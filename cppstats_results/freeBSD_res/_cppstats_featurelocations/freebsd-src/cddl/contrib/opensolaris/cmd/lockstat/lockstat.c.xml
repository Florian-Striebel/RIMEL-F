<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/cddl/contrib/opensolaris/cmd/lockstat/lockstat.c">
























<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>ident</name> <cpp:literal>"%Z%%M% %I% %E% SMI"</cpp:literal></cpp:pragma>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;strings.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/modctl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/wait.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dtrace.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/lockstat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;alloca.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>illumos</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GETOPT_EOF</name></cpp:macro> <cpp:value>EOF</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/resource.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>mergesort</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>, <parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>lsmergesort(a, b, c, d)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GETOPT_EOF</name></cpp:macro> <cpp:value>(-1)</cpp:value></cpp:define>

<typedef>typedef <type><name>uintptr_t</name></type> <name>pc_t</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOCKSTAT_OPTSTR</name></cpp:macro> <cpp:value>"x:bths:n:d:i:l:f:e:ckwWgCHEATID:RpPo:V"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LS_MAX_STACK_DEPTH</name></cpp:macro> <cpp:value>50</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LS_MAX_EVENTS</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>lsrec</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>lsrec</name></name> <modifier>*</modifier></type><name>ls_next</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>illumos</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>uintptr_t</name></type> <name>ls_lock</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ls_lock</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>uintptr_t</name></type> <name>ls_caller</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>ls_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>ls_event</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uintptr_t</name></type> <name>ls_refcnt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>ls_time</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name><name>ls_hist</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uintptr_t</name></type> <name><name>ls_stack</name><index>[<expr><name>LS_MAX_STACK_DEPTH</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>lsrec_t</name>;</typedef>

<typedef>typedef <type><struct>struct <name>lsdata</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>lsrec</name></name> <modifier>*</modifier></type><name>lsd_next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lsd_count</name></decl>;</decl_stmt>
}</block></struct></type> <name>lsdata_t</name>;</typedef>






<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LS_BASIC</name></cpp:macro> <cpp:value>offsetof(lsrec_t, ls_time)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LS_TIME</name></cpp:macro> <cpp:value>offsetof(lsrec_t, ls_hist[0])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LS_HIST</name></cpp:macro> <cpp:value>offsetof(lsrec_t, ls_stack[0])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LS_STACK</name><parameter_list>(<parameter><type><name>depth</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>offsetof(lsrec_t, ls_stack[depth])</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>report_stats</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>lsrec_t</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>report_trace</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>lsrec_t</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>symtab_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier></type><name>addr_to_sym</name><parameter_list>(<parameter><decl><type><name>uintptr_t</name></type></decl></parameter>, <parameter><decl><type><name>uintptr_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>uintptr_t</name></type> <name>sym_to_addr</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>size_t</name></type> <name>sym_size</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier></type><name>strtok_r</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_NRECS</name></cpp:macro> <cpp:value>10000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_HZ</name></cpp:macro> <cpp:value>97</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_HZ</name></cpp:macro> <cpp:value>1000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_AGGSIZE</name></cpp:macro> <cpp:value>(16 * 1024)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_AGGSIZE</name></cpp:macro> <cpp:value>(32 * 1024 * 1024)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>g_stkdepth</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>g_topn</name> <init>= <expr><name>INT_MAX</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>hrtime_t</name></type> <name>g_elapsed</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>g_rates</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>g_pflag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>g_Pflag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>g_wflag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>g_Wflag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>g_cflag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>g_kflag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>g_gflag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>g_Vflag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>g_tracing</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name>g_recsize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name>g_nrecs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>g_nrecs_used</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uchar_t</name></type> <name><name>g_enabled</name><index>[<expr><name>LS_MAX_EVENTS</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>hrtime_t</name></type> <name><name>g_min_duration</name><index>[<expr><name>LS_MAX_EVENTS</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>g_dtp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>g_predicate</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>g_ipredicate</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>g_prog</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>g_proglen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>g_dropped</name></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct <name>ls_event_info</name> <block>{
<decl_stmt><decl><type><name>char</name></type> <name>ev_type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>ev_lhdr</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>ev_desc</name><index>[<expr><literal type="number">80</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>ev_units</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>ev_name</name><index>[<expr><name>DTRACE_NAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ev_predicate</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ev_acquire</name></decl>;</decl_stmt>
}</block></struct></type> <name>ls_event_info_t</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>ls_event_info_t</name></type> <name><name>g_event_info</name><index>[<expr><name>LS_MAX_EVENTS</name></expr>]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><literal type="char">'C'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"Adaptive mutex spin"</literal></expr>, <expr><literal type="string">"nsec"</literal></expr>,
<expr><literal type="string">"lockstat:::adaptive-spin"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'C'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"Adaptive mutex block"</literal></expr>, <expr><literal type="string">"nsec"</literal></expr>,
<expr><literal type="string">"lockstat:::adaptive-block"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'C'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"Spin lock spin"</literal></expr>, <expr><literal type="string">"nsec"</literal></expr>,
<expr><literal type="string">"lockstat:::spin-spin"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'C'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"Thread lock spin"</literal></expr>, <expr><literal type="string">"nsec"</literal></expr>,
<expr><literal type="string">"lockstat:::thread-spin"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'C'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"R/W writer blocked by writer"</literal></expr>, <expr><literal type="string">"nsec"</literal></expr>,
<expr><literal type="string">"lockstat:::rw-block"</literal></expr>, <expr><literal type="string">"arg2 == 0 &amp;&amp; arg3 == 1"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'C'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"R/W writer blocked by readers"</literal></expr>, <expr><literal type="string">"nsec"</literal></expr>,
<expr><literal type="string">"lockstat:::rw-block"</literal></expr>, <expr><literal type="string">"arg2 == 0 &amp;&amp; arg3 == 0 &amp;&amp; arg4"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'C'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"R/W reader blocked by writer"</literal></expr>, <expr><literal type="string">"nsec"</literal></expr>,
<expr><literal type="string">"lockstat:::rw-block"</literal></expr>, <expr><literal type="string">"arg2 == 1 &amp;&amp; arg3 == 1"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'C'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"R/W reader blocked by write wanted"</literal></expr>, <expr><literal type="string">"nsec"</literal></expr>,
<expr><literal type="string">"lockstat:::rw-block"</literal></expr>, <expr><literal type="string">"arg2 == 1 &amp;&amp; arg3 == 0 &amp;&amp; arg4"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'C'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"R/W writer spin on writer"</literal></expr>, <expr><literal type="string">"nsec"</literal></expr>,
<expr><literal type="string">"lockstat:::rw-spin"</literal></expr>, <expr><literal type="string">"arg2 == 0 &amp;&amp; arg3 == 1"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'C'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"R/W writer spin on readers"</literal></expr>, <expr><literal type="string">"nsec"</literal></expr>,
<expr><literal type="string">"lockstat:::rw-spin"</literal></expr>, <expr><literal type="string">"arg2 == 0 &amp;&amp; arg3 == 0 &amp;&amp; arg4"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'C'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"R/W reader spin on writer"</literal></expr>, <expr><literal type="string">"nsec"</literal></expr>,
<expr><literal type="string">"lockstat:::rw-spin"</literal></expr>, <expr><literal type="string">"arg2 == 1 &amp;&amp; arg3 == 1"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'C'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"R/W reader spin on write wanted"</literal></expr>, <expr><literal type="string">"nsec"</literal></expr>,
<expr><literal type="string">"lockstat:::rw-spin"</literal></expr>, <expr><literal type="string">"arg2 == 1 &amp;&amp; arg3 == 0 &amp;&amp; arg4"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'C'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"SX exclusive block"</literal></expr>, <expr><literal type="string">"nsec"</literal></expr>,
<expr><literal type="string">"lockstat:::sx-block"</literal></expr>, <expr><literal type="string">"arg2 == 0"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'C'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"SX shared block"</literal></expr>, <expr><literal type="string">"nsec"</literal></expr>,
<expr><literal type="string">"lockstat:::sx-block"</literal></expr>, <expr><literal type="string">"arg2 == 1"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'C'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"SX exclusive spin"</literal></expr>, <expr><literal type="string">"nsec"</literal></expr>,
<expr><literal type="string">"lockstat:::sx-spin"</literal></expr>, <expr><literal type="string">"arg2 == 0"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'C'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"SX shared spin"</literal></expr>, <expr><literal type="string">"nsec"</literal></expr>,
<expr><literal type="string">"lockstat:::sx-spin"</literal></expr>, <expr><literal type="string">"arg2 == 1"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'C'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"lockmgr writer blocked by writer"</literal></expr>, <expr><literal type="string">"nsec"</literal></expr>,
<expr><literal type="string">"lockstat:::lockmgr-block"</literal></expr>, <expr><literal type="string">"arg2 == 0 &amp;&amp; arg3 == 1"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'C'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"lockmgr writer blocked by readers"</literal></expr>, <expr><literal type="string">"nsec"</literal></expr>,
<expr><literal type="string">"lockstat:::lockmgr-block"</literal></expr>, <expr><literal type="string">"arg2 == 0 &amp;&amp; arg3 == 0 &amp;&amp; arg4"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'C'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"lockmgr reader blocked by writer"</literal></expr>, <expr><literal type="string">"nsec"</literal></expr>,
<expr><literal type="string">"lockstat:::lockmgr-block"</literal></expr>, <expr><literal type="string">"arg2 == 1 &amp;&amp; arg3 == 1"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'C'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"lockmgr reader blocked by write wanted"</literal></expr>, <expr><literal type="string">"nsec"</literal></expr>,
<expr><literal type="string">"lockstat:::lockmgr-block"</literal></expr>, <expr><literal type="string">"arg2 == 1 &amp;&amp; arg3 == 0 &amp;&amp; arg4"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'C'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"Unknown event (type 20)"</literal></expr>, <expr><literal type="string">"units"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'C'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"Unknown event (type 21)"</literal></expr>, <expr><literal type="string">"units"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'C'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"Unknown event (type 22)"</literal></expr>, <expr><literal type="string">"units"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'C'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"Unknown event (type 23)"</literal></expr>, <expr><literal type="string">"units"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'C'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"Unknown event (type 24)"</literal></expr>, <expr><literal type="string">"units"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'C'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"Unknown event (type 25)"</literal></expr>, <expr><literal type="string">"units"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'C'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"Unknown event (type 26)"</literal></expr>, <expr><literal type="string">"units"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'C'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"Unknown event (type 27)"</literal></expr>, <expr><literal type="string">"units"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'C'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"Unknown event (type 28)"</literal></expr>, <expr><literal type="string">"units"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'C'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"Unknown event (type 29)"</literal></expr>, <expr><literal type="string">"units"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'C'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"Unknown event (type 30)"</literal></expr>, <expr><literal type="string">"units"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'C'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"Unknown event (type 31)"</literal></expr>, <expr><literal type="string">"units"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'H'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"Adaptive mutex hold"</literal></expr>, <expr><literal type="string">"nsec"</literal></expr>,
<expr><literal type="string">"lockstat:::adaptive-release"</literal></expr>, <expr><name>NULL</name></expr>,
<expr><literal type="string">"lockstat:::adaptive-acquire"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'H'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"Spin lock hold"</literal></expr>, <expr><literal type="string">"nsec"</literal></expr>,
<expr><literal type="string">"lockstat:::spin-release"</literal></expr>, <expr><name>NULL</name></expr>,
<expr><literal type="string">"lockstat:::spin-acquire"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'H'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"R/W writer hold"</literal></expr>, <expr><literal type="string">"nsec"</literal></expr>,
<expr><literal type="string">"lockstat:::rw-release"</literal></expr>, <expr><literal type="string">"arg1 == 0"</literal></expr>,
<expr><literal type="string">"lockstat:::rw-acquire"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'H'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"R/W reader hold"</literal></expr>, <expr><literal type="string">"nsec"</literal></expr>,
<expr><literal type="string">"lockstat:::rw-release"</literal></expr>, <expr><literal type="string">"arg1 == 1"</literal></expr>,
<expr><literal type="string">"lockstat:::rw-acquire"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'H'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"SX shared hold"</literal></expr>, <expr><literal type="string">"nsec"</literal></expr>,
<expr><literal type="string">"lockstat:::sx-release"</literal></expr>, <expr><literal type="string">"arg1 == 1"</literal></expr>,
<expr><literal type="string">"lockstat:::sx-acquire"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'H'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"SX exclusive hold"</literal></expr>, <expr><literal type="string">"nsec"</literal></expr>,
<expr><literal type="string">"lockstat:::sx-release"</literal></expr>, <expr><literal type="string">"arg1 == 0"</literal></expr>,
<expr><literal type="string">"lockstat:::sx-acquire"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'H'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"lockmgr shared hold"</literal></expr>, <expr><literal type="string">"nsec"</literal></expr>,
<expr><literal type="string">"lockstat:::lockmgr-release"</literal></expr>, <expr><literal type="string">"arg1 == 1"</literal></expr>,
<expr><literal type="string">"lockstat:::lockmgr-acquire"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'H'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"lockmgr exclusive hold"</literal></expr>, <expr><literal type="string">"nsec"</literal></expr>,
<expr><literal type="string">"lockstat:::lockmgr-release,lockstat:::lockmgr-disown"</literal></expr>, <expr><literal type="string">"arg1 == 0"</literal></expr>,
<expr><literal type="string">"lockstat:::lockmgr-acquire"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'H'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"Unknown event (type 40)"</literal></expr>, <expr><literal type="string">"units"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'H'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"Unknown event (type 41)"</literal></expr>, <expr><literal type="string">"units"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'H'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"Unknown event (type 42)"</literal></expr>, <expr><literal type="string">"units"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'H'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"Unknown event (type 43)"</literal></expr>, <expr><literal type="string">"units"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'H'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"Unknown event (type 44)"</literal></expr>, <expr><literal type="string">"units"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'H'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"Unknown event (type 45)"</literal></expr>, <expr><literal type="string">"units"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'H'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"Unknown event (type 46)"</literal></expr>, <expr><literal type="string">"units"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'H'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"Unknown event (type 47)"</literal></expr>, <expr><literal type="string">"units"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'H'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"Unknown event (type 48)"</literal></expr>, <expr><literal type="string">"units"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'H'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"Unknown event (type 49)"</literal></expr>, <expr><literal type="string">"units"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'H'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"Unknown event (type 50)"</literal></expr>, <expr><literal type="string">"units"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'H'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"Unknown event (type 51)"</literal></expr>, <expr><literal type="string">"units"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'H'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"Unknown event (type 52)"</literal></expr>, <expr><literal type="string">"units"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'H'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"Unknown event (type 53)"</literal></expr>, <expr><literal type="string">"units"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'H'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"Unknown event (type 54)"</literal></expr>, <expr><literal type="string">"units"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'H'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"Unknown event (type 55)"</literal></expr>, <expr><literal type="string">"units"</literal></expr> }</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>illumos</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{ <expr><literal type="char">'I'</literal></expr>, <expr><literal type="string">"CPU+PIL"</literal></expr>, <expr><literal type="string">"Profiling interrupt"</literal></expr>, <expr><literal type="string">"nsec"</literal></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr><block>{ <expr><literal type="char">'I'</literal></expr>, <expr><literal type="string">"CPU+Pri_Class"</literal></expr>, <expr><literal type="string">"Profiling interrupt"</literal></expr>, <expr><literal type="string">"nsec"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><literal type="string">"profile:::profile-97"</literal></expr>, <expr><name>NULL</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'I'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"Unknown event (type 57)"</literal></expr>, <expr><literal type="string">"units"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'I'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"Unknown event (type 58)"</literal></expr>, <expr><literal type="string">"units"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'I'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"Unknown event (type 59)"</literal></expr>, <expr><literal type="string">"units"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'E'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"Recursive lock entry detected"</literal></expr>, <expr><literal type="string">"(N/A)"</literal></expr>,
<expr><literal type="string">"lockstat:::rw-release"</literal></expr>, <expr><name>NULL</name></expr>, <expr><literal type="string">"lockstat:::rw-acquire"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'E'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"Lockstat enter failure"</literal></expr>, <expr><literal type="string">"(N/A)"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'E'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"Lockstat exit failure"</literal></expr>, <expr><literal type="string">"nsec"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="char">'E'</literal></expr>, <expr><literal type="string">"Lock"</literal></expr>, <expr><literal type="string">"Lockstat record failure"</literal></expr>, <expr><literal type="string">"(N/A)"</literal></expr> }</block></expr>,
}</block></expr>;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>illumos</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><specifier>static</specifier> <name>char</name> <operator>*</operator><name><name>g_pri_class</name><index>[]</index></name> <operator>=</operator> <block>{
<expr><literal type="string">""</literal></expr>,
<expr><literal type="string">"Intr"</literal></expr>,
<expr><literal type="string">"RealT"</literal></expr>,
<expr><literal type="string">"TShar"</literal></expr>,
<expr><literal type="string">"Idle"</literal></expr>
}</block></expr>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr><specifier>static</specifier> <name>void</name>
<macro><name>fail</name><argument_list>(<argument>int do_perror</argument>, <argument>const char *message</argument>, <argument>...</argument>)</argument_list></macro>
<block>{
<expr><name>va_list</name> <name>args</name></expr>;
<expr><name>int</name> <name>save_errno</name> <operator>=</operator> <name>errno</name></expr>;

<expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;
<expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"lockstat: "</literal></expr></argument>)</argument_list></call></expr>;
<expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>vfprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><name>do_perror</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">": %s"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>save_errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></block></expr>;
<expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name>
<macro><name>dfail</name><argument_list>(<argument>const char *message</argument>, <argument>...</argument>)</argument_list></macro>
<block>{
<expr><name>va_list</name> <name>args</name></expr>;

<expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;
<expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"lockstat: "</literal></expr></argument>)</argument_list></call></expr>;
<expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>vfprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;
<expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">": %s\n"</literal></expr></argument>,
<argument><expr><call><name>dtrace_errmsg</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>, <argument><expr><call><name>dtrace_errno</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;

<expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name>
<macro><name>show_events</name><argument_list>(<argument>char event_type</argument>, <argument>char *desc</argument>)</argument_list></macro>
<block>{
<expr><name>int</name> <name>i</name></expr>, <expr><name>first</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>, <expr><name>last</name></expr>;

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>LS_MAX_EVENTS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ls_event_info_t</name> <modifier>*</modifier></type><name>evp</name> <init>= <expr><operator>&amp;</operator><name><name>g_event_info</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>evp</name><operator>-&gt;</operator><name>ev_type</name></name> <operator>!=</operator> <name>event_type</name> <operator>||</operator>
<call><name>strncmp</name><argument_list>(<argument><expr><name><name>evp</name><operator>-&gt;</operator><name>ev_desc</name></name></expr></argument>, <argument><expr><literal type="string">"Unknown event"</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>first</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>first</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>last</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt/>}</block_content>

(void</block></for>) <call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"\n%s events (lockstat -%c or lockstat -e %d-%d):\n\n"</literal></expr></argument>,
<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>event_type</name></expr></argument>, <argument><expr><name>first</name></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call></block></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>first</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>last</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"%4d = %s\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>g_event_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ev_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
}

static <function><type><name>void</name></type>
<name>usage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"Usage: lockstat [options] command [args]\n"</literal>
<literal type="string">"\nGeneral options:\n\n"</literal>
<literal type="string">" -V print the corresponding D program\n"</literal>
<literal type="string">"\nEvent selection options:\n\n"</literal>
<literal type="string">" -C watch contention events [on by default]\n"</literal>
<literal type="string">" -E watch error events [off by default]\n"</literal>
<literal type="string">" -H watch hold events [off by default]\n"</literal>
<literal type="string">" -I watch interrupt events [off by default]\n"</literal>
<literal type="string">" -A watch all lock events [equivalent to -CH]\n"</literal>
<literal type="string">" -e event_list only watch the specified events (shown below);\n"</literal>
<literal type="string">" &lt;event_list&gt; is a comma-separated list of\n"</literal>
<literal type="string">" events or ranges of events, e.g. 1,4-7,35\n"</literal>
<literal type="string">" -i rate interrupt rate for -I [default: %d Hz]\n"</literal>
<literal type="string">"\nData gathering options:\n\n"</literal>
<literal type="string">" -b basic statistics (lock, caller, event count)\n"</literal>
<literal type="string">" -t timing for all events [default]\n"</literal>
<literal type="string">" -h histograms for event times\n"</literal>
<literal type="string">" -s depth stack traces &lt;depth&gt; deep\n"</literal>
<literal type="string">" -x opt[=val] enable or modify DTrace options\n"</literal>
<literal type="string">"\nData filtering options:\n\n"</literal>
<literal type="string">" -n nrecords maximum number of data records [default: %d]\n"</literal>
<literal type="string">" -l lock[,size] only watch &lt;lock&gt;, which can be specified as a\n"</literal>
<literal type="string">" symbolic name or hex address; &lt;size&gt; defaults\n"</literal>
<literal type="string">" to the ELF symbol size if available, 1 if not\n"</literal>
<literal type="string">" -f func[,size] only watch events generated by &lt;func&gt;\n"</literal>
<literal type="string">" -d duration only watch events longer than &lt;duration&gt;\n"</literal>
<literal type="string">" -T trace (rather than sample) events\n"</literal>
<literal type="string">"\nData reporting options:\n\n"</literal>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>illumos</name></expr></argument>)</argument_list></call></expr></cpp:if>
<literal type="string">" -c coalesce lock data for arrays like pse_mutex[]\n"</literal>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<literal type="string">" -k coalesce PCs within functions\n"</literal>
<literal type="string">" -g show total events generated by function\n"</literal>
<literal type="string">" -w wherever: don't distinguish events by caller\n"</literal>
<literal type="string">" -W whichever: don't distinguish events by lock\n"</literal>
<literal type="string">" -R display rates rather than counts\n"</literal>
<literal type="string">" -p parsable output format (awk(1)-friendly)\n"</literal>
<literal type="string">" -P sort lock data by (count * avg_time) product\n"</literal>
<literal type="string">" -D n only display top &lt;n&gt; events of each type\n"</literal>
<literal type="string">" -o filename send output to &lt;filename&gt;\n"</literal></expr></argument>,
<argument><expr><name>DEFAULT_HZ</name></expr></argument>, <argument><expr><name>DEFAULT_NRECS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>show_events</name><argument_list>(<argument><expr><literal type="char">'C'</literal></expr></argument>, <argument><expr><literal type="string">"Contention"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>show_events</name><argument_list>(<argument><expr><literal type="char">'H'</literal></expr></argument>, <argument><expr><literal type="string">"Hold-time"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>show_events</name><argument_list>(<argument><expr><literal type="char">'I'</literal></expr></argument>, <argument><expr><literal type="string">"Interrupt"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>show_events</name><argument_list>(<argument><expr><literal type="char">'E'</literal></expr></argument>, <argument><expr><literal type="string">"Error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>lockcmp</name><parameter_list>(<parameter><decl><type><name>lsrec_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>lsrec_t</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>ls_event</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>ls_event</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>ls_event</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>ls_event</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>g_stkdepth</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>ls_stack</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>ls_stack</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>ls_stack</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>ls_stack</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>ls_caller</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>ls_caller</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>ls_caller</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>ls_caller</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>illumos</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>ls_lock</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>ls_lock</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>ls_lock</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>ls_lock</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>ls_lock</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>ls_lock</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>countcmp</name><parameter_list>(<parameter><decl><type><name>lsrec_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>lsrec_t</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>ls_event</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>ls_event</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>ls_event</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>ls_event</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><name><name>b</name><operator>-&gt;</operator><name>ls_count</name></name> <operator>-</operator> <name><name>a</name><operator>-&gt;</operator><name>ls_count</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>timecmp</name><parameter_list>(<parameter><decl><type><name>lsrec_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>lsrec_t</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>ls_event</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>ls_event</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>ls_event</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>ls_event</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>ls_time</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>ls_time</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>ls_time</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>ls_time</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>lockcmp_anywhere</name><parameter_list>(<parameter><decl><type><name>lsrec_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>lsrec_t</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>ls_event</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>ls_event</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>ls_event</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>ls_event</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>illumos</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>ls_lock</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>ls_lock</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>ls_lock</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>ls_lock</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>ls_lock</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>ls_lock</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>lock_and_count_cmp_anywhere</name><parameter_list>(<parameter><decl><type><name>lsrec_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>lsrec_t</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>illumos</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>cmp</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>ls_event</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>ls_event</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>ls_event</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>ls_event</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>illumos</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>ls_lock</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>ls_lock</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>ls_lock</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>ls_lock</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>ls_lock</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>ls_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>cmp</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><operator>(</operator><name><name>b</name><operator>-&gt;</operator><name>ls_count</name></name> <operator>-</operator> <name><name>a</name><operator>-&gt;</operator><name>ls_count</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>sitecmp_anylock</name><parameter_list>(<parameter><decl><type><name>lsrec_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>lsrec_t</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>ls_event</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>ls_event</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>ls_event</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>ls_event</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>g_stkdepth</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>ls_stack</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>ls_stack</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>ls_stack</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>ls_stack</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>ls_caller</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>ls_caller</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>ls_caller</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>ls_caller</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>site_and_count_cmp_anylock</name><parameter_list>(<parameter><decl><type><name>lsrec_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>lsrec_t</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>ls_event</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>ls_event</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>ls_event</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>ls_event</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>g_stkdepth</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>ls_stack</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>ls_stack</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>ls_stack</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>ls_stack</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>ls_caller</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>ls_caller</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>ls_caller</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>ls_caller</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><name><name>b</name><operator>-&gt;</operator><name>ls_count</name></name> <operator>-</operator> <name><name>a</name><operator>-&gt;</operator><name>ls_count</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>lsmergesort</name><parameter_list>(<parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>cmp</name>)<parameter_list>(<parameter><decl><type><name>lsrec_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>lsrec_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>lsrec_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>lsrec_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>m</name> <init>= <expr><name>n</name> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>m</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>lsmergesort</name><argument_list>(<argument><expr><name>cmp</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>-</operator> <name>m</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>lsmergesort</name><argument_list>(<argument><expr><name>cmp</name></expr></argument>, <argument><expr><name>a</name> <operator>+</operator> <name>m</name></expr></argument>, <argument><expr><name>b</name> <operator>+</operator> <name>m</name></expr></argument>, <argument><expr><name>n</name> <operator>-</operator> <name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>m</name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>b</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>a</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>m</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>n</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>b</name><index>[<expr><name>n</name> <operator>+</operator> <name>m</name> <operator>-</operator> <name>j</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>a</name><index>[<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
<while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>j</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>a</name><operator>++</operator> <operator>=</operator> <ternary><condition><expr><call><name>cmp</name><argument_list>(<argument><expr><name><name>b</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>b</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name></expr> </then><else>: <expr><name><name>b</name><index>[<expr><name>j</name><operator>--</operator></expr>]</index></name></expr></else></ternary></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><operator>*</operator><name>a</name> <operator>=</operator> <name><name>b</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>coalesce</name><parameter_list>(<parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>cmp</name>)<parameter_list>(<parameter><decl><type><name>lsrec_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>lsrec_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>lsrec_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>lock</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lsrec_t</name> <modifier>*</modifier></type><name>target</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>current</name></decl>;</decl_stmt>

<expr_stmt><expr><name>target</name> <operator>=</operator> <name><name>lock</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>current</name> <operator>=</operator> <name><name>lock</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>cmp</name><argument_list>(<argument><expr><name>current</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>target</name> <operator>=</operator> <name>current</name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>current</name><operator>-&gt;</operator><name>ls_event</name></name> <operator>=</operator> <name>LS_MAX_EVENTS</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>ls_count</name></name> <operator>+=</operator> <name><name>current</name><operator>-&gt;</operator><name>ls_count</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>ls_refcnt</name></name> <operator>+=</operator> <name><name>current</name><operator>-&gt;</operator><name>ls_refcnt</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>g_recsize</name> <operator>&lt;</operator> <name>LS_TIME</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>ls_time</name></name> <operator>+=</operator> <name><name>current</name><operator>-&gt;</operator><name>ls_time</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>g_recsize</name> <operator>&lt;</operator> <name>LS_HIST</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">64</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>ls_hist</name><index>[<expr><name>j</name></expr>]</index></name> <operator>+=</operator> <name><name>current</name><operator>-&gt;</operator><name>ls_hist</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>coalesce_symbol</name><parameter_list>(<parameter><decl><type><name>uintptr_t</name> <modifier>*</modifier></type><name>addrp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uintptr_t</name></type> <name>symoff</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>symsize</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>addr_to_sym</name><argument_list>(<argument><expr><operator>*</operator><name>addrp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>symoff</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>symsize</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>symoff</name> <operator>&lt;</operator> <name>symsize</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>addrp</name> <operator>-=</operator> <name>symoff</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>predicate_add</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pred</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>what</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cmp</name></decl></parameter>, <parameter><decl><type><name>uintptr_t</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>new</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>newlen</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>what</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>pred</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>pred</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name><name>pred</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><operator>*</operator><name>pred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>newlen</name> <operator>=</operator> <name>len</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>what</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">32</literal> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"( &amp;&amp; )"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>new</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>newlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>pred</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>new</name></expr></argument>, <argument><expr><literal type="string">"(%s) &amp;&amp; (%s %s 0x%p)"</literal></expr></argument>,
<argument><expr><operator>*</operator><name>pred</name></expr></argument>, <argument><expr><name>what</name></expr></argument>, <argument><expr><name>cmp</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>new</name></expr></argument>, <argument><expr><literal type="string">"(%s) &amp;&amp; (%s)"</literal></expr></argument>, <argument><expr><operator>*</operator><name>pred</name></expr></argument>, <argument><expr><name>what</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>new</name></expr></argument>, <argument><expr><literal type="string">"%s %s 0x%p"</literal></expr></argument>,
<argument><expr><name>what</name></expr></argument>, <argument><expr><name>cmp</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>new</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>what</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>*</operator><name>pred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>pred</name> <operator>=</operator> <name>new</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>predicate_destroy</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pred</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>*</operator><name>pred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>pred</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>filter_add</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>filt</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>what</name></decl></parameter>, <parameter><decl><type><name>uintptr_t</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>uintptr_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>c</name> <init>= <expr><name>buf</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>new</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>newlen</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>filt</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>filt</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name><name>filt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>illumos</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="string">"%s(%s &gt;= 0x%p &amp;&amp; %s &lt; 0x%p)"</literal></expr></argument>, <argument><expr><ternary><condition><expr><operator>*</operator><name><name>filt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr> ?</condition><then>
<expr><literal type="string">" || "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name>what</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>base</name></expr></argument>, <argument><expr><name>what</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>base</name> <operator>+</operator> <name>size</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="string">"%s(%s &gt;= %p &amp;&amp; %s &lt; %p)"</literal></expr></argument>, <argument><expr><ternary><condition><expr><operator>*</operator><name><name>filt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr> ?</condition><then>
<expr><literal type="string">" || "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name>what</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>base</name></expr></argument>, <argument><expr><name>what</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>base</name> <operator>+</operator> <name>size</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>newlen</name> <operator>=</operator> <operator>(</operator><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><operator>*</operator><name>filt</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>new</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>newlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bcopy</name><argument_list>(<argument><expr><operator>*</operator><name>filt</name></expr></argument>, <argument><expr><name>new</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>strcat</name><argument_list>(<argument><expr><name>new</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>*</operator><name>filt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>filt</name> <operator>=</operator> <name>new</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>filter_destroy</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>filt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>*</operator><name>filt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>filt</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dprog_add</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>va_list</name></type> <name>args</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>, <decl><type ref="prev"/><name>offs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>vsnprintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>g_proglen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>offs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>offs</name> <operator>=</operator> <name>g_proglen</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>g_proglen</name> <operator>=</operator> <name>offs</name> <operator>+</operator> <name>size</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>g_prog</name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name>g_prog</name></expr></argument>, <argument><expr><name>g_proglen</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"failed to reallocate program text"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>vsnprintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g_prog</name><index>[<expr><name>offs</name></expr>]</index></name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>void</name></type>
<name>dprog_addevent</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>event</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ls_event_info_t</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><operator>&amp;</operator><name><name>g_event_info</name><index>[<expr><name>event</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pred</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>stack</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>caller</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg1</name> <init>= <expr><literal type="string">"arg1"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">80</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>hrtime_t</name></type> <name>dur</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>depth</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>ev_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>ev_type</name></name> <operator>==</operator> <literal type="char">'I'</literal></expr>)</condition> <block>{<block_content>






<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>illumos</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>arg0</name> <operator>=</operator> <literal type="string">"(uintptr_t)curthread-&gt;t_cpu + \n"</literal>
<literal type="string">"\t curthread-&gt;t_cpu-&gt;cpu_profile_pil"</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>arg0</name> <operator>=</operator> <literal type="string">"(uintptr_t)(curthread-&gt;td_oncpu &lt;&lt; 16) + \n"</literal>
<literal type="string">"\t 0x01000000 + curthread-&gt;td_pri_class"</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>caller</name> <operator>=</operator> <literal type="string">"(uintptr_t)arg0"</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>arg1</name> <operator>=</operator> <literal type="string">"arg2"</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>illumos</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>arg0</name> <operator>=</operator> <literal type="string">"(uintptr_t)arg0"</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>arg0</name> <operator>=</operator> <literal type="string">"stringof(args[0]-&gt;lock_object.lo_name)"</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>caller</name> <operator>=</operator> <literal type="string">"caller"</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>g_recsize</name> <operator>&gt;</operator> <name>LS_HIST</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>depth</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>g_recsize</name> <operator>&gt;</operator> <call><name>LS_STACK</name><argument_list>(<argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>depth</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>g_tracing</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><literal type="string">"\tstack(%d);\n"</literal></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><literal type="string">", stack(%d)"</literal></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>ev_acquire</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>





<expr_stmt><expr><call><name>dprog_add</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>info</name><operator>-&gt;</operator><name>ev_acquire</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>predicate_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pred</name></expr></argument>, <argument><expr><name><name>info</name><operator>-&gt;</operator><name>ev_predicate</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>predicate_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pred</name></expr></argument>, <argument><expr><name>g_predicate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pred</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dprog_add</name><argument_list>(<argument><expr><literal type="string">"/%s/\n"</literal></expr></argument>, <argument><expr><name>pred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>dprog_add</name><argument_list>(<argument><expr><literal type="string">"{\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"self-&gt;ev%d[(uintptr_t)arg0]"</literal></expr></argument>, <argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>ev_type</name></name> <operator>==</operator> <literal type="char">'H'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dprog_add</name><argument_list>(<argument><expr><literal type="string">"\t%s = timestamp;\n"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>





<expr_stmt><expr><call><name>dprog_add</name><argument_list>(<argument><expr><literal type="string">"\t%s++;\n"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>dprog_add</name><argument_list>(<argument><expr><literal type="string">"}\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>predicate_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pred</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>ev_type</name></name> <operator>==</operator> <literal type="char">'E'</literal></expr>)</condition> <block>{<block_content>







<expr_stmt><expr><call><name>dprog_add</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>info</name><operator>-&gt;</operator><name>ev_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dprog_add</name><argument_list>(<argument><expr><literal type="string">"/%s/\n{\n\t%s--;\n}\n\n"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>predicate_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pred</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>ev_type</name></name> <operator>==</operator> <literal type="char">'H'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"timestamp -\n\t "</literal>
<literal type="string">"self-&gt;ev%d[(uintptr_t)arg0]"</literal></expr></argument>, <argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>arg1</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>predicate_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pred</name></expr></argument>, <argument><expr><name><name>info</name><operator>-&gt;</operator><name>ev_predicate</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>ev_type</name></name> <operator>!=</operator> <literal type="char">'I'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>predicate_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pred</name></expr></argument>, <argument><expr><name>g_predicate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>predicate_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pred</name></expr></argument>, <argument><expr><name>g_ipredicate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>dur</name> <operator>=</operator> <name><name>g_min_duration</name><index>[<expr><name>event</name></expr>]</index></name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>predicate_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pred</name></expr></argument>, <argument><expr><name>arg1</name></expr></argument>, <argument><expr><literal type="string">"&gt;="</literal></expr></argument>, <argument><expr><name>dur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>dprog_add</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>info</name><operator>-&gt;</operator><name>ev_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pred</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dprog_add</name><argument_list>(<argument><expr><literal type="string">"/%s/\n"</literal></expr></argument>, <argument><expr><name>pred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>predicate_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>dprog_add</name><argument_list>(<argument><expr><literal type="string">"{\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>g_tracing</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dprog_add</name><argument_list>(<argument><expr><literal type="string">"\ttrace(%dULL);\n"</literal></expr></argument>, <argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dprog_add</name><argument_list>(<argument><expr><literal type="string">"\ttrace(%s);\n"</literal></expr></argument>, <argument><expr><name>arg0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dprog_add</name><argument_list>(<argument><expr><literal type="string">"\ttrace(%s);\n"</literal></expr></argument>, <argument><expr><name>caller</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dprog_add</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>







<expr_stmt><expr><call><name>dprog_add</name><argument_list>(<argument><expr><literal type="string">"\t@avg[%dULL, %s, %s%s] = avg(%s);\n"</literal></expr></argument>,
<argument><expr><name>event</name></expr></argument>, <argument><expr><name>arg0</name></expr></argument>, <argument><expr><name>caller</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>g_recsize</name> <operator>&gt;=</operator> <name>LS_HIST</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dprog_add</name><argument_list>(<argument><expr><literal type="string">"\t@hist[%dULL, %s, %s%s] = quantize"</literal>
<literal type="string">"(%s);\n"</literal></expr></argument>, <argument><expr><name>event</name></expr></argument>, <argument><expr><name>arg0</name></expr></argument>, <argument><expr><name>caller</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>ev_acquire</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dprog_add</name><argument_list>(<argument><expr><literal type="string">"\tself-&gt;ev%d[arg0] = 0;\n"</literal></expr></argument>, <argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>dprog_add</name><argument_list>(<argument><expr><literal type="string">"}\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dprog_compile</name><parameter_list>()</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_prog_t</name> <modifier>*</modifier></type><name>prog</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_proginfo_t</name></type> <name>info</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>g_Vflag</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"lockstat: vvvv D program vvvv\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fputs</name><argument_list>(<argument><expr><name>g_prog</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"lockstat: ^^^^ D program ^^^^\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>prog</name> <operator>=</operator> <call><name>dtrace_program_strcompile</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>, <argument><expr><name>g_prog</name></expr></argument>,
<argument><expr><name>DTRACE_PROBESPEC_NAME</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dfail</name><argument_list>(<argument><expr><literal type="string">"failed to compile program"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dtrace_program_exec</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>, <argument><expr><name>prog</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dfail</name><argument_list>(<argument><expr><literal type="string">"failed to enable probes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dtrace_go</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dfail</name><argument_list>(<argument><expr><literal type="string">"couldn't start tracing"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>illumos</name></expr></argument>)</argument_list></call></expr></cpp:if>
<name>status_fire</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
status_fire<parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{<block_content/>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>status_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_optval_t</name></type> <name>val</name></decl>, <decl><type ref="prev"/><name>status</name></decl>, <decl><type ref="prev"/><name>agg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sigaction</name></name></type> <name>act</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>itimerspec</name></name></type> <name>ts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sigevent</name></name></type> <name>ev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>timer_t</name></type> <name>tid</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dtrace_getopt</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>, <argument><expr><literal type="string">"statusrate"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dfail</name><argument_list>(<argument><expr><literal type="string">"failed to get 'statusrate'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dtrace_getopt</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>, <argument><expr><literal type="string">"aggrate"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>agg</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dfail</name><argument_list>(<argument><expr><literal type="string">"failed to get 'statusrate'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>








<expr_stmt><expr><name>val</name> <operator>=</operator> <ternary><condition><expr><name>status</name> <operator>&lt;</operator> <name>agg</name></expr> ?</condition><then> <expr><name>status</name></expr> </then><else>: <expr><name>agg</name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sigemptyset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>act</name><operator>.</operator><name>sa_mask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>act</name><operator>.</operator><name>sa_flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>act</name><operator>.</operator><name>sa_handler</name></name> <operator>=</operator> <name>status_fire</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sigaction</name><argument_list>(<argument><expr><name>SIGUSR1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>act</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ev</name><operator>.</operator><name>sigev_notify</name></name> <operator>=</operator> <name>SIGEV_SIGNAL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ev</name><operator>.</operator><name>sigev_signo</name></name> <operator>=</operator> <name>SIGUSR1</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>timer_create</name><argument_list>(<argument><expr><name>CLOCK_REALTIME</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tid</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dfail</name><argument_list>(<argument><expr><literal type="string">"cannot create CLOCK_REALTIME timer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>ts</name><operator>.</operator><name>it_value</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <name>val</name> <operator>/</operator> <name>NANOSEC</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ts</name><operator>.</operator><name>it_value</name><operator>.</operator><name>tv_nsec</name></name> <operator>=</operator> <name>val</name> <operator>%</operator> <name>NANOSEC</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ts</name><operator>.</operator><name>it_interval</name></name> <operator>=</operator> <name><name>ts</name><operator>.</operator><name>it_value</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>timer_settime</name><argument_list>(<argument><expr><name>tid</name></expr></argument>, <argument><expr><name>TIMER_RELTIME</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dfail</name><argument_list>(<argument><expr><literal type="string">"cannot set time on CLOCK_REALTIME timer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>status_check</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>g_tracing</name> <operator>&amp;&amp;</operator> <call><name>dtrace_aggregate_snap</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dfail</name><argument_list>(<argument><expr><literal type="string">"failed to snap aggregate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dtrace_status</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dfail</name><argument_list>(<argument><expr><literal type="string">"dtrace_status()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>lsrec_fill</name><parameter_list>(<parameter><decl><type><name>lsrec_t</name> <modifier>*</modifier></type><name>lsrec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>dtrace_recdesc_t</name> <modifier>*</modifier></type><name>rec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nrecs</name></decl></parameter>, <parameter><decl><type><name>caddr_t</name></type> <name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>bzero</name><argument_list>(<argument><expr><name>lsrec</name></expr></argument>, <argument><expr><name>g_recsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lsrec</name><operator>-&gt;</operator><name>ls_count</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>g_recsize</name> <operator>&gt;</operator> <name>LS_HIST</name> <operator>&amp;&amp;</operator> <name>nrecs</name> <operator>&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>nrecs</name> <operator>&lt;</operator> <literal type="number">3</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"truncated DTrace record"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>dtrd_size</name></name> <operator>!=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"bad event size in first record"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name><name>lsrec</name><operator>-&gt;</operator><name>ls_event</name></name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>*</operator><operator>(</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>data</name> <operator>+</operator> <name><name>rec</name><operator>-&gt;</operator><name>dtrd_offset</name></name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>rec</name><operator>++</operator></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>illumos</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>dtrd_size</name></name> <operator>!=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uintptr_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"bad lock address size in second record"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name><name>lsrec</name><operator>-&gt;</operator><name>ls_lock</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>uintptr_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>data</name> <operator>+</operator> <name><name>rec</name><operator>-&gt;</operator><name>dtrd_offset</name></name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>rec</name><operator>++</operator></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name><name>lsrec</name><operator>-&gt;</operator><name>ls_lock</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>data</name> <operator>+</operator> <name><name>rec</name><operator>-&gt;</operator><name>dtrd_offset</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rec</name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>dtrd_size</name></name> <operator>!=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uintptr_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"bad caller size in third record"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name><name>lsrec</name><operator>-&gt;</operator><name>ls_caller</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>uintptr_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>data</name> <operator>+</operator> <name><name>rec</name><operator>-&gt;</operator><name>dtrd_offset</name></name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>rec</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>g_recsize</name> <operator>&gt;</operator> <name>LS_HIST</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>frames</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>pc_t</name> <modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>

<expr_stmt><expr><name>frames</name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>dtrd_size</name></name> <operator>/</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>pc_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<expr_stmt><expr><name>stack</name> <operator>=</operator> <operator>(</operator><name>pc_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>data</name> <operator>+</operator> <name><name>rec</name><operator>-&gt;</operator><name>dtrd_offset</name></name><operator>)</operator></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>frames</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>lsrec</name><operator>-&gt;</operator><name>ls_stack</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>stack</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>count_aggregate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dtrace_aggdata_t</name> <modifier>*</modifier></type><name>agg</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>size_t</name> <operator>*</operator><operator>)</operator><name>arg</name><operator>)</operator> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>DTRACE_AGGWALK_NEXT</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>process_aggregate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dtrace_aggdata_t</name> <modifier>*</modifier></type><name>agg</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>dtrace_aggdesc_t</name> <modifier>*</modifier></type><name>aggdesc</name> <init>= <expr><name><name>agg</name><operator>-&gt;</operator><name>dtada_desc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>caddr_t</name></type> <name>data</name> <init>= <expr><name><name>agg</name><operator>-&gt;</operator><name>dtada_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lsdata_t</name> <modifier>*</modifier></type><name>lsdata</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lsrec_t</name> <modifier>*</modifier></type><name>lsrec</name> <init>= <expr><name><name>lsdata</name><operator>-&gt;</operator><name>lsd_next</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>dtrace_recdesc_t</name> <modifier>*</modifier></type><name>rec</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>avg</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>quantized</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>lsdata</name><operator>-&gt;</operator><name>lsd_count</name></name> <operator>&lt;</operator> <name>g_nrecs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>










<if_stmt><if>if <condition>(<expr><name><name>aggdesc</name><operator>-&gt;</operator><name>dtagd_varid</name></name> <operator>&gt;</operator> <name>DTRACE_AGGVARIDNONE</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>




<expr_stmt><expr><name>rec</name> <operator>=</operator> <operator>&amp;</operator><name><name>aggdesc</name><operator>-&gt;</operator><name>dtagd_rec</name><index>[<expr><name><name>aggdesc</name><operator>-&gt;</operator><name>dtagd_nrecs</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>aggdesc</name><operator>-&gt;</operator><name>dtagd_varid</name></name> <operator>!=</operator> <name>DTRACE_AGGVARIDNONE</name> <operator>+</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"bad variable ID in aggregation record"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>dtrd_size</name></name> <operator>!=</operator>
<name>DTRACE_QUANTIZE_NBUCKETS</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"bad quantize size in aggregation record"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name>quantized</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>data</name> <operator>+</operator> <name><name>rec</name><operator>-&gt;</operator><name>dtrd_offset</name></name><operator>)</operator></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>DTRACE_QUANTIZE_ZEROBUCKET</name></expr><operator>,</operator> <expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init>
<condition><expr><name>i</name> <operator>&lt;</operator> <name>DTRACE_QUANTIZE_NBUCKETS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>lsrec</name><operator>-&gt;</operator><name>ls_hist</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>quantized</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

<goto>goto <name>out</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>lsrec_fill</name><argument_list>(<argument><expr><name>lsrec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aggdesc</name><operator>-&gt;</operator><name>dtagd_rec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
<argument><expr><name><name>aggdesc</name><operator>-&gt;</operator><name>dtagd_nrecs</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rec</name> <operator>=</operator> <operator>&amp;</operator><name><name>aggdesc</name><operator>-&gt;</operator><name>dtagd_rec</name><index>[<expr><name><name>aggdesc</name><operator>-&gt;</operator><name>dtagd_nrecs</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>dtrd_size</name></name> <operator>!=</operator> <literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"bad avg size in aggregation record"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name>avg</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>data</name> <operator>+</operator> <name><name>rec</name><operator>-&gt;</operator><name>dtrd_offset</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lsrec</name><operator>-&gt;</operator><name>ls_count</name></name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>avg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lsrec</name><operator>-&gt;</operator><name>ls_time</name></name> <operator>=</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><name><name>avg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>g_recsize</name> <operator>&gt;=</operator> <name>LS_HIST</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>DTRACE_AGGWALK_NEXT</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<label><name>out</name>:</label>
<expr_stmt><expr><name><name>lsdata</name><operator>-&gt;</operator><name>lsd_next</name></name> <operator>=</operator> <operator>(</operator><name>lsrec_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>lsrec</name> <operator>+</operator> <name>g_recsize</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lsdata</name><operator>-&gt;</operator><name>lsd_count</name></name><operator>++</operator></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>DTRACE_AGGWALK_NEXT</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>process_trace</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dtrace_probedata_t</name> <modifier>*</modifier></type><name>pdata</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>lsdata_t</name> <modifier>*</modifier></type><name>lsdata</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lsrec_t</name> <modifier>*</modifier></type><name>lsrec</name> <init>= <expr><name><name>lsdata</name><operator>-&gt;</operator><name>lsd_next</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_eprobedesc_t</name> <modifier>*</modifier></type><name>edesc</name> <init>= <expr><name><name>pdata</name><operator>-&gt;</operator><name>dtpda_edesc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>caddr_t</name></type> <name>data</name> <init>= <expr><name><name>pdata</name><operator>-&gt;</operator><name>dtpda_data</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>lsdata</name><operator>-&gt;</operator><name>lsd_count</name></name> <operator>&gt;=</operator> <name>g_nrecs</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>DTRACE_CONSUME_NEXT</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>lsrec_fill</name><argument_list>(<argument><expr><name>lsrec</name></expr></argument>, <argument><expr><name><name>edesc</name><operator>-&gt;</operator><name>dtepd_rec</name></name></expr></argument>, <argument><expr><name><name>edesc</name><operator>-&gt;</operator><name>dtepd_nrecs</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lsdata</name><operator>-&gt;</operator><name>lsd_next</name></name> <operator>=</operator> <operator>(</operator><name>lsrec_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>lsrec</name> <operator>+</operator> <name>g_recsize</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lsdata</name><operator>-&gt;</operator><name>lsd_count</name></name><operator>++</operator></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>DTRACE_CONSUME_NEXT</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>process_data</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>lsdata_t</name></type> <name>lsdata</name></decl>;</decl_stmt>


<expr_stmt><expr><name><name>lsdata</name><operator>.</operator><name>lsd_next</name></name> <operator>=</operator> <operator>(</operator><name>lsrec_t</name> <operator>*</operator><operator>)</operator><name>data</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lsdata</name><operator>.</operator><name>lsd_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>g_tracing</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dtrace_consume</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>, <argument><expr><name>out</name></expr></argument>,
<argument><expr><name>process_trace</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lsdata</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dfail</name><argument_list>(<argument><expr><literal type="string">"failed to consume buffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><name><name>lsdata</name><operator>.</operator><name>lsd_count</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dtrace_aggregate_walk_keyvarsorted</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>,
<argument><expr><name>process_aggregate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lsdata</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dfail</name><argument_list>(<argument><expr><literal type="string">"failed to walk aggregate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><name><name>lsdata</name><operator>.</operator><name>lsd_count</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>drophandler</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dtrace_dropdata_t</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>g_dropped</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"lockstat: warning: %s"</literal></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>dtdda_msg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>DTRACE_HANDLE_OK</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>data_buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lsrec_t</name> <modifier>*</modifier></type><name>lsp</name></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>current</name></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>first</name></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>sort_buf</name></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>merge_buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><name>stdout</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>pid_t</name></type> <name>child</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>hrtime_t</name></type> <name>duration</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>addrp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>offp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sizep</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>evp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>lastp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uintptr_t</name></type> <name>addr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>, <decl><type ref="prev"/><name>off</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>events_specified</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>exec_errno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>event</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>filt</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ifilt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint64_t</name></type> <name><name>ev_count</name><index>[<expr><name>LS_MAX_EVENTS</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint64_t</name></type> <name><name>ev_time</name><index>[<expr><name>LS_MAX_EVENTS</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_optval_t</name></type> <name>aggsize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>aggstr</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>ncpus</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>dynvar</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>g_dtp</name> <operator>=</operator> <call><name>dtrace_open</name><argument_list>(<argument><expr><name>DTRACE_VERSION</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"cannot open dtrace library: %s"</literal></expr></argument>,
<argument><expr><call><name>dtrace_errmsg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dtrace_handle_drop</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>drophandler</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dfail</name><argument_list>(<argument><expr><literal type="string">"couldn't establish drop handler"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>symtab_init</name><argument_list>()</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"can't load kernel symbols"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>g_nrecs</name> <operator>=</operator> <name>DEFAULT_NRECS</name></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>getopt</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>LOCKSTAT_OPTSTR</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>GETOPT_EOF</name></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'b'</literal></expr>:</case>
<expr_stmt><expr><name>g_recsize</name> <operator>=</operator> <name>LS_BASIC</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'t'</literal></expr>:</case>
<expr_stmt><expr><name>g_recsize</name> <operator>=</operator> <name>LS_TIME</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'h'</literal></expr>:</case>
<expr_stmt><expr><name>g_recsize</name> <operator>=</operator> <name>LS_HIST</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'s'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isdigit</name><argument_list>(<argument><expr><name><name>optarg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>g_stkdepth</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>g_stkdepth</name> <operator>&gt;</operator> <name>LS_MAX_STACK_DEPTH</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"max stack depth is %d"</literal></expr></argument>,
<argument><expr><name>LS_MAX_STACK_DEPTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>g_recsize</name> <operator>=</operator> <call><name>LS_STACK</name><argument_list>(<argument><expr><name>g_stkdepth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'n'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isdigit</name><argument_list>(<argument><expr><name><name>optarg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>g_nrecs</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'d'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isdigit</name><argument_list>(<argument><expr><name><name>optarg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>duration</name> <operator>=</operator> <call><name>atoll</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>







<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>LS_MAX_EVENTS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>g_event_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ev_type</name> <operator>!=</operator> <literal type="char">'E'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>g_min_duration</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>duration</name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

<break>break;</break>

<case>case <expr><literal type="char">'i'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isdigit</name><argument_list>(<argument><expr><name><name>optarg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <name>MAX_HZ</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"max interrupt rate is %d Hz"</literal></expr></argument>, <argument><expr><name>MAX_HZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>LS_MAX_EVENTS</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>g_event_info</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>ev_desc</name></expr></argument>,
<argument><expr><literal type="string">"Profiling interrupt"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name><name>g_event_info</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>ev_name</name></expr></argument>,
<argument><expr><literal type="string">"profile:::profile-%d"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'l'</literal></expr>:</case>
<case>case <expr><literal type="char">'f'</literal></expr>:</case>
<expr_stmt><expr><name>addrp</name> <operator>=</operator> <call><name>strtok</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sizep</name> <operator>=</operator> <call><name>strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>addrp</name> <operator>=</operator> <call><name>strtok</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">",+"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>offp</name> <operator>=</operator> <call><name>strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <ternary><condition><expr><name>sizep</name></expr> ?</condition><then> <expr><call><name>strtoul</name><argument_list>(<argument><expr><name>sizep</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>off</name> <operator>=</operator> <ternary><condition><expr><name>offp</name></expr> ?</condition><then> <expr><call><name>strtoul</name><argument_list>(<argument><expr><name>offp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>addrp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name>addrp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call> <operator>+</operator> <name>off</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>sym_to_addr</name><argument_list>(<argument><expr><name>addrp</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>off</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>sizep</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>sym_size</name><argument_list>(<argument><expr><name>addrp</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>off</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>-</operator> <name>off</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"symbol '%s' not found"</literal></expr></argument>, <argument><expr><name>addrp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'l'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>filter_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>filt</name></expr></argument>, <argument><expr><literal type="string">"arg0"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>filter_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>filt</name></expr></argument>, <argument><expr><literal type="string">"caller"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>filter_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ifilt</name></expr></argument>, <argument><expr><literal type="string">"arg0"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'e'</literal></expr>:</case>
<expr_stmt><expr><name>evp</name> <operator>=</operator> <call><name>strtok_r</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>lastp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>evp</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ev1</name></decl>, <decl><type ref="prev"/><name>ev2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>evp2</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>strtok</name><argument_list>(<argument><expr><name>evp</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>evp2</name> <operator>=</operator> <call><name>strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ev1</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>evp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ev2</name> <operator>=</operator> <ternary><condition><expr><name>evp2</name></expr> ?</condition><then> <expr><call><name>atoi</name><argument_list>(<argument><expr><name>evp2</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>ev1</name></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>uint_t</name><operator>)</operator><name>ev1</name> <operator>&gt;=</operator> <name>LS_MAX_EVENTS</name> <operator>||</operator>
<operator>(</operator><name>uint_t</name><operator>)</operator><name>ev2</name> <operator>&gt;=</operator> <name>LS_MAX_EVENTS</name> <operator>||</operator> <name>ev1</name> <operator>&gt;</operator> <name>ev2</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"-e events out of range"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>ev1</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>ev2</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>g_enabled</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name>evp</name> <operator>=</operator> <call><name>strtok_r</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>lastp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>events_specified</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>illumos</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><literal type="char">'c'</literal></expr>:</case>
<expr_stmt><expr><name>g_cflag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><literal type="char">'k'</literal></expr>:</case>
<expr_stmt><expr><name>g_kflag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'w'</literal></expr>:</case>
<expr_stmt><expr><name>g_wflag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'W'</literal></expr>:</case>
<expr_stmt><expr><name>g_Wflag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'g'</literal></expr>:</case>
<expr_stmt><expr><name>g_gflag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'C'</literal></expr>:</case>
<case>case <expr><literal type="char">'E'</literal></expr>:</case>
<case>case <expr><literal type="char">'H'</literal></expr>:</case>
<case>case <expr><literal type="char">'I'</literal></expr>:</case>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>LS_MAX_EVENTS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>g_event_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ev_type</name> <operator>==</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>g_enabled</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
<expr_stmt><expr><name>events_specified</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'A'</literal></expr>:</case>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>LS_MAX_EVENTS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><literal type="string">"CH"</literal></expr></argument>, <argument><expr><name><name>g_event_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ev_type</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>g_enabled</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
<expr_stmt><expr><name>events_specified</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'T'</literal></expr>:</case>
<expr_stmt><expr><name>g_tracing</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'D'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isdigit</name><argument_list>(<argument><expr><name><name>optarg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>g_topn</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'R'</literal></expr>:</case>
<expr_stmt><expr><name>g_rates</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'p'</literal></expr>:</case>
<expr_stmt><expr><name>g_pflag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'P'</literal></expr>:</case>
<expr_stmt><expr><name>g_Pflag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'o'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>out</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"error opening file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'V'</literal></expr>:</case>
<expr_stmt><expr><name>g_Vflag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>

<default>default:</default>
<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>LOCKSTAT_OPTSTR</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></switch>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>filt</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>predicate_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>g_predicate</name></expr></argument>, <argument><expr><name>filt</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>filter_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>filt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ifilt</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>predicate_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>g_ipredicate</name></expr></argument>, <argument><expr><name>ifilt</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>filter_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ifilt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>g_recsize</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>g_gflag</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>g_stkdepth</name> <operator>=</operator> <name>LS_MAX_STACK_DEPTH</name></expr>;</expr_stmt>
<expr_stmt><expr><name>g_recsize</name> <operator>=</operator> <call><name>LS_STACK</name><argument_list>(<argument><expr><name>g_stkdepth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>g_recsize</name> <operator>=</operator> <name>LS_TIME</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>g_gflag</name> <operator>&amp;&amp;</operator> <name>g_recsize</name> <operator>&lt;=</operator> <call><name>LS_STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"'-g' requires at least '-s 1' data gathering"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>




<expr_stmt><expr><name>g_recsize</name> <operator>=</operator> <operator>-</operator><operator>(</operator><operator>-</operator><name>g_recsize</name> <operator>&amp;</operator> <operator>-</operator><sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>LS_MAX_EVENTS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>



<if_stmt><if>if <condition>(<expr><operator>!</operator><name>events_specified</name> <operator>&amp;&amp;</operator> <name><name>g_event_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ev_type</name> <operator>==</operator> <literal type="char">'C'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>g_enabled</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>LS_MAX_EVENTS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>g_enabled</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>g_event_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ev_acquire</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>




<expr_stmt><expr><name>dynvar</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>dprog_addevent</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>





<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&lt;=</operator> <name>optind</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ncpus</name> <operator>=</operator> <call><name>sysconf</name><argument_list>(<argument><expr><name>_SC_NPROCESSORS_ONLN</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dfail</name><argument_list>(<argument><expr><literal type="string">"couldn't determine number of online CPUs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>








<if_stmt><if>if <condition>(<expr><operator>(</operator><name>aggsize</name> <operator>=</operator> <operator>(</operator><name>g_nrecs</name> <operator>*</operator> <name>g_recsize</name> <operator>*</operator> <literal type="number">2</literal><operator>)</operator> <operator>/</operator> <name>ncpus</name><operator>)</operator> <operator>&lt;</operator> <name>MIN_AGGSIZE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>aggsize</name> <operator>=</operator> <name>MIN_AGGSIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>aggsize</name> <operator>&gt;</operator> <name>MAX_AGGSIZE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>aggsize</name> <operator>=</operator> <name>MAX_AGGSIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>aggstr</name></expr></argument>, <argument><expr><literal type="string">"%lld"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name> <name>long</name><operator>)</operator><name>aggsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>g_tracing</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dtrace_setopt</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>, <argument><expr><literal type="string">"bufsize"</literal></expr></argument>, <argument><expr><literal type="string">"4k"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dfail</name><argument_list>(<argument><expr><literal type="string">"failed to set 'bufsize'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dtrace_setopt</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>, <argument><expr><literal type="string">"aggsize"</literal></expr></argument>, <argument><expr><name>aggstr</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dfail</name><argument_list>(<argument><expr><literal type="string">"failed to set 'aggsize'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>dynvar</name></expr>)</condition> <block>{<block_content>







<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>aggstr</name></expr></argument>, <argument><expr><literal type="string">"%ldm"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>ncpus</name> <operator>&lt;</operator> <literal type="number">32</literal></expr> ?</condition><then> <expr><name>ncpus</name></expr> </then><else>: <expr><literal type="number">32</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dtrace_setopt</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>, <argument><expr><literal type="string">"dynvarsize"</literal></expr></argument>, <argument><expr><name>aggstr</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dfail</name><argument_list>(<argument><expr><literal type="string">"failed to set 'dynvarsize'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dtrace_setopt</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>, <argument><expr><literal type="string">"bufsize"</literal></expr></argument>, <argument><expr><name>aggstr</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dfail</name><argument_list>(<argument><expr><literal type="string">"failed to set 'bufsize'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dtrace_setopt</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>, <argument><expr><literal type="string">"statusrate"</literal></expr></argument>, <argument><expr><literal type="string">"10sec"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dfail</name><argument_list>(<argument><expr><literal type="string">"failed to set 'statusrate'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>optind</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>getopt</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>LOCKSTAT_OPTSTR</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>GETOPT_EOF</name></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'x'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dtrace_setopt</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dfail</name><argument_list>(<argument><expr><literal type="string">"failed to set -x %s"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></while>

<expr_stmt><expr><name>argc</name> <operator>-=</operator> <name>optind</name></expr>;</expr_stmt>
<expr_stmt><expr><name>argv</name> <operator>+=</operator> <name>optind</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>dprog_compile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>status_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>g_elapsed</name> <operator>=</operator> <operator>-</operator><call><name>gethrtime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name>child</name> <operator>=</operator> <call><name>fork</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>child</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"cannot fork"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>child</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dtrace_close</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>execvp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>exec_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">127</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>illumos</name></expr></argument>)</argument_list></call></expr></cpp:if>
<while>while <condition>(<expr><call><name>waitpid</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>WEXITED</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>child</name></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<while>while <condition>(<expr><call><name>waitpid</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>child</name></expr>)</condition><block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>status_check</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></while></block_content></block></while>

<expr_stmt><expr><name>g_elapsed</name> <operator>+=</operator> <call><name>gethrtime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>WIFEXITED</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>WEXITSTATUS</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>exec_errno</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>exec_errno</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"could not execute %s"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"lockstat: warning: %s exited with code %d\n"</literal></expr></argument>,
<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>WEXITSTATUS</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"lockstat: warning: %s died on signal %d\n"</literal></expr></argument>,
<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>WTERMSIG</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dtrace_stop</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dfail</name><argument_list>(<argument><expr><literal type="string">"failed to stop dtrace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>







<if_stmt><if>if <condition>(<expr><operator>!</operator><name>g_tracing</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dtrace_aggregate_snap</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dfail</name><argument_list>(<argument><expr><literal type="string">"failed to snap aggregate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>g_nrecs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dtrace_aggregate_walk</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>,
<argument><expr><name>count_aggregate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>g_nrecs</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dfail</name><argument_list>(<argument><expr><literal type="string">"failed to walk aggregate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>illumos</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>data_buf</name> <operator>=</operator> <call><name>memalign</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><operator>(</operator><name>g_nrecs</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>g_recsize</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if_stmt><if>if <condition>(<expr><call><name>posix_memalign</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>data_buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><operator>(</operator><name>g_nrecs</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>g_recsize</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"Memory allocation failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>




<expr_stmt><expr><name>g_nrecs_used</name> <operator>=</operator> <call><name>process_data</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>data_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>g_nrecs_used</name> <operator>&gt;</operator> <name>g_nrecs</name> <operator>||</operator> <name>g_dropped</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"lockstat: warning: "</literal>
<literal type="string">"ran out of data records (use -n for more)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>lsp</name> <operator>=</operator> <operator>(</operator><name>lsrec_t</name> <operator>*</operator><operator>)</operator><name>data_buf</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>g_nrecs_used</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator>

<expr><name>lsp</name> <operator>=</operator> <operator>(</operator><name>lsrec_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>lsp</name> <operator>+</operator> <name>g_recsize</name><operator>)</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>ev_count</name><index>[<expr><name><name>lsp</name><operator>-&gt;</operator><name>ls_event</name></name></expr>]</index></name> <operator>+=</operator> <name><name>lsp</name><operator>-&gt;</operator><name>ls_count</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ev_time</name><index>[<expr><name><name>lsp</name><operator>-&gt;</operator><name>ls_event</name></name></expr>]</index></name> <operator>+=</operator> <name><name>lsp</name><operator>-&gt;</operator><name>ls_time</name></name></expr>;</expr_stmt>
</block_content>}</block></for>




<if_stmt><if>if <condition>(<expr><name>g_gflag</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>lsrec_t</name> <modifier>*</modifier></type><name>newlsp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>oldlsp</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>illumos</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>newlsp</name> <operator>=</operator> <call><name>memalign</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><name>g_nrecs_used</name> <operator>*</operator> <name>LS_TIME</name> <operator>*</operator> <operator>(</operator><name>g_stkdepth</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>posix_memalign</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>newlsp</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><name>g_nrecs_used</name> <operator>*</operator> <name>LS_TIME</name> <operator>*</operator> <operator>(</operator><name>g_stkdepth</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name>newlsp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"Cannot allocate space for -g processing"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>lsp</name> <operator>=</operator> <name>newlsp</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>oldlsp</name> <operator>=</operator> <operator>(</operator><name>lsrec_t</name> <operator>*</operator><operator>)</operator><name>data_buf</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>g_nrecs_used</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator>

<expr><name>oldlsp</name> <operator>=</operator> <operator>(</operator><name>lsrec_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>oldlsp</name> <operator>+</operator> <name>g_recsize</name><operator>)</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>fr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>caller_in_stack</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>oldlsp</name><operator>-&gt;</operator><name>ls_count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>fr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>fr</name> <operator>&lt;</operator> <name>g_stkdepth</name></expr>;</condition> <incr><expr><name>fr</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>oldlsp</name><operator>-&gt;</operator><name>ls_stack</name><index>[<expr><name>fr</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>oldlsp</name><operator>-&gt;</operator><name>ls_stack</name><index>[<expr><name>fr</name></expr>]</index></name> <operator>==</operator> <name><name>oldlsp</name><operator>-&gt;</operator><name>ls_caller</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>caller_in_stack</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>bcopy</name><argument_list>(<argument><expr><name>oldlsp</name></expr></argument>, <argument><expr><name>lsp</name></expr></argument>, <argument><expr><name>LS_TIME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lsp</name><operator>-&gt;</operator><name>ls_caller</name></name> <operator>=</operator> <name><name>oldlsp</name><operator>-&gt;</operator><name>ls_stack</name><index>[<expr><name>fr</name></expr>]</index></name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>illumos</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>lsp</name><operator>-&gt;</operator><name>ls_lock</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name><name>oldlsp</name><operator>-&gt;</operator><name>ls_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>lsp</name> <operator>=</operator> <operator>(</operator><name>lsrec_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>lsp</name> <operator>+</operator> <name>LS_TIME</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>caller_in_stack</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bcopy</name><argument_list>(<argument><expr><name>oldlsp</name></expr></argument>, <argument><expr><name>lsp</name></expr></argument>, <argument><expr><name>LS_TIME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>lsp</name> <operator>=</operator> <operator>(</operator><name>lsrec_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>lsp</name> <operator>+</operator> <name>LS_TIME</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>illumos</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>oldlsp</name><operator>-&gt;</operator><name>ls_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></for>
<expr_stmt><expr><name>g_nrecs</name> <operator>=</operator> <name>g_nrecs_used</name> <operator>=</operator>
<operator>(</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>lsp</name> <operator>-</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><name>newlsp</name><operator>)</operator> <operator>/</operator> <name>LS_TIME</name></expr>;</expr_stmt>
<expr_stmt><expr><name>g_recsize</name> <operator>=</operator> <name>LS_TIME</name></expr>;</expr_stmt>
<expr_stmt><expr><name>g_stkdepth</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>data_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>data_buf</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>newlsp</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>sort_buf</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><literal type="number">2</literal> <operator>*</operator> <operator>(</operator><name>g_nrecs</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>,
<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"Sort buffer allocation failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>merge_buf</name> <operator>=</operator> <name>sort_buf</name> <operator>+</operator> <operator>(</operator><name>g_nrecs</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>





<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>lsp</name> <operator>=</operator> <operator>(</operator><name>lsrec_t</name> <operator>*</operator><operator>)</operator><name>data_buf</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>g_nrecs_used</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator>

<expr><name>lsp</name> <operator>=</operator> <operator>(</operator><name>lsrec_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>lsp</name> <operator>+</operator> <name>g_recsize</name><operator>)</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>lsp</name><operator>-&gt;</operator><name>ls_count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>lsp</name><operator>-&gt;</operator><name>ls_event</name></name> <operator>=</operator> <name>LS_MAX_EVENTS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>sort_buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>lsp</name></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>g_nrecs_used</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>




<expr_stmt><expr><name><name>sort_buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>lsp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lsp</name><operator>-&gt;</operator><name>ls_event</name></name> <operator>=</operator> <name>LS_MAX_EVENTS</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>g_tracing</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>report_trace</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>sort_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><name>g_gflag</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>mergesort</name><argument_list>(<argument><expr><name>lockcmp</name></expr></argument>, <argument><expr><name>sort_buf</name></expr></argument>, <argument><expr><name>merge_buf</name></expr></argument>, <argument><expr><name>g_nrecs_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>coalesce</name><argument_list>(<argument><expr><name>lockcmp</name></expr></argument>, <argument><expr><name>sort_buf</name></expr></argument>, <argument><expr><name>g_nrecs_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><name>g_cflag</name> <operator>||</operator> <name>g_kflag</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>g_nrecs_used</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>fr</name></decl>;</decl_stmt>
<expr_stmt><expr><name>lsp</name> <operator>=</operator> <name><name>sort_buf</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>illumos</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>g_cflag</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>coalesce_symbol</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lsp</name><operator>-&gt;</operator><name>ls_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name>g_kflag</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>fr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>fr</name> <operator>&lt;</operator> <name>g_stkdepth</name></expr>;</condition> <incr><expr><name>fr</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>coalesce_symbol</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lsp</name><operator>-&gt;</operator><name>ls_stack</name><index>[<expr><name>fr</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>coalesce_symbol</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lsp</name><operator>-&gt;</operator><name>ls_caller</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>mergesort</name><argument_list>(<argument><expr><name>lockcmp</name></expr></argument>, <argument><expr><name>sort_buf</name></expr></argument>, <argument><expr><name>merge_buf</name></expr></argument>, <argument><expr><name>g_nrecs_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>coalesce</name><argument_list>(<argument><expr><name>lockcmp</name></expr></argument>, <argument><expr><name>sort_buf</name></expr></argument>, <argument><expr><name>g_nrecs_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name>g_wflag</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>mergesort</name><argument_list>(<argument><expr><name>lock_and_count_cmp_anywhere</name></expr></argument>,
<argument><expr><name>sort_buf</name></expr></argument>, <argument><expr><name>merge_buf</name></expr></argument>, <argument><expr><name>g_nrecs_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>coalesce</name><argument_list>(<argument><expr><name>lockcmp_anywhere</name></expr></argument>, <argument><expr><name>sort_buf</name></expr></argument>, <argument><expr><name>g_nrecs_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name>g_Wflag</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>mergesort</name><argument_list>(<argument><expr><name>site_and_count_cmp_anylock</name></expr></argument>,
<argument><expr><name>sort_buf</name></expr></argument>, <argument><expr><name>merge_buf</name></expr></argument>, <argument><expr><name>g_nrecs_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>coalesce</name><argument_list>(<argument><expr><name>sitecmp_anylock</name></expr></argument>, <argument><expr><name>sort_buf</name></expr></argument>, <argument><expr><name>g_nrecs_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><name>g_recsize</name> <operator>&lt;</operator> <name>LS_TIME</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>g_Pflag</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>g_Pflag</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>mergesort</name><argument_list>(<argument><expr><name>timecmp</name></expr></argument>, <argument><expr><name>sort_buf</name></expr></argument>, <argument><expr><name>merge_buf</name></expr></argument>, <argument><expr><name>g_nrecs_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>mergesort</name><argument_list>(<argument><expr><name>countcmp</name></expr></argument>, <argument><expr><name>sort_buf</name></expr></argument>, <argument><expr><name>merge_buf</name></expr></argument>, <argument><expr><name>g_nrecs_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>




<expr_stmt><expr><name>first</name> <operator>=</operator> <operator>&amp;</operator><name><name>sort_buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><name>event</name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>first</name><operator>)</operator><operator>-&gt;</operator><name>ls_event</name></name><operator>)</operator> <operator>&lt;</operator> <name>LS_MAX_EVENTS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>current</name> <operator>=</operator> <name>first</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><name>lsp</name> <operator>=</operator> <operator>*</operator><name>current</name><operator>)</operator><operator>-&gt;</operator><name>ls_event</name> <operator>==</operator> <name>event</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>current</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><call><name>report_stats</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>first</name></expr></argument>, <argument><expr><name>current</name> <operator>-</operator> <name>first</name></expr></argument>, <argument><expr><name><name>ev_count</name><index>[<expr><name>event</name></expr>]</index></name></expr></argument>,
<argument><expr><name><name>ev_time</name><index>[<expr><name>event</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>first</name> <operator>=</operator> <name>current</name></expr>;</expr_stmt>
</block_content>}</block></while>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>illumos</name></expr></argument>)</argument_list></call></expr></cpp:if>



<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>lsp</name> <operator>=</operator> <operator>(</operator><name>lsrec_t</name> <operator>*</operator><operator>)</operator><name>data_buf</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>g_nrecs_used</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator>
<expr><name>lsp</name> <operator>=</operator> <operator>(</operator><name>lsrec_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>lsp</name> <operator>+</operator> <name>g_recsize</name><operator>)</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>lsp</name><operator>-&gt;</operator><name>ls_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>format_symbol</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uintptr_t</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>show_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uintptr_t</name></type> <name>symoff</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>symname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>symsize</name></decl>;</decl_stmt>

<expr_stmt><expr><name>symname</name> <operator>=</operator> <call><name>addr_to_sym</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>symoff</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>symsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>show_size</name> <operator>&amp;&amp;</operator> <name>symoff</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s[%ld]"</literal></expr></argument>, <argument><expr><name>symname</name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><name>symsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>symoff</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>symname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>symoff</name> <operator>&lt;</operator> <literal type="number">16</literal> <operator>&amp;&amp;</operator> <call><name>bcmp</name><argument_list>(<argument><expr><name>symname</name></expr></argument>, <argument><expr><literal type="string">"cpu["</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>illumos</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s+%ld"</literal></expr></argument>, <argument><expr><name>symname</name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><name>symoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s+%s"</literal></expr></argument>, <argument><expr><name>symname</name></expr></argument>, <argument><expr><name><name>g_pri_class</name><index>[<expr><operator>(</operator><name>int</name><operator>)</operator><name>symoff</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if type="elseif">else if <condition>(<expr><name>symoff</name> <operator>&lt;=</operator> <name>symsize</name> <operator>||</operator> <operator>(</operator><name>symoff</name> <operator>&lt;</operator> <literal type="number">256</literal> <operator>&amp;&amp;</operator> <name>addr</name> <operator>!=</operator> <name>symoff</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s+0x%llx"</literal></expr></argument>, <argument><expr><name>symname</name></expr></argument>,
<argument><expr><operator>(</operator><name>unsigned</name> <name>long</name> <name>long</name><operator>)</operator><name>symoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"0x%llx"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name> <name>long</name><operator>)</operator><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><operator>(</operator><name>buf</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>report_stats</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><name>lsrec_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>sort_buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nrecs</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>total_count</name></decl></parameter>,
<parameter><decl><type><name>uint64_t</name></type> <name>total_time</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>event</name> <init>= <expr><name><name>sort_buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>ls_event</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lsrec_t</name> <modifier>*</modifier></type><name>lsp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>ptotal</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>percent</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>fr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>displayed</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>first_bin</name></decl>, <decl><type ref="prev"/><name>last_bin</name></decl>, <decl><type ref="prev"/><name>max_bin_count</name></decl>, <decl><type ref="prev"/><name>total_bin_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rectype</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>lhdr</name><index>[<expr><literal type="number">80</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>chdr</name><index>[<expr><literal type="number">80</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name>rectype</name> <operator>=</operator> <name>g_recsize</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>g_topn</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%20llu %s\n"</literal></expr></argument>,
<argument><expr><ternary><condition><expr><name>g_rates</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>total_count</name></expr> </then><else>:
<expr><operator>(</operator><operator>(</operator><name>unsigned</name> <name>long</name> <name>long</name><operator>)</operator><name>total_count</name> <operator>*</operator> <name>NANOSEC</name><operator>)</operator> <operator>/</operator> <name>g_elapsed</name></expr></else></ternary></expr></argument>,
<argument><expr><name><name>g_event_info</name><index>[<expr><name>event</name></expr>]</index></name><operator>.</operator><name>ev_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>lhdr</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>,
<argument><expr><ternary><condition><expr><name>g_Wflag</name></expr> ?</condition><then> <expr><literal type="string">"Hottest "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name><name>g_event_info</name><index>[<expr><name>event</name></expr>]</index></name><operator>.</operator><name>ev_lhdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>chdr</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>,
<argument><expr><ternary><condition><expr><name>g_wflag</name></expr> ?</condition><then> <expr><literal type="string">"Hottest "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><literal type="string">"Caller"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>g_pflag</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,
<argument><expr><literal type="string">"\n%s: %.0f events in %.3f seconds (%.0f events/sec)\n\n"</literal></expr></argument>,
<argument><expr><name><name>g_event_info</name><index>[<expr><name>event</name></expr>]</index></name><operator>.</operator><name>ev_desc</name></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>)</operator><name>total_count</name></expr></argument>,
<argument><expr><operator>(</operator><name>double</name><operator>)</operator><name>g_elapsed</name> <operator>/</operator> <name>NANOSEC</name></expr></argument>,
<argument><expr><operator>(</operator><name>double</name><operator>)</operator><name>total_count</name> <operator>*</operator> <name>NANOSEC</name> <operator>/</operator> <name>g_elapsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>g_pflag</name> <operator>&amp;&amp;</operator> <name>rectype</name> <operator>&lt;</operator> <name>LS_HIST</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>g_event_info</name><index>[<expr><name>event</name></expr>]</index></name><operator>.</operator><name>ev_units</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%5s %4s %4s %4s %8s %-22s %-24s\n"</literal></expr></argument>,
<argument><expr><ternary><condition><expr><name>g_rates</name></expr> ?</condition><then> <expr><literal type="string">"ops/s"</literal></expr> </then><else>: <expr><literal type="string">"Count"</literal></expr></else></ternary></expr></argument>,
<argument><expr><ternary><condition><expr><name>g_gflag</name></expr> ?</condition><then> <expr><literal type="string">"genr"</literal></expr> </then><else>: <expr><literal type="string">"indv"</literal></expr></else></ternary></expr></argument>,
<argument><expr><literal type="string">"cuml"</literal></expr></argument>, <argument><expr><literal type="string">"rcnt"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>rectype</name> <operator>&gt;=</operator> <name>LS_TIME</name></expr> ?</condition><then> <expr><name>buf</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name>lhdr</name></expr></argument>, <argument><expr><name>chdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"---------------------------------"</literal>
<literal type="string">"----------------------------------------------\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>displayed</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nrecs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>lsp</name> <operator>=</operator> <name><name>sort_buf</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>displayed</name><operator>++</operator> <operator>&gt;=</operator> <name>g_topn</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>g_pflag</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%u %u"</literal></expr></argument>,
<argument><expr><name><name>lsp</name><operator>-&gt;</operator><name>ls_event</name></name></expr></argument>, <argument><expr><name><name>lsp</name><operator>-&gt;</operator><name>ls_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>illumos</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>,
<argument><expr><call><name>format_symbol</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>lsp</name><operator>-&gt;</operator><name>ls_lock</name></name></expr></argument>, <argument><expr><name>g_cflag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name><name>lsp</name><operator>-&gt;</operator><name>ls_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>,
<argument><expr><call><name>format_symbol</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>lsp</name><operator>-&gt;</operator><name>ls_caller</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">" %f"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>double</name><operator>)</operator><name><name>lsp</name><operator>-&gt;</operator><name>ls_refcnt</name></name> <operator>/</operator> <name><name>lsp</name><operator>-&gt;</operator><name>ls_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>rectype</name> <operator>&gt;=</operator> <name>LS_TIME</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">" %llu"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>unsigned</name> <name>long</name> <name>long</name><operator>)</operator><name><name>lsp</name><operator>-&gt;</operator><name>ls_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>rectype</name> <operator>&gt;=</operator> <name>LS_HIST</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">64</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">" %u"</literal></expr></argument>,
<argument><expr><name><name>lsp</name><operator>-&gt;</operator><name>ls_hist</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>LS_MAX_STACK_DEPTH</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>rectype</name> <operator>&lt;=</operator> <call><name>LS_STACK</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call> <operator>||</operator>
<name><name>lsp</name><operator>-&gt;</operator><name>ls_stack</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>,
<argument><expr><call><name>format_symbol</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>lsp</name><operator>-&gt;</operator><name>ls_stack</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>rectype</name> <operator>&gt;=</operator> <name>LS_HIST</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"---------------------------------"</literal>
<literal type="string">"----------------------------------------------\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>,
<argument><expr><name><name>g_event_info</name><index>[<expr><name>event</name></expr>]</index></name><operator>.</operator><name>ev_units</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%5s %4s %4s %4s %8s %-22s %-24s\n"</literal></expr></argument>,
<argument><expr><ternary><condition><expr><name>g_rates</name></expr> ?</condition><then> <expr><literal type="string">"ops/s"</literal></expr> </then><else>: <expr><literal type="string">"Count"</literal></expr></else></ternary></expr></argument>,
<argument><expr><ternary><condition><expr><name>g_gflag</name></expr> ?</condition><then> <expr><literal type="string">"genr"</literal></expr> </then><else>: <expr><literal type="string">"indv"</literal></expr></else></ternary></expr></argument>,
<argument><expr><literal type="string">"cuml"</literal></expr></argument>, <argument><expr><literal type="string">"rcnt"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>lhdr</name></expr></argument>, <argument><expr><name>chdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>g_Pflag</name> <operator>&amp;&amp;</operator> <name>total_time</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>percent</name> <operator>=</operator> <operator>(</operator><name><name>lsp</name><operator>-&gt;</operator><name>ls_time</name></name> <operator>*</operator> <literal type="number">100.00</literal><operator>)</operator> <operator>/</operator> <name>total_time</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>percent</name> <operator>=</operator> <operator>(</operator><name><name>lsp</name><operator>-&gt;</operator><name>ls_count</name></name> <operator>*</operator> <literal type="number">100.00</literal><operator>)</operator> <operator>/</operator> <name>total_count</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>ptotal</name> <operator>+=</operator> <name>percent</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>rectype</name> <operator>&gt;=</operator> <name>LS_TIME</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%llu"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>unsigned</name> <name>long</name> <name>long</name><operator>)</operator><operator>(</operator><name><name>lsp</name><operator>-&gt;</operator><name>ls_time</name></name> <operator>/</operator> <name><name>lsp</name><operator>-&gt;</operator><name>ls_count</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%5llu "</literal></expr></argument>,
<argument><expr><ternary><condition><expr><name>g_rates</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>lsp</name><operator>-&gt;</operator><name>ls_count</name></name></expr> </then><else>:
<expr><operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>lsp</name><operator>-&gt;</operator><name>ls_count</name></name> <operator>*</operator> <name>NANOSEC</name><operator>)</operator> <operator>/</operator> <name>g_elapsed</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%3.0f%% "</literal></expr></argument>, <argument><expr><name>percent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>g_gflag</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"---- "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%3.0f%% "</literal></expr></argument>, <argument><expr><name>ptotal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%4.2f %8s "</literal></expr></argument>,
<argument><expr><operator>(</operator><name>double</name><operator>)</operator><name><name>lsp</name><operator>-&gt;</operator><name>ls_refcnt</name></name> <operator>/</operator> <name><name>lsp</name><operator>-&gt;</operator><name>ls_count</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>illumos</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%-22s "</literal></expr></argument>,
<argument><expr><call><name>format_symbol</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>lsp</name><operator>-&gt;</operator><name>ls_lock</name></name></expr></argument>, <argument><expr><name>g_cflag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%-22s "</literal></expr></argument>, <argument><expr><name><name>lsp</name><operator>-&gt;</operator><name>ls_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%-24s\n"</literal></expr></argument>,
<argument><expr><call><name>format_symbol</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>lsp</name><operator>-&gt;</operator><name>ls_caller</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>rectype</name> <operator>&lt;</operator> <name>LS_HIST</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%10s %31s %-9s %-24s\n"</literal></expr></argument>,
<argument><expr><name><name>g_event_info</name><index>[<expr><name>event</name></expr>]</index></name><operator>.</operator><name>ev_units</name></expr></argument>,
<argument><expr><literal type="string">"------ Time Distribution ------"</literal></expr></argument>,
<argument><expr><ternary><condition><expr><name>g_rates</name></expr> ?</condition><then> <expr><literal type="string">"ops/s"</literal></expr> </then><else>: <expr><literal type="string">"count"</literal></expr></else></ternary></expr></argument>,
<argument><expr><ternary><condition><expr><name>rectype</name> <operator>&gt;</operator> <call><name>LS_STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"Stack"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>first_bin</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>lsp</name><operator>-&gt;</operator><name>ls_hist</name><index>[<expr><name>first_bin</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>first_bin</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<expr_stmt><expr><name>last_bin</name> <operator>=</operator> <literal type="number">63</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>lsp</name><operator>-&gt;</operator><name>ls_hist</name><index>[<expr><name>last_bin</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>last_bin</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>

<expr_stmt><expr><name>max_bin_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>total_bin_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>first_bin</name></expr>;</init> <condition><expr><name>j</name> <operator>&lt;=</operator> <name>last_bin</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>total_bin_count</name> <operator>+=</operator> <name><name>lsp</name><operator>-&gt;</operator><name>ls_hist</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>lsp</name><operator>-&gt;</operator><name>ls_hist</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&gt;</operator> <name>max_bin_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>max_bin_count</name> <operator>=</operator> <name><name>lsp</name><operator>-&gt;</operator><name>ls_hist</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>




<for>for <control>(<init><expr><name>fr</name> <operator>=</operator> <literal type="number">3</literal></expr>;</init> <condition><expr><name>fr</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>fr</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>lsp</name><operator>-&gt;</operator><name>ls_stack</name><index>[<expr><name>fr</name></expr>]</index></name> <operator>==</operator> <name><name>lsp</name><operator>-&gt;</operator><name>ls_caller</name></name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>first_bin</name></expr>;</init> <condition><expr><name>j</name> <operator>&lt;=</operator> <name>last_bin</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>uint_t</name></type> <name>depth</name> <init>= <expr><operator>(</operator><name><name>lsp</name><operator>-&gt;</operator><name>ls_hist</name><index>[<expr><name>j</name></expr>]</index></name> <operator>*</operator> <literal type="number">30</literal><operator>)</operator> <operator>/</operator> <name>total_bin_count</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%10llu |%s%s %-9u "</literal></expr></argument>,
<argument><expr><literal type="number">1ULL</literal> <operator>&lt;&lt;</operator> <name>j</name></expr></argument>,
<argument><expr><literal type="string">"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"</literal> <operator>+</operator> <literal type="number">30</literal> <operator>-</operator> <name>depth</name></expr></argument>,
<argument><expr><literal type="string">" "</literal> <operator>+</operator> <name>depth</name></expr></argument>,
<argument><expr><ternary><condition><expr><name>g_rates</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>lsp</name><operator>-&gt;</operator><name>ls_hist</name><index>[<expr><name>j</name></expr>]</index></name></expr> </then><else>:
<expr><operator>(</operator><name>uint_t</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>lsp</name><operator>-&gt;</operator><name>ls_hist</name><index>[<expr><name>j</name></expr>]</index></name> <operator>*</operator> <name>NANOSEC</name><operator>)</operator> <operator>/</operator>
<name>g_elapsed</name><operator>)</operator></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>rectype</name> <operator>&lt;=</operator> <call><name>LS_STACK</name><argument_list>(<argument><expr><name>fr</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>lsp</name><operator>-&gt;</operator><name>ls_stack</name><index>[<expr><name>fr</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%-24s\n"</literal></expr></argument>,
<argument><expr><call><name>format_symbol</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>lsp</name><operator>-&gt;</operator><name>ls_stack</name><index>[<expr><name>fr</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fr</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></for>
<while>while <condition>(<expr><name>rectype</name> <operator>&gt;</operator> <call><name>LS_STACK</name><argument_list>(<argument><expr><name>fr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>lsp</name><operator>-&gt;</operator><name>ls_stack</name><index>[<expr><name>fr</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%15s %-36s %-24s\n"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>,
<argument><expr><call><name>format_symbol</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>lsp</name><operator>-&gt;</operator><name>ls_stack</name><index>[<expr><name>fr</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fr</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>g_pflag</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"---------------------------------"</literal>
<literal type="string">"----------------------------------------------\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fflush</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>report_trace</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><name>lsrec_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>sort_buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>lsrec_t</name> <modifier>*</modifier></type><name>lsp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>fr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rectype</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>buf2</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name>rectype</name> <operator>=</operator> <name>g_recsize</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>g_pflag</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%5s %7s %11s %-24s %-24s\n"</literal></expr></argument>,
<argument><expr><literal type="string">"Event"</literal></expr></argument>, <argument><expr><literal type="string">"Time"</literal></expr></argument>, <argument><expr><literal type="string">"Owner"</literal></expr></argument>, <argument><expr><literal type="string">"Lock"</literal></expr></argument>, <argument><expr><literal type="string">"Caller"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"---------------------------------"</literal>
<literal type="string">"----------------------------------------------\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>g_nrecs_used</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>lsp</name> <operator>=</operator> <name><name>sort_buf</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>lsp</name><operator>-&gt;</operator><name>ls_event</name></name> <operator>&gt;=</operator> <name>LS_MAX_EVENTS</name> <operator>||</operator> <name><name>lsp</name><operator>-&gt;</operator><name>ls_count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%2d %10llu %11p %-24s %-24s\n"</literal></expr></argument>,
<argument><expr><name><name>lsp</name><operator>-&gt;</operator><name>ls_event</name></name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name> <name>long</name><operator>)</operator><name><name>lsp</name><operator>-&gt;</operator><name>ls_time</name></name></expr></argument>,
<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>lsp</name><operator>-&gt;</operator><name>ls_next</name></name></expr></argument>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>illumos</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><call><name>format_symbol</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>lsp</name><operator>-&gt;</operator><name>ls_lock</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<argument><expr><name><name>lsp</name><operator>-&gt;</operator><name>ls_lock</name></name></expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<argument><expr><call><name>format_symbol</name><argument_list>(<argument><expr><name>buf2</name></expr></argument>, <argument><expr><name><name>lsp</name><operator>-&gt;</operator><name>ls_caller</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>rectype</name> <operator>&lt;=</operator> <call><name>LS_STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>




<for>for <control>(<init><expr><name>fr</name> <operator>=</operator> <literal type="number">3</literal></expr>;</init> <condition><expr><name>fr</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>fr</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>lsp</name><operator>-&gt;</operator><name>ls_stack</name><index>[<expr><name>fr</name></expr>]</index></name> <operator>==</operator> <name><name>lsp</name><operator>-&gt;</operator><name>ls_caller</name></name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

<while>while <condition>(<expr><name>rectype</name> <operator>&gt;</operator> <call><name>LS_STACK</name><argument_list>(<argument><expr><name>fr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>lsp</name><operator>-&gt;</operator><name>ls_stack</name><index>[<expr><name>fr</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%53s %-24s\n"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>,
<argument><expr><call><name>format_symbol</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>lsp</name><operator>-&gt;</operator><name>ls_stack</name><index>[<expr><name>fr</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fr</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fflush</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
