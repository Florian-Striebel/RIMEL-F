<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/cddl/contrib/opensolaris/cmd/plockstat/plockstat.c">

























<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>illumos</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>ident</name> <cpp:literal>"%Z%%M% %I% %E% SMI"</cpp:literal></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dtrace.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;link.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;priv.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;strings.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/wait.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libgen.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libproc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libproc_compat.h&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>g_pname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>g_dtp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>ps_prochandle</name></name> <modifier>*</modifier></type><name>g_pr</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>E_SUCCESS</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>E_ERROR</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>E_USAGE</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>









<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>g_hold_init</name> <init>=
<expr><literal type="string">"plockstat$target:::rw-acquire\n"</literal>
<literal type="string">"{\n"</literal>
<literal type="string">" self-&gt;rwhold[arg0] = timestamp;\n"</literal>
<literal type="string">"}\n"</literal>
<literal type="string">"plockstat$target:::mutex-acquire\n"</literal>
<literal type="string">"/arg1 == 0/\n"</literal>
<literal type="string">"{\n"</literal>
<literal type="string">" mtxhold[arg0] = timestamp;\n"</literal>
<literal type="string">"}\n"</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>g_hold_histogram</name> <init>=
<expr><literal type="string">"plockstat$target:::rw-release\n"</literal>
<literal type="string">"/self-&gt;rwhold[arg0] &amp;&amp; arg1 == 1/\n"</literal>
<literal type="string">"{\n"</literal>
<literal type="string">" @rw_w_hold[arg0, ustack()] =\n"</literal>
<literal type="string">" quantize(timestamp - self-&gt;rwhold[arg0]);\n"</literal>
<literal type="string">" self-&gt;rwhold[arg0] = 0;\n"</literal>
<literal type="string">" rw_w_hold_found = 1;\n"</literal>
<literal type="string">"}\n"</literal>
<literal type="string">"plockstat$target:::rw-release\n"</literal>
<literal type="string">"/self-&gt;rwhold[arg0]/\n"</literal>
<literal type="string">"{\n"</literal>
<literal type="string">" @rw_r_hold[arg0, ustack()] =\n"</literal>
<literal type="string">" quantize(timestamp - self-&gt;rwhold[arg0]);\n"</literal>
<literal type="string">" self-&gt;rwhold[arg0] = 0;\n"</literal>
<literal type="string">" rw_r_hold_found = 1;\n"</literal>
<literal type="string">"}\n"</literal>
<literal type="string">"plockstat$target:::mutex-release\n"</literal>
<literal type="string">"/mtxhold[arg0] &amp;&amp; arg1 == 0/\n"</literal>
<literal type="string">"{\n"</literal>
<literal type="string">" @mtx_hold[arg0, ustack()] = quantize(timestamp - mtxhold[arg0]);\n"</literal>
<literal type="string">" mtxhold[arg0] = 0;\n"</literal>
<literal type="string">" mtx_hold_found = 1;\n"</literal>
<literal type="string">"}\n"</literal>
<literal type="string">"\n"</literal>
<literal type="string">"END\n"</literal>
<literal type="string">"/mtx_hold_found/\n"</literal>
<literal type="string">"{\n"</literal>
<literal type="string">" trace(\"Mutex hold\");\n"</literal>
<literal type="string">" printa(@mtx_hold);\n"</literal>
<literal type="string">"}\n"</literal>
<literal type="string">"END\n"</literal>
<literal type="string">"/rw_r_hold_found/\n"</literal>
<literal type="string">"{\n"</literal>
<literal type="string">" trace(\"R/W reader hold\");\n"</literal>
<literal type="string">" printa(@rw_r_hold);\n"</literal>
<literal type="string">"}\n"</literal>
<literal type="string">"END\n"</literal>
<literal type="string">"/rw_w_hold_found/\n"</literal>
<literal type="string">"{\n"</literal>
<literal type="string">" trace(\"R/W writer hold\");\n"</literal>
<literal type="string">" printa(@rw_w_hold);\n"</literal>
<literal type="string">"}\n"</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>g_hold_times</name> <init>=
<expr><literal type="string">"plockstat$target:::rw-release\n"</literal>
<literal type="string">"/self-&gt;rwhold[arg0] &amp;&amp; arg1 == 1/\n"</literal>
<literal type="string">"{\n"</literal>
<literal type="string">" @rw_w_hold[arg0, ustack(5)] = sum(timestamp - self-&gt;rwhold[arg0]);\n"</literal>
<literal type="string">" @rw_w_hold_count[arg0, ustack(5)] = count();\n"</literal>
<literal type="string">" self-&gt;rwhold[arg0] = 0;\n"</literal>
<literal type="string">" rw_w_hold_found = 1;\n"</literal>
<literal type="string">"}\n"</literal>
<literal type="string">"plockstat$target:::rw-release\n"</literal>
<literal type="string">"/self-&gt;rwhold[arg0]/\n"</literal>
<literal type="string">"{\n"</literal>
<literal type="string">" @rw_r_hold[arg0, ustack(5)] = sum(timestamp - self-&gt;rwhold[arg0]);\n"</literal>
<literal type="string">" @rw_r_hold_count[arg0, ustack(5)] = count();\n"</literal>
<literal type="string">" self-&gt;rwhold[arg0] = 0;\n"</literal>
<literal type="string">" rw_r_hold_found = 1;\n"</literal>
<literal type="string">"}\n"</literal>
<literal type="string">"plockstat$target:::mutex-release\n"</literal>
<literal type="string">"/mtxhold[arg0] &amp;&amp; arg1 == 0/\n"</literal>
<literal type="string">"{\n"</literal>
<literal type="string">" @mtx_hold[arg0, ustack(5)] = sum(timestamp - mtxhold[arg0]);\n"</literal>
<literal type="string">" @mtx_hold_count[arg0, ustack(5)] = count();\n"</literal>
<literal type="string">" mtxhold[arg0] = 0;\n"</literal>
<literal type="string">" mtx_hold_found = 1;\n"</literal>
<literal type="string">"}\n"</literal>
<literal type="string">"\n"</literal>
<literal type="string">"END\n"</literal>
<literal type="string">"/mtx_hold_found/\n"</literal>
<literal type="string">"{\n"</literal>
<literal type="string">" trace(\"Mutex hold\");\n"</literal>
<literal type="string">" printa(@mtx_hold, @mtx_hold_count);\n"</literal>
<literal type="string">"}\n"</literal>
<literal type="string">"END\n"</literal>
<literal type="string">"/rw_r_hold_found/\n"</literal>
<literal type="string">"{\n"</literal>
<literal type="string">" trace(\"R/W reader hold\");\n"</literal>
<literal type="string">" printa(@rw_r_hold, @rw_r_hold_count);\n"</literal>
<literal type="string">"}\n"</literal>
<literal type="string">"END\n"</literal>
<literal type="string">"/rw_w_hold_found/\n"</literal>
<literal type="string">"{\n"</literal>
<literal type="string">" trace(\"R/W writer hold\");\n"</literal>
<literal type="string">" printa(@rw_w_hold, @rw_w_hold_count);\n"</literal>
<literal type="string">"}\n"</literal></expr></init></decl>;</decl_stmt>







<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>g_ctnd_init</name> <init>=
<expr><literal type="string">"plockstat$target:::rw-block\n"</literal>
<literal type="string">"{\n"</literal>
<literal type="string">" self-&gt;rwblock[arg0] = timestamp;\n"</literal>
<literal type="string">"}\n"</literal>
<literal type="string">"plockstat$target:::mutex-block\n"</literal>
<literal type="string">"{\n"</literal>
<literal type="string">" self-&gt;mtxblock[arg0] = timestamp;\n"</literal>
<literal type="string">"}\n"</literal>
<literal type="string">"plockstat$target:::mutex-spin\n"</literal>
<literal type="string">"{\n"</literal>
<literal type="string">" self-&gt;mtxspin[arg0] = timestamp;\n"</literal>
<literal type="string">"}\n"</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>g_ctnd_histogram</name> <init>=
<expr><literal type="string">"plockstat$target:::rw-blocked\n"</literal>
<literal type="string">"/self-&gt;rwblock[arg0] &amp;&amp; arg1 == 1 &amp;&amp; arg2 != 0/\n"</literal>
<literal type="string">"{\n"</literal>
<literal type="string">" @rw_w_block[arg0, ustack()] =\n"</literal>
<literal type="string">" quantize(timestamp - self-&gt;rwblock[arg0]);\n"</literal>
<literal type="string">" self-&gt;rwblock[arg0] = 0;\n"</literal>
<literal type="string">" rw_w_block_found = 1;\n"</literal>
<literal type="string">"}\n"</literal>
<literal type="string">"plockstat$target:::rw-blocked\n"</literal>
<literal type="string">"/self-&gt;rwblock[arg0] &amp;&amp; arg2 != 0/\n"</literal>
<literal type="string">"{\n"</literal>
<literal type="string">" @rw_r_block[arg0, ustack()] =\n"</literal>
<literal type="string">" quantize(timestamp - self-&gt;rwblock[arg0]);\n"</literal>
<literal type="string">" self-&gt;rwblock[arg0] = 0;\n"</literal>
<literal type="string">" rw_r_block_found = 1;\n"</literal>
<literal type="string">"}\n"</literal>
<literal type="string">"plockstat$target:::rw-blocked\n"</literal>
<literal type="string">"/self-&gt;rwblock[arg0]/\n"</literal>
<literal type="string">"{\n"</literal>
<literal type="string">" self-&gt;rwblock[arg0] = 0;\n"</literal>
<literal type="string">"}\n"</literal>
<literal type="string">"plockstat$target:::mutex-spun\n"</literal>
<literal type="string">"/self-&gt;mtxspin[arg0] &amp;&amp; arg1 != 0/\n"</literal>
<literal type="string">"{\n"</literal>
<literal type="string">" @mtx_spin[arg0, ustack()] =\n"</literal>
<literal type="string">" quantize(timestamp - self-&gt;mtxspin[arg0]);\n"</literal>
<literal type="string">" self-&gt;mtxspin[arg0] = 0;\n"</literal>
<literal type="string">" mtx_spin_found = 1;\n"</literal>
<literal type="string">"}\n"</literal>
<literal type="string">"plockstat$target:::mutex-spun\n"</literal>
<literal type="string">"/self-&gt;mtxspin[arg0]/\n"</literal>
<literal type="string">"{\n"</literal>
<literal type="string">" @mtx_vain_spin[arg0, ustack()] =\n"</literal>
<literal type="string">" quantize(timestamp - self-&gt;mtxspin[arg0]);\n"</literal>
<literal type="string">" self-&gt;mtxspin[arg0] = 0;\n"</literal>
<literal type="string">" mtx_vain_spin_found = 1;\n"</literal>
<literal type="string">"}\n"</literal>
<literal type="string">"plockstat$target:::mutex-blocked\n"</literal>
<literal type="string">"/self-&gt;mtxblock[arg0] &amp;&amp; arg1 != 0/\n"</literal>
<literal type="string">"{\n"</literal>
<literal type="string">" @mtx_block[arg0, ustack()] =\n"</literal>
<literal type="string">" quantize(timestamp - self-&gt;mtxblock[arg0]);\n"</literal>
<literal type="string">" self-&gt;mtxblock[arg0] = 0;\n"</literal>
<literal type="string">" mtx_block_found = 1;\n"</literal>
<literal type="string">"}\n"</literal>
<literal type="string">"plockstat$target:::mutex-blocked\n"</literal>
<literal type="string">"/self-&gt;mtxblock[arg0]/\n"</literal>
<literal type="string">"{\n"</literal>
<literal type="string">" self-&gt;mtxblock[arg0] = 0;\n"</literal>
<literal type="string">"}\n"</literal>
<literal type="string">"\n"</literal>
<literal type="string">"END\n"</literal>
<literal type="string">"/mtx_block_found/\n"</literal>
<literal type="string">"{\n"</literal>
<literal type="string">" trace(\"Mutex block\");\n"</literal>
<literal type="string">" printa(@mtx_block);\n"</literal>
<literal type="string">"}\n"</literal>
<literal type="string">"END\n"</literal>
<literal type="string">"/mtx_spin_found/\n"</literal>
<literal type="string">"{\n"</literal>
<literal type="string">" trace(\"Mutex spin\");\n"</literal>
<literal type="string">" printa(@mtx_spin);\n"</literal>
<literal type="string">"}\n"</literal>
<literal type="string">"END\n"</literal>
<literal type="string">"/mtx_vain_spin_found/\n"</literal>
<literal type="string">"{\n"</literal>
<literal type="string">" trace(\"Mutex unsuccessful spin\");\n"</literal>
<literal type="string">" printa(@mtx_vain_spin);\n"</literal>
<literal type="string">"}\n"</literal>
<literal type="string">"END\n"</literal>
<literal type="string">"/rw_r_block_found/\n"</literal>
<literal type="string">"{\n"</literal>
<literal type="string">" trace(\"R/W reader block\");\n"</literal>
<literal type="string">" printa(@rw_r_block);\n"</literal>
<literal type="string">"}\n"</literal>
<literal type="string">"END\n"</literal>
<literal type="string">"/rw_w_block_found/\n"</literal>
<literal type="string">"{\n"</literal>
<literal type="string">" trace(\"R/W writer block\");\n"</literal>
<literal type="string">" printa(@rw_w_block);\n"</literal>
<literal type="string">"}\n"</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>g_ctnd_times</name> <init>=
<expr><literal type="string">"plockstat$target:::rw-blocked\n"</literal>
<literal type="string">"/self-&gt;rwblock[arg0] &amp;&amp; arg1 == 1 &amp;&amp; arg2 != 0/\n"</literal>
<literal type="string">"{\n"</literal>
<literal type="string">" @rw_w_block[arg0, ustack(5)] =\n"</literal>
<literal type="string">" sum(timestamp - self-&gt;rwblock[arg0]);\n"</literal>
<literal type="string">" @rw_w_block_count[arg0, ustack(5)] = count();\n"</literal>
<literal type="string">" self-&gt;rwblock[arg0] = 0;\n"</literal>
<literal type="string">" rw_w_block_found = 1;\n"</literal>
<literal type="string">"}\n"</literal>
<literal type="string">"plockstat$target:::rw-blocked\n"</literal>
<literal type="string">"/self-&gt;rwblock[arg0] &amp;&amp; arg2 != 0/\n"</literal>
<literal type="string">"{\n"</literal>
<literal type="string">" @rw_r_block[arg0, ustack(5)] =\n"</literal>
<literal type="string">" sum(timestamp - self-&gt;rwblock[arg0]);\n"</literal>
<literal type="string">" @rw_r_block_count[arg0, ustack(5)] = count();\n"</literal>
<literal type="string">" self-&gt;rwblock[arg0] = 0;\n"</literal>
<literal type="string">" rw_r_block_found = 1;\n"</literal>
<literal type="string">"}\n"</literal>
<literal type="string">"plockstat$target:::rw-blocked\n"</literal>
<literal type="string">"/self-&gt;rwblock[arg0]/\n"</literal>
<literal type="string">"{\n"</literal>
<literal type="string">" self-&gt;rwblock[arg0] = 0;\n"</literal>
<literal type="string">"}\n"</literal>
<literal type="string">"plockstat$target:::mutex-spun\n"</literal>
<literal type="string">"/self-&gt;mtxspin[arg0] &amp;&amp; arg1 != 0/\n"</literal>
<literal type="string">"{\n"</literal>
<literal type="string">" @mtx_spin[arg0, ustack(5)] =\n"</literal>
<literal type="string">" sum(timestamp - self-&gt;mtxspin[arg0]);\n"</literal>
<literal type="string">" @mtx_spin_count[arg0, ustack(5)] = count();\n"</literal>
<literal type="string">" self-&gt;mtxspin[arg0] = 0;\n"</literal>
<literal type="string">" mtx_spin_found = 1;\n"</literal>
<literal type="string">"}\n"</literal>
<literal type="string">"plockstat$target:::mutex-spun\n"</literal>
<literal type="string">"/self-&gt;mtxspin[arg0]/\n"</literal>
<literal type="string">"{\n"</literal>
<literal type="string">" @mtx_vain_spin[arg0, ustack(5)] =\n"</literal>
<literal type="string">" sum(timestamp - self-&gt;mtxspin[arg0]);\n"</literal>
<literal type="string">" @mtx_vain_spin_count[arg0, ustack(5)] = count();\n"</literal>
<literal type="string">" self-&gt;mtxspin[arg0] = 0;\n"</literal>
<literal type="string">" mtx_vain_spin_found = 1;\n"</literal>
<literal type="string">"}\n"</literal>
<literal type="string">"plockstat$target:::mutex-blocked\n"</literal>
<literal type="string">"/self-&gt;mtxblock[arg0] &amp;&amp; arg1 != 0/\n"</literal>
<literal type="string">"{\n"</literal>
<literal type="string">" @mtx_block[arg0, ustack(5)] =\n"</literal>
<literal type="string">" sum(timestamp - self-&gt;mtxblock[arg0]);\n"</literal>
<literal type="string">" @mtx_block_count[arg0, ustack(5)] = count();\n"</literal>
<literal type="string">" self-&gt;mtxblock[arg0] = 0;\n"</literal>
<literal type="string">" mtx_block_found = 1;\n"</literal>
<literal type="string">"}\n"</literal>
<literal type="string">"plockstat$target:::mutex-blocked\n"</literal>
<literal type="string">"/self-&gt;mtxblock[arg0]/\n"</literal>
<literal type="string">"{\n"</literal>
<literal type="string">" self-&gt;mtxblock[arg0] = 0;\n"</literal>
<literal type="string">"}\n"</literal>
<literal type="string">"\n"</literal>
<literal type="string">"END\n"</literal>
<literal type="string">"/mtx_block_found/\n"</literal>
<literal type="string">"{\n"</literal>
<literal type="string">" trace(\"Mutex block\");\n"</literal>
<literal type="string">" printa(@mtx_block, @mtx_block_count);\n"</literal>
<literal type="string">"}\n"</literal>
<literal type="string">"END\n"</literal>
<literal type="string">"/mtx_spin_found/\n"</literal>
<literal type="string">"{\n"</literal>
<literal type="string">" trace(\"Mutex spin\");\n"</literal>
<literal type="string">" printa(@mtx_spin, @mtx_spin_count);\n"</literal>
<literal type="string">"}\n"</literal>
<literal type="string">"END\n"</literal>
<literal type="string">"/mtx_vain_spin_found/\n"</literal>
<literal type="string">"{\n"</literal>
<literal type="string">" trace(\"Mutex unsuccessful spin\");\n"</literal>
<literal type="string">" printa(@mtx_vain_spin, @mtx_vain_spin_count);\n"</literal>
<literal type="string">"}\n"</literal>
<literal type="string">"END\n"</literal>
<literal type="string">"/rw_r_block_found/\n"</literal>
<literal type="string">"{\n"</literal>
<literal type="string">" trace(\"R/W reader block\");\n"</literal>
<literal type="string">" printa(@rw_r_block, @rw_r_block_count);\n"</literal>
<literal type="string">"}\n"</literal>
<literal type="string">"END\n"</literal>
<literal type="string">"/rw_w_block_found/\n"</literal>
<literal type="string">"{\n"</literal>
<literal type="string">" trace(\"R/W writer block\");\n"</literal>
<literal type="string">" printa(@rw_w_block, @rw_w_block_count);\n"</literal>
<literal type="string">"}\n"</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>g_prog</name><index>[<expr><literal type="number">4096</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name>g_proglen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>g_opt_V</name></decl>, <decl><type ref="prev"/><name>g_opt_s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>g_intr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>g_exited</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>dtrace_optval_t</name></type> <name>g_nframes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ulong_t</name></type> <name>g_nent</name> <init>= <expr><name>ULONG_MAX</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PLOCKSTAT_OPTSTR</name></cpp:macro> <cpp:value>"n:ps:e:vx:ACHV"</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>usage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Usage:\n"</literal>
<literal type="string">"\t%s [-vACHV] [-n count] [-s depth] [-e secs] [-x opt[=val]]\n"</literal>
<literal type="string">"\t command [arg...]\n"</literal>
<literal type="string">"\t%s [-vACHV] [-n count] [-s depth] [-e secs] [-x opt[=val]]\n"</literal>
<literal type="string">"\t -p pid\n"</literal></expr></argument>, <argument><expr><name>g_pname</name></expr></argument>, <argument><expr><name>g_pname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>E_USAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>verror</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>ap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>error</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: "</literal></expr></argument>, <argument><expr><name>g_pname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>vfprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fmt</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">": %s\n"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>fatal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verror</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>g_pr</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>g_dtp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dtrace_proc_release</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>, <argument><expr><name>g_pr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>E_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>dfatal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: "</literal></expr></argument>, <argument><expr><name>g_pname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fmt</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>vfprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fmt</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>fmt</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">": %s\n"</literal></expr></argument>,
<argument><expr><call><name>dtrace_errmsg</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>, <argument><expr><call><name>dtrace_errno</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>fmt</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>,
<argument><expr><call><name>dtrace_errmsg</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>, <argument><expr><call><name>dtrace_errno</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>g_pr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dtrace_proc_continue</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>, <argument><expr><name>g_pr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dtrace_proc_release</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>, <argument><expr><name>g_pr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>E_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>notice</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verror</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dprog_add</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prog</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>prog</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>bcopy</name><argument_list>(<argument><expr><name>prog</name></expr></argument>, <argument><expr><name>g_prog</name> <operator>+</operator> <name>g_proglen</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>g_proglen</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>g_proglen</name> <operator>&lt;</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>g_prog</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dprog_compile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_prog_t</name> <modifier>*</modifier></type><name>prog</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_proginfo_t</name></type> <name>info</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>g_opt_V</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: vvvv D program vvvv\n"</literal></expr></argument>, <argument><expr><name>g_pname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fputs</name><argument_list>(<argument><expr><name>g_prog</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: ^^^^ D program ^^^^\n"</literal></expr></argument>, <argument><expr><name>g_pname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>prog</name> <operator>=</operator> <call><name>dtrace_program_strcompile</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>, <argument><expr><name>g_prog</name></expr></argument>,
<argument><expr><name>DTRACE_PROBESPEC_NAME</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dfatal</name><argument_list>(<argument><expr><literal type="string">"failed to compile program"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dtrace_program_exec</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>, <argument><expr><name>prog</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dfatal</name><argument_list>(<argument><expr><literal type="string">"failed to enable probes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>print_legend</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%5s %8s %-28s %s\n"</literal></expr></argument>, <argument><expr><literal type="string">"Count"</literal></expr></argument>, <argument><expr><literal type="string">"nsec"</literal></expr></argument>, <argument><expr><literal type="string">"Lock"</literal></expr></argument>, <argument><expr><literal type="string">"Caller"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>print_bar</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"---------------------------------------"</literal>
<literal type="string">"----------------------------------------\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>print_histogram_header</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n%10s ---- Time Distribution --- %5s %s\n"</literal></expr></argument>,
<argument><expr><literal type="string">"nsec"</literal></expr></argument>, <argument><expr><literal type="string">"count"</literal></expr></argument>, <argument><expr><literal type="string">"Stack"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>int</name></type>
<name>getsym</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ps_prochandle</name></name> <modifier>*</modifier></type><name>P</name></decl></parameter>, <parameter><decl><type><name>uintptr_t</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>nolocks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>name</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GElf_Sym</name></type> <name>sym</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>illumos</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>prsyminfo_t</name></type> <name>info</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>prmap_t</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>info</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>P</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>Pxlookup_by_addr</name><argument_list>(<argument><expr><name>P</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><operator>&amp;</operator><name>sym</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="string">"%#lx"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>illumos</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>.</operator><name>prs_object</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>info</name><operator>.</operator><name>prs_object</name></name> <operator>=</operator> <literal type="string">"&lt;unknown&gt;"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>.</operator><name>prs_lmid</name></name> <operator>!=</operator> <name>LM_ID_BASE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="string">"LM%lu`"</literal></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>prs_lmid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> <operator>-=</operator> <name>len</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="string">"%s`%s"</literal></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>prs_object</name></name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>prs_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>map</name> <operator>=</operator> <call><name>proc_addr2map</name><argument_list>(<argument><expr><name>P</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="string">"%s`%s"</literal></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>pr_mapname</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>buf</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> <operator>-=</operator> <name>len</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sym</name><operator>.</operator><name>st_value</name></name> <operator>!=</operator> <name>addr</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="string">"+%#lx"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><operator>(</operator><name>addr</name> <operator>-</operator> <name><name>sym</name><operator>.</operator><name>st_value</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>nolocks</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"libc.so.1"</literal></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>pr_mapname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><call><name>strstr</name><argument_list>(<argument><expr><literal type="string">"mutex"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
<call><name>strstr</name><argument_list>(<argument><expr><literal type="string">"rw"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>process_aggregate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dtrace_aggdata_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>aggsdata</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>naggvars</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>dtrace_recdesc_t</name> <modifier>*</modifier></type><name>rec</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uintptr_t</name></type> <name>lock</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>caddr_t</name></type> <name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>ps_prochandle</name></name> <modifier>*</modifier></type><name>P</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>sum</name></decl>, <decl><type ref="prev"/><name>count</name></decl>, <decl><type ref="prev"/><name>avg</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><operator>(</operator><name>uint_t</name> <operator>*</operator><operator>)</operator><name>arg</name><operator>)</operator><operator>++</operator> <operator>&gt;=</operator> <name>g_nent</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>DTRACE_AGGWALK_NEXT</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>rec</name> <operator>=</operator> <name><name>aggsdata</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>dtada_desc</name><operator>-&gt;</operator><name>dtagd_rec</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>data</name> <operator>=</operator> <name><name>aggsdata</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>dtada_data</name></expr>;</expr_stmt>


<expr_stmt><expr><name>lock</name> <operator>=</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>*</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>data</name> <operator>+</operator> <name><name>rec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>dtrd_offset</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>stack</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>data</name> <operator>+</operator> <name><name>rec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>dtrd_offset</name><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>g_opt_s</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>sum</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>aggsdata</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>dtada_data</name> <operator>+</operator>
<name><name>aggsdata</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name><name>dtada_desc</name><operator>-&gt;</operator><name>dtagd_rec</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>dtrd_offset</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>count</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>aggsdata</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>dtada_data</name> <operator>+</operator>
<name><name>aggsdata</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name><name>dtada_desc</name><operator>-&gt;</operator><name>dtagd_rec</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>dtrd_offset</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>


<expr_stmt><expr><name>a</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>aggsdata</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>dtada_data</name> <operator>+</operator>
<name><name>aggsdata</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name><name>dtada_desc</name><operator>-&gt;</operator><name>dtagd_rec</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>dtrd_offset</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>print_bar</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>print_legend</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>count</name> <operator>=</operator> <name>sum</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>i</name> <operator>=</operator> <name>DTRACE_QUANTIZE_ZEROBUCKET</name></expr><operator>,</operator> <expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init>
<condition><expr><name>i</name> <operator>&lt;</operator> <name>DTRACE_QUANTIZE_NBUCKETS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>count</name> <operator>+=</operator> <name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>sum</name> <operator>+=</operator> <name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;&lt;</operator> <operator>(</operator><name>j</name> <operator>-</operator> <literal type="number">64</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>avg</name> <operator>=</operator> <name>sum</name> <operator>/</operator> <name>count</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%5llu %8llu "</literal></expr></argument>, <argument><expr><operator>(</operator><name>u_longlong_t</name><operator>)</operator><name>count</name></expr></argument>, <argument><expr><operator>(</operator><name>u_longlong_t</name><operator>)</operator><name>avg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>pid</name> <operator>=</operator> <name><name>stack</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>P</name> <operator>=</operator> <call><name>dtrace_proc_grab</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>PGRAB_RDONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>getsym</name><argument_list>(<argument><expr><name>P</name></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%-28s "</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <literal type="number">5</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>getsym</name><argument_list>(<argument><expr><name>P</name></expr></argument>, <argument><expr><name><name>stack</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>g_opt_s</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>stack_done</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>quant_done</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>first_bin</name></decl>, <decl><type ref="prev"/><name>last_bin</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>bin_size</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>


<expr_stmt><expr><name>a</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>aggsdata</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>dtada_data</name> <operator>+</operator>
<name><name>aggsdata</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name><name>dtada_desc</name><operator>-&gt;</operator><name>dtagd_rec</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>dtrd_offset</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>print_histogram_header</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>first_bin</name> <operator>=</operator> <name>DTRACE_QUANTIZE_ZEROBUCKET</name></expr>;</init>
<condition><expr><name><name>a</name><index>[<expr><name>first_bin</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>first_bin</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></for>
<for>for <control>(<init><expr><name>last_bin</name> <operator>=</operator> <name>DTRACE_QUANTIZE_ZEROBUCKET</name> <operator>+</operator> <literal type="number">63</literal></expr>;</init>
<condition><expr><name><name>a</name><index>[<expr><name>last_bin</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>last_bin</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>!</operator><name>stack_done</name> <operator>||</operator> <operator>!</operator><name>quant_done</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>stack_done</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>getsym</name><argument_list>(<argument><expr><name>P</name></expr></argument>, <argument><expr><name><name>stack</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>,
<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>quant_done</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>bin_size</name> <operator>=</operator> <name><name>a</name><index>[<expr><name>first_bin</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%10llu |%-24.*s| %5llu %s\n"</literal></expr></argument>,
<argument><expr><literal type="number">1ULL</literal> <operator>&lt;&lt;</operator>
<operator>(</operator><name>first_bin</name> <operator>-</operator> <name>DTRACE_QUANTIZE_ZEROBUCKET</name><operator>)</operator></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><literal type="number">24.0</literal> <operator>*</operator> <name>bin_size</name> <operator>/</operator> <name>count</name><operator>)</operator></expr></argument>,
<argument><expr><literal type="string">"@@@@@@@@@@@@@@@@@@@@@@@@@@"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>u_longlong_t</name><operator>)</operator><name>bin_size</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%43s %s\n"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name>g_nframes</name> <operator>||</operator> <name><name>stack</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>stack_done</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>first_bin</name><operator>++</operator> <operator>==</operator> <name>last_bin</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>quant_done</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>dtrace_proc_release</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>, <argument><expr><name>P</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>DTRACE_AGGWALK_NEXT</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>prochandler</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ps_prochandle</name></name> <modifier>*</modifier></type><name>P</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>illumos</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>psinfo_t</name> <modifier>*</modifier></type><name>prp</name> <init>= <expr><call><name>Ppsinfo</name><argument_list>(<argument><expr><name>P</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pid</name> <init>= <expr><call><name>Pstatus</name><argument_list>(<argument><expr><name>P</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>pr_pid</name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>int</name></type> <name>pid</name> <init>= <expr><call><name>proc_getpid</name><argument_list>(<argument><expr><name>P</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>wstat</name> <init>= <expr><call><name>proc_getwstat</name><argument_list>(<argument><expr><name>P</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>char</name></type> <name><name>name</name><index>[<expr><name>SIG2STR_MAX</name></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>msg</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>notice</name><argument_list>(<argument><expr><literal type="string">"pid %d: %s\n"</literal></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><call><name>Pstate</name><argument_list>(<argument><expr><name>P</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>PS_UNDEAD</name></expr>:</case>








<if_stmt><if>if <condition>(<expr><call><name>WIFSIGNALED</name><argument_list>(<argument><expr><name>wstat</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>notice</name><argument_list>(<argument><expr><literal type="string">"pid %d terminated by %s\n"</literal></expr></argument>, <argument><expr><name>pid</name></expr></argument>,
<argument><expr><call><name>proc_signame</name><argument_list>(<argument><expr><call><name>WTERMSIG</name><argument_list>(<argument><expr><name>wstat</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>name</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>WEXITSTATUS</name><argument_list>(<argument><expr><name>wstat</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>notice</name><argument_list>(<argument><expr><literal type="string">"pid %d exited with status %d\n"</literal></expr></argument>,
<argument><expr><name>pid</name></expr></argument>, <argument><expr><call><name>WEXITSTATUS</name><argument_list>(<argument><expr><name>wstat</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>notice</name><argument_list>(<argument><expr><literal type="string">"pid %d has exited\n"</literal></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>g_exited</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>PS_LOST</name></expr>:</case>
<expr_stmt><expr><call><name>notice</name><argument_list>(<argument><expr><literal type="string">"pid %d exec'd a set-id or unobservable program\n"</literal></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>g_exited</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>chewrec</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dtrace_probedata_t</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>dtrace_recdesc_t</name> <modifier>*</modifier></type><name>rec</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_eprobedesc_t</name> <modifier>*</modifier></type><name>epd</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>dtpda_edesc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_aggvarid_t</name></type> <name><name>aggvars</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>nagv</name></decl>;</decl_stmt>




<if_stmt><if>if <condition>(<expr><name>rec</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>DTRACE_CONSUME_NEXT</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>dtpda_data</name></name> <operator>-</operator> <name><name>rec</name><operator>-&gt;</operator><name>dtrd_offset</name></name></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>dtrd_action</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DTRACEACT_DIFEXPR</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n%s\n\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>buf</name> <operator>+</operator> <name><name>rec</name><operator>-&gt;</operator><name>dtrd_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>g_opt_s</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>print_legend</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>print_bar</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>DTRACE_CONSUME_NEXT</name><operator>)</operator></expr>;</return>

<case>case <expr><name>DTRACEACT_PRINTA</name></expr>:</case>
<for>for <control>(<init><expr><name>nagv</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>epd</name><operator>-&gt;</operator><name>dtepd_nrecs</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>dtrace_recdesc_t</name> <modifier>*</modifier></type><name>nrec</name> <init>= <expr><operator>&amp;</operator><name><name>rec</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>nrec</name><operator>-&gt;</operator><name>dtrd_uarg</name></name> <operator>!=</operator> <name><name>rec</name><operator>-&gt;</operator><name>dtrd_uarg</name></name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>


<expr_stmt><expr><name><name>aggvars</name><index>[<expr><name>nagv</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>dtrace_aggvarid_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>caddr_t</name><operator>)</operator><name>buf</name> <operator>+</operator>
<name><name>nrec</name><operator>-&gt;</operator><name>dtrd_offset</name></name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>nagv</name> <operator>==</operator> <operator>(</operator><ternary><condition><expr><name>g_opt_s</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint_t</name></type> <name>nent</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dtrace_aggregate_walk_joined</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>, <argument><expr><name>aggvars</name></expr></argument>, <argument><expr><name>nagv</name></expr></argument>,
<argument><expr><name>process_aggregate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nent</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dfatal</name><argument_list>(<argument><expr><literal type="string">"failed to walk aggregate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><name>DTRACE_CONSUME_NEXT</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>

<return>return <expr><operator>(</operator><name>DTRACE_CONSUME_THIS</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>intr</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>signo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>g_intr</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>illumos</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>ucred_t</name> <modifier>*</modifier></type><name>ucp</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>opt_C</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>opt_H</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>opt_p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>opt_v</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sigaction</name></name></type> <name>act</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>done</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>g_pname</name> <operator>=</operator> <call><name>basename</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>g_pname</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>illumos</name></expr></argument>)</argument_list></call></expr></cpp:if>



<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ucp</name> <operator>=</operator> <call><name>ucred_get</name><argument_list>(<argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>priv_set_t</name> <modifier>*</modifier></type><name>psp</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>psp</name> <operator>=</operator> <call><name>ucred_getprivset</name><argument_list>(<argument><expr><name>ucp</name></expr></argument>, <argument><expr><name>PRIV_EFFECTIVE</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>priv_ismember</name><argument_list>(<argument><expr><name>psp</name></expr></argument>, <argument><expr><name>PRIV_DTRACE_PROC</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"dtrace_proc privilege required\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ucred_free</name><argument_list>(<argument><expr><name>ucp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>getopt</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>PLOCKSTAT_OPTSTR</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>EOF</name></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'n'</literal></expr>:</case>
<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>g_nent</name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>end</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>||</operator> <name>errno</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: invalid count "</literal>
<literal type="string">"'%s'\n"</literal></expr></argument>, <argument><expr><name>g_pname</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'p'</literal></expr>:</case>
<expr_stmt><expr><name>opt_p</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'v'</literal></expr>:</case>
<expr_stmt><expr><name>opt_v</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'A'</literal></expr>:</case>
<expr_stmt><expr><name>opt_C</name> <operator>=</operator> <name>opt_H</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'C'</literal></expr>:</case>
<expr_stmt><expr><name>opt_C</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'H'</literal></expr>:</case>
<expr_stmt><expr><name>opt_H</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'V'</literal></expr>:</case>
<expr_stmt><expr><name>g_opt_V</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>

<default>default:</default>
<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>PLOCKSTAT_OPTSTR</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></switch>
</block_content>}</block></while>




<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <name>optind</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>opt_C</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>opt_H</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>opt_C</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>g_dtp</name> <operator>=</operator> <call><name>dtrace_open</name><argument_list>(<argument><expr><name>DTRACE_VERSION</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"failed to initialize dtrace: %s\n"</literal></expr></argument>,
<argument><expr><call><name>dtrace_errmsg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><call><name>dtrace_setopt</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>, <argument><expr><literal type="string">"strsize"</literal></expr></argument>, <argument><expr><literal type="string">"32"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dfatal</name><argument_list>(<argument><expr><literal type="string">"failed to set 'strsize'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><call><name>dtrace_setopt</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>, <argument><expr><literal type="string">"bufsize"</literal></expr></argument>, <argument><expr><literal type="string">"1k"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dfatal</name><argument_list>(<argument><expr><literal type="string">"failed to set 'bufsize'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><call><name>dtrace_setopt</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>, <argument><expr><literal type="string">"aggsortrev"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dfatal</name><argument_list>(<argument><expr><literal type="string">"failed to set 'aggsortrev'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><call><name>dtrace_setopt</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>, <argument><expr><literal type="string">"aggsize"</literal></expr></argument>, <argument><expr><literal type="string">"256k"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dfatal</name><argument_list>(<argument><expr><literal type="string">"failed to set 'aggsize'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dtrace_setopt</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>, <argument><expr><literal type="string">"aggrate"</literal></expr></argument>, <argument><expr><literal type="string">"1sec"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dfatal</name><argument_list>(<argument><expr><literal type="string">"failed to set 'aggrate'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>





<expr_stmt><expr><name>optind</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>getopt</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>PLOCKSTAT_OPTSTR</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>EOF</name></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'s'</literal></expr>:</case>
<expr_stmt><expr><name>g_opt_s</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dtrace_setopt</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>, <argument><expr><literal type="string">"ustackframes"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dfatal</name><argument_list>(<argument><expr><literal type="string">"failed to set 'ustackframes'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'x'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dtrace_setopt</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dfatal</name><argument_list>(<argument><expr><literal type="string">"failed to set -x %s"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'e'</literal></expr>:</case>
<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>optarg</name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <operator>*</operator><name>end</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>||</operator> <name>errno</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: invalid timeout "</literal>
<literal type="string">"'%s'\n"</literal></expr></argument>, <argument><expr><name>g_pname</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>





<expr_stmt><expr><call><name>dprog_add</name><argument_list>(<argument><expr><literal type="string">"BEGIN\n{\n\tend = timestamp + "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dprog_add</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dprog_add</name><argument_list>(<argument><expr><literal type="string">" * 1000000000;\n}\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dprog_add</name><argument_list>(<argument><expr><literal type="string">"tick-10hz\n/timestamp &gt;= end/\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dprog_add</name><argument_list>(<argument><expr><literal type="string">"{\n\texit(0);\n}\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></while>

<expr_stmt><expr><name>argc</name> <operator>-=</operator> <name>optind</name></expr>;</expr_stmt>
<expr_stmt><expr><name>argv</name> <operator>+=</operator> <name>optind</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>opt_H</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dprog_add</name><argument_list>(<argument><expr><name>g_hold_init</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>g_opt_s</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dprog_add</name><argument_list>(<argument><expr><name>g_hold_times</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dprog_add</name><argument_list>(<argument><expr><name>g_hold_histogram</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>opt_C</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dprog_add</name><argument_list>(<argument><expr><name>g_ctnd_init</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>g_opt_s</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dprog_add</name><argument_list>(<argument><expr><name>g_ctnd_times</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dprog_add</name><argument_list>(<argument><expr><name>g_ctnd_histogram</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>opt_p</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ulong_t</name></type> <name>pid</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: only one pid is allowed\n"</literal></expr></argument>,
<argument><expr><name>g_pname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>pid</name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>end</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>||</operator> <name>errno</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>pid_t</name><operator>)</operator><name>pid</name> <operator>!=</operator> <name>pid</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: invalid pid '%s'\n"</literal></expr></argument>,
<argument><expr><name>g_pname</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>g_pr</name> <operator>=</operator> <call><name>dtrace_proc_grab</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>, <argument><expr><operator>(</operator><name>pid_t</name><operator>)</operator><name>pid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dfatal</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>g_pr</name> <operator>=</operator> <call><name>dtrace_proc_create</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dfatal</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>dprog_compile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dtrace_handle_proc</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prochandler</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dfatal</name><argument_list>(<argument><expr><literal type="string">"failed to establish proc handler"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sigemptyset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>act</name><operator>.</operator><name>sa_mask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>act</name><operator>.</operator><name>sa_flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>act</name><operator>.</operator><name>sa_handler</name></name> <operator>=</operator> <name>intr</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sigaction</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>act</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sigaction</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>act</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dtrace_go</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dfatal</name><argument_list>(<argument><expr><literal type="string">"dtrace_go()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dtrace_getopt</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>, <argument><expr><literal type="string">"ustackframes"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>g_nframes</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dfatal</name><argument_list>(<argument><expr><literal type="string">"failed to get 'ustackframes'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>dtrace_proc_continue</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>, <argument><expr><name>g_pr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>opt_v</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s: tracing enabled for pid %d\n"</literal></expr></argument>, <argument><expr><name>g_pname</name></expr></argument>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>illumos</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>Pstatus</name><argument_list>(<argument><expr><name>g_pr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>pr_pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>proc_getpid</name><argument_list>(<argument><expr><name>g_pr</name></expr></argument>)</argument_list></call></expr></expr_stmt>)</block_content></block>;</function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<do>do <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>g_intr</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>done</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dtrace_sleep</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>done</name> <operator>||</operator> <name>g_intr</name> <operator>||</operator> <name>g_exited</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>done</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dtrace_stop</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dfatal</name><argument_list>(<argument><expr><literal type="string">"couldn't stop tracing"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><call><name>dtrace_work</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>, <argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>chewrec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DTRACE_WORKSTATUS_DONE</name></expr>:</case>
<expr_stmt><expr><name>done</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DTRACE_WORKSTATUS_OKAY</name></expr>:</case>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>dfatal</name><argument_list>(<argument><expr><literal type="string">"processing aborted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>

</block_content>}</block> while <condition>(<expr><operator>!</operator><name>done</name></expr>)</condition>;</do>

<expr_stmt><expr><call><name>dtrace_close</name><argument_list>(<argument><expr><name>g_dtp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
}
</unit>
