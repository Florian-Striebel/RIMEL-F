<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/cddl/contrib/opensolaris/lib/libdtrace/common/dt_cc.c">




















































































<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/wait.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/sysmacros.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;strings.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ucontext.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dirent.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dt_module.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dt_program.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dt_provider.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dt_printf.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dt_pid.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dt_grammar.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dt_ident.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dt_string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dt_impl.h&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>dtrace_diftype_t</name></type> <name>dt_void_rtype</name> <init>= <expr><block>{
<expr><name>DIF_TYPE_CTF</name></expr>, <expr><name>CTF_K_INTEGER</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>dtrace_diftype_t</name></type> <name>dt_int_rtype</name> <init>= <expr><block>{
<expr><name>DIF_TYPE_CTF</name></expr>, <expr><name>CTF_K_INTEGER</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr>sizeof <operator>(</operator><name>uint64_t</name><operator>)</operator></expr>
}</block></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>dt_compile</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>dtrace_probespec_t</name></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>,
<parameter><decl><type><name>uint_t</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier>[]</type></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_idreset</name><parameter_list>(<parameter><decl><type><name>dt_idhash_t</name> <modifier>*</modifier></type><name>dhp</name></decl></parameter>, <parameter><decl><type><name>dt_ident_t</name> <modifier>*</modifier></type><name>idp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ignored</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>idp</name><operator>-&gt;</operator><name>di_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>DT_IDFLG_REF</name> <operator>|</operator> <name>DT_IDFLG_MOD</name> <operator>|</operator>
<name>DT_IDFLG_DIFR</name> <operator>|</operator> <name>DT_IDFLG_DIFW</name><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_idpragma</name><parameter_list>(<parameter><decl><type><name>dt_idhash_t</name> <modifier>*</modifier></type><name>dhp</name></decl></parameter>, <parameter><decl><type><name>dt_ident_t</name> <modifier>*</modifier></type><name>idp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ignored</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>yylineno</name> <operator>=</operator> <name><name>idp</name><operator>-&gt;</operator><name>di_lineno</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_PRAGMA_UNUSED</name></expr></argument>, <argument><expr><literal type="string">"unused #pragma %s\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>idp</name><operator>-&gt;</operator><name>di_iarg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>dtrace_stmtdesc_t</name> <modifier>*</modifier></type>
<name>dt_stmt_create</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>dtrace_ecbdesc_t</name> <modifier>*</modifier></type><name>edp</name></decl></parameter>,
<parameter><decl><type><name>dtrace_attribute_t</name></type> <name>descattr</name></decl></parameter>, <parameter><decl><type><name>dtrace_attribute_t</name></type> <name>stmtattr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_stmtdesc_t</name> <modifier>*</modifier></type><name>sdp</name> <init>= <expr><call><name>dtrace_stmt_create</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>edp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>sdp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_NOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_stmt</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_stmt</name></name> <operator>=</operator> <name>sdp</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sdp</name><operator>-&gt;</operator><name>dtsd_descattr</name></name> <operator>=</operator> <name>descattr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sdp</name><operator>-&gt;</operator><name>dtsd_stmtattr</name></name> <operator>=</operator> <name>stmtattr</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>sdp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>dtrace_actdesc_t</name> <modifier>*</modifier></type>
<name>dt_stmt_action</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>dtrace_stmtdesc_t</name> <modifier>*</modifier></type><name>sdp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_actdesc_t</name> <modifier>*</modifier></type><name>new</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>new</name> <operator>=</operator> <call><name>dtrace_stmt_action</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_NOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><name>new</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_action_destructive</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dtrace_actdesc_t</name> <modifier>*</modifier></type><name>ap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><call><name>DTRACEACT_ISDESTRUCTIVE</name><argument_list>(<argument><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_kind</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name><name>ap</name><operator>-&gt;</operator><name>dtad_kind</name></name> <operator>==</operator>
<name>DTRACEACT_DIFEXPR</name> <operator>&amp;&amp;</operator> <name><name>ap</name><operator>-&gt;</operator><name>dtad_difo</name><operator>-&gt;</operator><name>dtdo_destructive</name></name><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_stmt_append</name><parameter_list>(<parameter><decl><type><name>dtrace_stmtdesc_t</name> <modifier>*</modifier></type><name>sdp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_ecbdesc_t</name> <modifier>*</modifier></type><name>edp</name> <init>= <expr><name><name>sdp</name><operator>-&gt;</operator><name>dtsd_ecbdesc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_actdesc_t</name> <modifier>*</modifier></type><name>ap</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>commit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>speculate</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>datarec</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>




<for>for <control>(<init><expr><name>ap</name> <operator>=</operator> <name><name>edp</name><operator>-&gt;</operator><name>dted_action</name></name></expr>;</init> <condition><expr><name>ap</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ap</name> <operator>=</operator> <name><name>ap</name><operator>-&gt;</operator><name>dtad_next</name></name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_kind</name></name> <operator>==</operator> <name>DTRACEACT_COMMIT</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>commit</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_COMM_COMM</name></expr></argument>, <argument><expr><literal type="string">"commit( ) may "</literal>
<literal type="string">"not follow commit( )\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>datarec</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_COMM_DREC</name></expr></argument>, <argument><expr><literal type="string">"commit( ) may "</literal>
<literal type="string">"not follow data-recording action(s)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>tap</name> <operator>=</operator> <name>ap</name></expr>;</init> <condition><expr><name>tap</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>tap</name> <operator>=</operator> <name><name>tap</name><operator>-&gt;</operator><name>dtad_next</name></name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DTRACEACT_ISAGG</name><argument_list>(<argument><expr><name><name>tap</name><operator>-&gt;</operator><name>dtad_kind</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_AGG_COMM</name></expr></argument>, <argument><expr><literal type="string">"aggregating actions "</literal>
<literal type="string">"may not follow commit( )\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>commit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_kind</name></name> <operator>==</operator> <name>DTRACEACT_SPECULATE</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>speculate</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_SPEC_SPEC</name></expr></argument>, <argument><expr><literal type="string">"speculate( ) may "</literal>
<literal type="string">"not follow speculate( )\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>commit</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_SPEC_COMM</name></expr></argument>, <argument><expr><literal type="string">"speculate( ) may "</literal>
<literal type="string">"not follow commit( )\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>datarec</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_SPEC_DREC</name></expr></argument>, <argument><expr><literal type="string">"speculate( ) may "</literal>
<literal type="string">"not follow data-recording action(s)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>speculate</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>DTRACEACT_ISAGG</name><argument_list>(<argument><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_kind</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>speculate</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_AGG_SPEC</name></expr></argument>, <argument><expr><literal type="string">"aggregating actions "</literal>
<literal type="string">"may not follow speculate( )\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>datarec</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>speculate</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dt_action_destructive</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_ACT_SPEC</name></expr></argument>, <argument><expr><literal type="string">"destructive actions "</literal>
<literal type="string">"may not follow speculate( )\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_kind</name></name> <operator>==</operator> <name>DTRACEACT_EXIT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_EXIT_SPEC</name></expr></argument>, <argument><expr><literal type="string">"exit( ) may not "</literal>
<literal type="string">"follow speculate( )\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><call><name>dt_action_destructive</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call> <operator>||</operator>
<name><name>ap</name><operator>-&gt;</operator><name>dtad_kind</name></name> <operator>==</operator> <name>DTRACEACT_DISCARD</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_kind</name></name> <operator>==</operator> <name>DTRACEACT_DIFEXPR</name> <operator>&amp;&amp;</operator>
<name><name>ap</name><operator>-&gt;</operator><name>dtad_difo</name><operator>-&gt;</operator><name>dtdo_rtype</name><operator>.</operator><name>dtdt_kind</name></name> <operator>==</operator> <name>DIF_TYPE_CTF</name> <operator>&amp;&amp;</operator>
<name><name>ap</name><operator>-&gt;</operator><name>dtad_difo</name><operator>-&gt;</operator><name>dtdo_rtype</name><operator>.</operator><name>dtdt_size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>commit</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_DREC_COMM</name></expr></argument>, <argument><expr><literal type="string">"data-recording actions "</literal>
<literal type="string">"may not follow commit( )\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>speculate</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>datarec</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><call><name>dtrace_stmt_add</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></argument>, <argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_prog</name></name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><call><name>dtrace_errno</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_stmt</name></name> <operator>==</operator> <name>sdp</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_stmt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_action_difconst</name><parameter_list>(<parameter><decl><type><name>dtrace_actdesc_t</name> <modifier>*</modifier></type><name>ap</name></decl></parameter>, <parameter><decl><type><name>uint_t</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>dtrace_actkind_t</name></type> <name>kind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name> <init>= <expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_difo_t</name> <modifier>*</modifier></type><name>dp</name> <init>= <expr><call><name>dt_zalloc</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>dtrace_difo_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>dp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_NOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>dp</name><operator>-&gt;</operator><name>dtdo_buf</name></name> <operator>=</operator> <call><name>dt_alloc</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>dif_instr_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dp</name><operator>-&gt;</operator><name>dtdo_inttab</name></name> <operator>=</operator> <call><name>dt_alloc</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dp</name><operator>-&gt;</operator><name>dtdo_buf</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>dp</name><operator>-&gt;</operator><name>dtdo_inttab</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_difo_free</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_NOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>dp</name><operator>-&gt;</operator><name>dtdo_buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>DIF_INSTR_SETX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dp</name><operator>-&gt;</operator><name>dtdo_buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>DIF_INSTR_RET</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dp</name><operator>-&gt;</operator><name>dtdo_len</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dp</name><operator>-&gt;</operator><name>dtdo_inttab</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dp</name><operator>-&gt;</operator><name>dtdo_intlen</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dp</name><operator>-&gt;</operator><name>dtdo_rtype</name></name> <operator>=</operator> <name>dt_int_rtype</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_difo</name></name> <operator>=</operator> <name>dp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_kind</name></name> <operator>=</operator> <name>kind</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_action_clear</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>dtrace_stmtdesc_t</name> <modifier>*</modifier></type><name>sdp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_ident_t</name> <modifier>*</modifier></type><name>aid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_actdesc_t</name> <modifier>*</modifier></type><name>ap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>anp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>n</name><index>[<expr><name>DT_TYPE_NAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>argc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>anp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name></name></expr>;</init> <condition><expr><name>anp</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>anp</name> <operator>=</operator> <name><name>anp</name><operator>-&gt;</operator><name>dn_list</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>argc</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_CLEAR_PROTO</name></expr></argument>,
<argument><expr><literal type="string">"%s( ) prototype mismatch: %d args passed, 1 expected\n"</literal></expr></argument>,
<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>anp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>anp</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>anp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>!=</operator> <name>DT_NODE_AGG</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_CLEAR_AGGARG</name></expr></argument>,
<argument><expr><literal type="string">"%s( ) argument #1 is incompatible with prototype:\n"</literal>
<literal type="string">"\tprototype: aggregation\n\t argument: %s\n"</literal></expr></argument>,
<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>,
<argument><expr><call><name>dt_node_type_name</name><argument_list>(<argument><expr><name>anp</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>aid</name> <operator>=</operator> <name><name>anp</name><operator>-&gt;</operator><name>dn_ident</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>aid</name><operator>-&gt;</operator><name>di_gen</name></name> <operator>==</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_gen</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>aid</name><operator>-&gt;</operator><name>di_flags</name></name> <operator>&amp;</operator> <name>DT_IDFLG_MOD</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_CLEAR_AGGBAD</name></expr></argument>,
<argument><expr><literal type="string">"undefined aggregation: @%s\n"</literal></expr></argument>, <argument><expr><name><name>aid</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ap</name> <operator>=</operator> <call><name>dt_stmt_action</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_action_difconst</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name><name>anp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_id</name></name></expr></argument>, <argument><expr><name>DTRACEACT_LIBACT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_arg</name></name> <operator>=</operator> <name>DT_ACT_CLEAR</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_action_normalize</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>dtrace_stmtdesc_t</name> <modifier>*</modifier></type><name>sdp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_ident_t</name> <modifier>*</modifier></type><name>aid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_actdesc_t</name> <modifier>*</modifier></type><name>ap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>anp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>normal</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>denormal</name> <init>= <expr><operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>, <argument><expr><literal type="string">"denormalize"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>n</name><index>[<expr><name>DT_TYPE_NAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>argc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>anp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name></name></expr>;</init> <condition><expr><name>anp</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>anp</name> <operator>=</operator> <name><name>anp</name><operator>-&gt;</operator><name>dn_list</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>argc</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>denormal</name> <operator>&amp;&amp;</operator> <name>argc</name> <operator>!=</operator> <literal type="number">1</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>!</operator><name>denormal</name> <operator>&amp;&amp;</operator> <name>argc</name> <operator>!=</operator> <literal type="number">2</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_NORMALIZE_PROTO</name></expr></argument>,
<argument><expr><literal type="string">"%s( ) prototype mismatch: %d args passed, %d expected\n"</literal></expr></argument>,
<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><ternary><condition><expr><name>denormal</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>anp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>anp</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>anp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>!=</operator> <name>DT_NODE_AGG</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_NORMALIZE_AGGARG</name></expr></argument>,
<argument><expr><literal type="string">"%s( ) argument #1 is incompatible with prototype:\n"</literal>
<literal type="string">"\tprototype: aggregation\n\t argument: %s\n"</literal></expr></argument>,
<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>,
<argument><expr><call><name>dt_node_type_name</name><argument_list>(<argument><expr><name>anp</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>normal</name> <operator>=</operator> <name><name>anp</name><operator>-&gt;</operator><name>dn_list</name></name><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>dt_node_is_scalar</name><argument_list>(<argument><expr><name>normal</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_NORMALIZE_SCALAR</name></expr></argument>,
<argument><expr><literal type="string">"%s( ) argument #2 must be of scalar type\n"</literal></expr></argument>,
<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>aid</name> <operator>=</operator> <name><name>anp</name><operator>-&gt;</operator><name>dn_ident</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>aid</name><operator>-&gt;</operator><name>di_gen</name></name> <operator>==</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_gen</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>aid</name><operator>-&gt;</operator><name>di_flags</name></name> <operator>&amp;</operator> <name>DT_IDFLG_MOD</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_NORMALIZE_AGGBAD</name></expr></argument>,
<argument><expr><literal type="string">"undefined aggregation: @%s\n"</literal></expr></argument>, <argument><expr><name><name>aid</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ap</name> <operator>=</operator> <call><name>dt_stmt_action</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_action_difconst</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name><name>anp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_id</name></name></expr></argument>, <argument><expr><name>DTRACEACT_LIBACT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>denormal</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_arg</name></name> <operator>=</operator> <name>DT_ACT_DENORMALIZE</name></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_arg</name></name> <operator>=</operator> <name>DT_ACT_NORMALIZE</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>normal</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ap</name> <operator>=</operator> <call><name>dt_stmt_action</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_cg</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>, <argument><expr><name>normal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_difo</name></name> <operator>=</operator> <call><name>dt_as</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_kind</name></name> <operator>=</operator> <name>DTRACEACT_LIBACT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_arg</name></name> <operator>=</operator> <name>DT_ACT_NORMALIZE</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_action_trunc</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>dtrace_stmtdesc_t</name> <modifier>*</modifier></type><name>sdp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_ident_t</name> <modifier>*</modifier></type><name>aid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_actdesc_t</name> <modifier>*</modifier></type><name>ap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>anp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>trunc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>n</name><index>[<expr><name>DT_TYPE_NAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>argc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>anp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name></name></expr>;</init> <condition><expr><name>anp</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>anp</name> <operator>=</operator> <name><name>anp</name><operator>-&gt;</operator><name>dn_list</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>argc</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">2</literal> <operator>||</operator> <name>argc</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_TRUNC_PROTO</name></expr></argument>,
<argument><expr><literal type="string">"%s( ) prototype mismatch: %d args passed, %s expected\n"</literal></expr></argument>,
<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>, <argument><expr><name>argc</name></expr></argument>,
<argument><expr><ternary><condition><expr><name>argc</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="string">"at least 1"</literal></expr> </then><else>: <expr><literal type="string">"no more than 2"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>anp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>anp</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>trunc</name> <operator>=</operator> <name><name>anp</name><operator>-&gt;</operator><name>dn_list</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>anp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>!=</operator> <name>DT_NODE_AGG</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_TRUNC_AGGARG</name></expr></argument>,
<argument><expr><literal type="string">"%s( ) argument #1 is incompatible with prototype:\n"</literal>
<literal type="string">"\tprototype: aggregation\n\t argument: %s\n"</literal></expr></argument>,
<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>,
<argument><expr><call><name>dt_node_type_name</name><argument_list>(<argument><expr><name>anp</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>trunc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dt_node_is_scalar</name><argument_list>(<argument><expr><name>trunc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_TRUNC_SCALAR</name></expr></argument>,
<argument><expr><literal type="string">"%s( ) argument #2 must be of scalar type\n"</literal></expr></argument>,
<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>aid</name> <operator>=</operator> <name><name>anp</name><operator>-&gt;</operator><name>dn_ident</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>aid</name><operator>-&gt;</operator><name>di_gen</name></name> <operator>==</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_gen</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>aid</name><operator>-&gt;</operator><name>di_flags</name></name> <operator>&amp;</operator> <name>DT_IDFLG_MOD</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_TRUNC_AGGBAD</name></expr></argument>,
<argument><expr><literal type="string">"undefined aggregation: @%s\n"</literal></expr></argument>, <argument><expr><name><name>aid</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ap</name> <operator>=</operator> <call><name>dt_stmt_action</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_action_difconst</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name><name>anp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_id</name></name></expr></argument>, <argument><expr><name>DTRACEACT_LIBACT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_arg</name></name> <operator>=</operator> <name>DT_ACT_TRUNC</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ap</name> <operator>=</operator> <call><name>dt_stmt_action</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_action_difconst</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>DTRACEACT_LIBACT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>trunc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_cg</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>, <argument><expr><name>trunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_difo</name></name> <operator>=</operator> <call><name>dt_as</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_kind</name></name> <operator>=</operator> <name>DTRACEACT_LIBACT</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_arg</name></name> <operator>=</operator> <name>DT_ACT_TRUNC</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_action_printa</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>dtrace_stmtdesc_t</name> <modifier>*</modifier></type><name>sdp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_ident_t</name> <modifier>*</modifier></type><name>aid</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>fid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_actdesc_t</name> <modifier>*</modifier></type><name>ap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>anp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>proto</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>n</name><index>[<expr><name>DT_TYPE_NAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>argc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>argr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>anp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name></name></expr>;</init> <condition><expr><name>anp</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>anp</name> <operator>=</operator> <name><name>anp</name><operator>-&gt;</operator><name>dn_list</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>argc</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>

<switch>switch <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name><operator>-&gt;</operator><name>dn_kind</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DT_NODE_STRING</name></expr>:</case>
<expr_stmt><expr><name>format</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name><operator>-&gt;</operator><name>dn_string</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>anp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name><operator>-&gt;</operator><name>dn_list</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>argr</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_AGG</name></expr>:</case>
<expr_stmt><expr><name>format</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>anp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>argr</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><name>format</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>anp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>argr</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&lt;</operator> <name>argr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_PRINTA_PROTO</name></expr></argument>,
<argument><expr><literal type="string">"%s( ) prototype mismatch: %d args passed, %d expected\n"</literal></expr></argument>,
<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>anp</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>anp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>anp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>!=</operator> <name>DT_NODE_AGG</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_PRINTA_AGGARG</name></expr></argument>,
<argument><expr><literal type="string">"%s( ) argument #%d is incompatible with "</literal>
<literal type="string">"prototype:\n\tprototype: aggregation\n"</literal>
<literal type="string">"\t argument: %s\n"</literal></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>, <argument><expr><name>argr</name></expr></argument>,
<argument><expr><call><name>dt_node_type_name</name><argument_list>(<argument><expr><name>anp</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>aid</name> <operator>=</operator> <name><name>anp</name><operator>-&gt;</operator><name>dn_ident</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>fid</name> <operator>=</operator> <name><name>aid</name><operator>-&gt;</operator><name>di_iarg</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>aid</name><operator>-&gt;</operator><name>di_gen</name></name> <operator>==</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_gen</name></name> <operator>&amp;&amp;</operator>
<operator>!</operator><operator>(</operator><name><name>aid</name><operator>-&gt;</operator><name>di_flags</name></name> <operator>&amp;</operator> <name>DT_IDFLG_MOD</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_PRINTA_AGGBAD</name></expr></argument>,
<argument><expr><literal type="string">"undefined aggregation: @%s\n"</literal></expr></argument>, <argument><expr><name><name>aid</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><name>proto</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_printa_validate</name><argument_list>(<argument><expr><name>proto</name></expr></argument>, <argument><expr><name>anp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>proto</name> <operator>=</operator> <name>anp</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>format</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>yylineno</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_line</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sdp</name><operator>-&gt;</operator><name>dtsd_fmtdata</name></name> <operator>=</operator>
<call><name>dt_printf_create</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_printf_validate</name><argument_list>(<argument><expr><name><name>sdp</name><operator>-&gt;</operator><name>dtsd_fmtdata</name></name></expr></argument>,
<argument><expr><name>DT_PRINTF_AGGREGATION</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
<argument><expr><name><name>fid</name><operator>-&gt;</operator><name>di_id</name></name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>dt_idsig_t</name> <operator>*</operator><operator>)</operator><name><name>aid</name><operator>-&gt;</operator><name>di_data</name></name><operator>)</operator><operator>-&gt;</operator><name>dis_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>format</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ap</name> <operator>=</operator> <call><name>dt_stmt_action</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_action_difconst</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name><name>anp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_id</name></name></expr></argument>, <argument><expr><name>DTRACEACT_PRINTA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>anp</name> <operator>=</operator> <name><name>anp</name><operator>-&gt;</operator><name>dn_list</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>argr</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_action_printflike</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>dtrace_stmtdesc_t</name> <modifier>*</modifier></type><name>sdp</name></decl></parameter>,
<parameter><decl><type><name>dtrace_actkind_t</name></type> <name>kind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>anp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>arg1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_actdesc_t</name> <modifier>*</modifier></type><name>ap</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>n</name><index>[<expr><name>DT_TYPE_NAMELEN</name></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>DTRACEACT_ISPRINTFLIKE</name><argument_list>(<argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>!=</operator> <name>DT_NODE_STRING</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_PRINTF_ARG_FMT</name></expr></argument>,
<argument><expr><literal type="string">"%s( ) argument #1 is incompatible with prototype:\n"</literal>
<literal type="string">"\tprototype: string constant\n\t argument: %s\n"</literal></expr></argument>,
<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>,
<argument><expr><call><name>dt_node_type_name</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>arg1</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name><operator>-&gt;</operator><name>dn_list</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>yylineno</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_line</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>str</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name><operator>-&gt;</operator><name>dn_string</name></name></expr>;</expr_stmt>












<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>==</operator> <name>DTRACEACT_FREOPEN</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>DT_FREOPEN_RESTORE</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>






<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_FREOPEN_INVALID</name></expr></argument>,
<argument><expr><literal type="string">"%s( ) argument #1 cannot be \"%s\"\n"</literal></expr></argument>,
<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>, <argument><expr><name>DT_FREOPEN_RESTORE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>str</name> <operator>=</operator> <name>DT_FREOPEN_RESTORE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>sdp</name><operator>-&gt;</operator><name>dtsd_fmtdata</name></name> <operator>=</operator> <call><name>dt_printf_create</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>dt_printf_validate</name><argument_list>(<argument><expr><name><name>sdp</name><operator>-&gt;</operator><name>dtsd_fmtdata</name></name></expr></argument>, <argument><expr><name>DT_PRINTF_EXACTLEN</name></expr></argument>,
<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>DTRACEACT_AGGREGATION</name></expr></argument>, <argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>arg1</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>dif_instr_t</name> <modifier>*</modifier></type><name>dbuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_difo_t</name> <modifier>*</modifier></type><name>dp</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>dbuf</name> <operator>=</operator> <call><name>dt_alloc</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>dif_instr_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator>
<operator>(</operator><name>dp</name> <operator>=</operator> <call><name>dt_zalloc</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>dtrace_difo_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_free</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>dbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_NOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>dbuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>DIF_INSTR_RET</name><argument_list>(<argument><expr><name>DIF_REG_R0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>dp</name><operator>-&gt;</operator><name>dtdo_buf</name></name> <operator>=</operator> <name>dbuf</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dp</name><operator>-&gt;</operator><name>dtdo_len</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dp</name><operator>-&gt;</operator><name>dtdo_rtype</name></name> <operator>=</operator> <name>dt_int_rtype</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ap</name> <operator>=</operator> <call><name>dt_stmt_action</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_difo</name></name> <operator>=</operator> <name>dp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_kind</name></name> <operator>=</operator> <name>kind</name></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>anp</name> <operator>=</operator> <name>arg1</name></expr>;</init> <condition><expr><name>anp</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>anp</name> <operator>=</operator> <name><name>anp</name><operator>-&gt;</operator><name>dn_list</name></name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>ap</name> <operator>=</operator> <call><name>dt_stmt_action</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_cg</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>, <argument><expr><name>anp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_difo</name></name> <operator>=</operator> <call><name>dt_as</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_kind</name></name> <operator>=</operator> <name>kind</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_action_trace</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>dtrace_stmtdesc_t</name> <modifier>*</modifier></type><name>sdp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ctflib</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>dtrace_actdesc_t</name> <modifier>*</modifier></type><name>ap</name> <init>= <expr><call><name>dt_stmt_action</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>boolean_t</name></type> <name>istrace</name> <init>= <expr><operator>(</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_id</name></name> <operator>==</operator> <name>DT_ACT_TRACE</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>act</name> <init>= <expr><ternary><condition><expr><name>istrace</name></expr> ?</condition><then> <expr><literal type="string">"trace"</literal></expr> </then><else>: <expr><literal type="string">"print"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dt_node_is_void</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name>istrace</name></expr> ?</condition><then> <expr><name>D_TRACE_VOID</name></expr> </then><else>: <expr><name>D_PRINT_VOID</name></expr></else></ternary></expr></argument>,
<argument><expr><literal type="string">"%s( ) may not be applied to a void expression\n"</literal></expr></argument>, <argument><expr><name>act</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dt_node_resolve</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name></name></expr></argument>, <argument><expr><name>DT_IDENT_XLPTR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name>istrace</name></expr> ?</condition><then> <expr><name>D_TRACE_DYN</name></expr> </then><else>: <expr><name>D_PRINT_DYN</name></expr></else></ternary></expr></argument>,
<argument><expr><literal type="string">"%s( ) may not be applied to a translated pointer\n"</literal></expr></argument>, <argument><expr><name>act</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_AGG</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name>istrace</name></expr> ?</condition><then> <expr><name>D_TRACE_AGG</name></expr> </then><else>: <expr><name>D_PRINT_AGG</name></expr></else></ternary></expr></argument>,
<argument><expr><literal type="string">"%s( ) may not be applied to an aggregation%s\n"</literal></expr></argument>, <argument><expr><name>act</name></expr></argument>,
<argument><expr><ternary><condition><expr><name>istrace</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">" -- did you mean printa()?"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>dt_cg</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>















<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_id</name></name> <operator>==</operator> <name>DT_ACT_PRINT</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_module_t</name> <modifier>*</modifier></type><name>dmp</name></decl>;</decl_stmt>

<expr_stmt><expr><name>dret</name> <operator>=</operator> <name><name>yypcb</name><operator>-&gt;</operator><name>pcb_dret</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>dmp</name> <operator>=</operator> <call><name>dt_module_lookup_by_ctf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>dret</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"%s`%ld"</literal></expr></argument>, <argument><expr><name><name>dmp</name><operator>-&gt;</operator><name>dm_name</name></name></expr></argument>, <argument><expr><name><name>dret</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dmp</name><operator>-&gt;</operator><name>dm_pid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ctflib</name> <operator>=</operator> <call><name>dt_module_getlibid</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>dmp</name></expr></argument>, <argument><expr><name><name>dret</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ctflib</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"%s`%d`%ld"</literal></expr></argument>, <argument><expr><name><name>dmp</name><operator>-&gt;</operator><name>dm_name</name></name></expr></argument>,
<argument><expr><name>ctflib</name></expr></argument>, <argument><expr><name><name>dret</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"%s`%ld"</literal></expr></argument>, <argument><expr><name><name>dmp</name><operator>-&gt;</operator><name>dm_name</name></name></expr></argument>,
<argument><expr><name><name>dret</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>sdp</name><operator>-&gt;</operator><name>dtsd_strdata</name></name> <operator>=</operator> <call><name>dt_alloc</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sdp</name><operator>-&gt;</operator><name>dtsd_strdata</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_NOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name><name>sdp</name><operator>-&gt;</operator><name>dtsd_strdata</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="string">"%s`%ld"</literal></expr></argument>, <argument><expr><name><name>dmp</name><operator>-&gt;</operator><name>dm_name</name></name></expr></argument>,
<argument><expr><name><name>dret</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dmp</name><operator>-&gt;</operator><name>dm_pid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name><name>sdp</name><operator>-&gt;</operator><name>dtsd_strdata</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="string">"%s`%d`%ld"</literal></expr></argument>,
<argument><expr><name><name>dmp</name><operator>-&gt;</operator><name>dm_name</name></name></expr></argument>, <argument><expr><name>ctflib</name></expr></argument>, <argument><expr><name><name>dret</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name><name>sdp</name><operator>-&gt;</operator><name>dtsd_strdata</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="string">"%s`%ld"</literal></expr></argument>,
<argument><expr><name><name>dmp</name><operator>-&gt;</operator><name>dm_name</name></name></expr></argument>, <argument><expr><name><name>dret</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_difo</name></name> <operator>=</operator> <call><name>dt_as</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_kind</name></name> <operator>=</operator> <name>DTRACEACT_DIFEXPR</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_action_tracemem</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>dtrace_stmtdesc_t</name> <modifier>*</modifier></type><name>sdp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_actdesc_t</name> <modifier>*</modifier></type><name>ap</name> <init>= <expr><call><name>dt_stmt_action</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>addr</name> <init>= <expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>max</name> <init>= <expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name><operator>-&gt;</operator><name>dn_list</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>n</name><index>[<expr><name>DT_TYPE_NAMELEN</name></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dt_node_is_integer</name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>dt_node_is_pointer</name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>D_TRACEMEM_ADDR</name></expr></argument>,
<argument><expr><literal type="string">"tracemem( ) argument #1 is incompatible with "</literal>
<literal type="string">"prototype:\n\tprototype: pointer or integer\n"</literal>
<literal type="string">"\t argument: %s\n"</literal></expr></argument>,
<argument><expr><call><name>dt_node_type_name</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dt_node_is_posconst</name><argument_list>(<argument><expr><name>max</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>max</name></expr></argument>, <argument><expr><name>D_TRACEMEM_SIZE</name></expr></argument>, <argument><expr><literal type="string">"tracemem( ) argument #2 must "</literal>
<literal type="string">"be a non-zero positive integral constant expression\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>size</name> <operator>=</operator> <name><name>max</name><operator>-&gt;</operator><name>dn_list</name></name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>size</name><operator>-&gt;</operator><name>dn_list</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>D_TRACEMEM_ARGS</name></expr></argument>, <argument><expr><literal type="string">"tracemem ( ) prototype "</literal>
<literal type="string">"mismatch: expected at most 3 args\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dt_node_is_scalar</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>D_TRACEMEM_DYNSIZE</name></expr></argument>, <argument><expr><literal type="string">"tracemem ( ) "</literal>
<literal type="string">"dynamic size (argument #3) must be of "</literal>
<literal type="string">"scalar type\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>dt_cg</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_difo</name></name> <operator>=</operator> <call><name>dt_as</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_difo</name><operator>-&gt;</operator><name>dtdo_rtype</name></name> <operator>=</operator> <name>dt_int_rtype</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_kind</name></name> <operator>=</operator> <name>DTRACEACT_TRACEMEM_DYNSIZE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ap</name> <operator>=</operator> <call><name>dt_stmt_action</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>dt_cg</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_difo</name></name> <operator>=</operator> <call><name>dt_as</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_kind</name></name> <operator>=</operator> <name>DTRACEACT_TRACEMEM</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_difo</name><operator>-&gt;</operator><name>dtdo_rtype</name><operator>.</operator><name>dtdt_flags</name></name> <operator>|=</operator> <name>DIF_TF_BYREF</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_difo</name><operator>-&gt;</operator><name>dtdo_rtype</name><operator>.</operator><name>dtdt_size</name></name> <operator>=</operator> <name><name>max</name><operator>-&gt;</operator><name>dn_value</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_action_stack_args</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>dtrace_actdesc_t</name> <modifier>*</modifier></type><name>ap</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>arg0</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_kind</name></name> <operator>=</operator> <name>DTRACEACT_STACK</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_options</name><index>[<expr><name>DTRACEOPT_STACKFRAMES</name></expr>]</index></name> <operator>!=</operator> <name>DTRACEOPT_UNSET</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_arg</name></name> <operator>=</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_options</name><index>[<expr><name>DTRACEOPT_STACKFRAMES</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_arg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>arg0</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>arg0</name><operator>-&gt;</operator><name>dn_list</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>arg0</name></expr></argument>, <argument><expr><name>D_STACK_PROTO</name></expr></argument>, <argument><expr><literal type="string">"stack( ) prototype "</literal>
<literal type="string">"mismatch: too many arguments\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dt_node_is_posconst</name><argument_list>(<argument><expr><name>arg0</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>arg0</name></expr></argument>, <argument><expr><name>D_STACK_SIZE</name></expr></argument>, <argument><expr><literal type="string">"stack( ) size must be a "</literal>
<literal type="string">"non-zero positive integral constant expression\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_arg</name></name> <operator>=</operator> <name><name>arg0</name><operator>-&gt;</operator><name>dn_value</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_action_stack</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>dtrace_stmtdesc_t</name> <modifier>*</modifier></type><name>sdp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_actdesc_t</name> <modifier>*</modifier></type><name>ap</name> <init>= <expr><call><name>dt_stmt_action</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>dt_action_stack_args</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_action_ustack_args</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>dtrace_actdesc_t</name> <modifier>*</modifier></type><name>ap</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>nframes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>strsize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>arg0</name> <init>= <expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>arg1</name> <init>= <expr><ternary><condition><expr><name>arg0</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name><name>arg0</name><operator>-&gt;</operator><name>dn_list</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_id</name></name> <operator>==</operator> <name>DT_ACT_JSTACK</name> <operator>||</operator>
<name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_id</name></name> <operator>==</operator> <name>DT_ACT_USTACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_id</name></name> <operator>==</operator> <name>DT_ACT_JSTACK</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_options</name><index>[<expr><name>DTRACEOPT_JSTACKFRAMES</name></expr>]</index></name> <operator>!=</operator> <name>DTRACEOPT_UNSET</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>nframes</name> <operator>=</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_options</name><index>[<expr><name>DTRACEOPT_JSTACKFRAMES</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_options</name><index>[<expr><name>DTRACEOPT_JSTACKSTRSIZE</name></expr>]</index></name> <operator>!=</operator> <name>DTRACEOPT_UNSET</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>strsize</name> <operator>=</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_options</name><index>[<expr><name>DTRACEOPT_JSTACKSTRSIZE</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_kind</name></name> <operator>=</operator> <name>DTRACEACT_JSTACK</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_id</name></name> <operator>==</operator> <name>DT_ACT_USTACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_options</name><index>[<expr><name>DTRACEOPT_USTACKFRAMES</name></expr>]</index></name> <operator>!=</operator> <name>DTRACEOPT_UNSET</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>nframes</name> <operator>=</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_options</name><index>[<expr><name>DTRACEOPT_USTACKFRAMES</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_kind</name></name> <operator>=</operator> <name>DTRACEACT_USTACK</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>arg0</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dt_node_is_posconst</name><argument_list>(<argument><expr><name>arg0</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>arg0</name></expr></argument>, <argument><expr><name>D_USTACK_FRAMES</name></expr></argument>, <argument><expr><literal type="string">"ustack( ) argument #1 "</literal>
<literal type="string">"must be a non-zero positive integer constant\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>nframes</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>arg0</name><operator>-&gt;</operator><name>dn_value</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>arg1</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>arg1</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>!=</operator> <name>DT_NODE_INT</name> <operator>||</operator>
<operator>(</operator><operator>(</operator><name><name>arg1</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_SIGNED</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name>int64_t</name><operator>)</operator><name><name>arg1</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>D_USTACK_STRSIZE</name></expr></argument>, <argument><expr><literal type="string">"ustack( ) argument #2 "</literal>
<literal type="string">"must be a positive integer constant\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>arg1</name><operator>-&gt;</operator><name>dn_list</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>D_USTACK_PROTO</name></expr></argument>, <argument><expr><literal type="string">"ustack( ) prototype "</literal>
<literal type="string">"mismatch: too many arguments\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>strsize</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>arg1</name><operator>-&gt;</operator><name>dn_value</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_arg</name></name> <operator>=</operator> <call><name>DTRACE_USTACK_ARG</name><argument_list>(<argument><expr><name>nframes</name></expr></argument>, <argument><expr><name>strsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_action_ustack</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>dtrace_stmtdesc_t</name> <modifier>*</modifier></type><name>sdp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_actdesc_t</name> <modifier>*</modifier></type><name>ap</name> <init>= <expr><call><name>dt_stmt_action</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>dt_action_ustack_args</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>, <argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_action_setopt</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>dtrace_stmtdesc_t</name> <modifier>*</modifier></type><name>sdp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_actdesc_t</name> <modifier>*</modifier></type><name>ap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>arg0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>arg1</name></decl>;</decl_stmt>





<expr_stmt><expr><name>arg0</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>arg1</name> <operator>=</operator> <name><name>arg0</name><operator>-&gt;</operator><name>dn_list</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>ap</name> <operator>=</operator> <call><name>dt_stmt_action</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_cg</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>, <argument><expr><name>arg0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_difo</name></name> <operator>=</operator> <call><name>dt_as</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_kind</name></name> <operator>=</operator> <name>DTRACEACT_LIBACT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_arg</name></name> <operator>=</operator> <name>DT_ACT_SETOPT</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ap</name> <operator>=</operator> <call><name>dt_stmt_action</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>arg1</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_action_difconst</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>DTRACEACT_LIBACT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>dt_cg</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>, <argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_difo</name></name> <operator>=</operator> <call><name>dt_as</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_kind</name></name> <operator>=</operator> <name>DTRACEACT_LIBACT</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_arg</name></name> <operator>=</operator> <name>DT_ACT_SETOPT</name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_action_symmod_args</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>dtrace_actdesc_t</name> <modifier>*</modifier></type><name>ap</name></decl></parameter>,
<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>dtrace_actkind_t</name></type> <name>kind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>kind</name> <operator>==</operator> <name>DTRACEACT_SYM</name> <operator>||</operator> <name>kind</name> <operator>==</operator> <name>DTRACEACT_MOD</name> <operator>||</operator>
<name>kind</name> <operator>==</operator> <name>DTRACEACT_USYM</name> <operator>||</operator> <name>kind</name> <operator>==</operator> <name>DTRACEACT_UMOD</name> <operator>||</operator>
<name>kind</name> <operator>==</operator> <name>DTRACEACT_UADDR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>dt_cg</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>, <argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_difo</name></name> <operator>=</operator> <call><name>dt_as</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_kind</name></name> <operator>=</operator> <name>kind</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_difo</name><operator>-&gt;</operator><name>dtdo_rtype</name><operator>.</operator><name>dtdt_size</name></name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_action_symmod</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>dtrace_stmtdesc_t</name> <modifier>*</modifier></type><name>sdp</name></decl></parameter>,
<parameter><decl><type><name>dtrace_actkind_t</name></type> <name>kind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_actdesc_t</name> <modifier>*</modifier></type><name>ap</name> <init>= <expr><call><name>dt_stmt_action</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>dt_action_symmod_args</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name></name></expr></argument>, <argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_action_ftruncate</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>dtrace_stmtdesc_t</name> <modifier>*</modifier></type><name>sdp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_actdesc_t</name> <modifier>*</modifier></type><name>ap</name> <init>= <expr><call><name>dt_stmt_action</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>







<expr_stmt><expr><call><name>dt_action_difconst</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>DTRACEACT_LIBACT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_arg</name></name> <operator>=</operator> <name>DT_ACT_FTRUNCATE</name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_action_stop</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>dtrace_stmtdesc_t</name> <modifier>*</modifier></type><name>sdp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_actdesc_t</name> <modifier>*</modifier></type><name>ap</name> <init>= <expr><call><name>dt_stmt_action</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_kind</name></name> <operator>=</operator> <name>DTRACEACT_STOP</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_arg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_action_breakpoint</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>dtrace_stmtdesc_t</name> <modifier>*</modifier></type><name>sdp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_actdesc_t</name> <modifier>*</modifier></type><name>ap</name> <init>= <expr><call><name>dt_stmt_action</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_kind</name></name> <operator>=</operator> <name>DTRACEACT_BREAKPOINT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_arg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_action_panic</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>dtrace_stmtdesc_t</name> <modifier>*</modifier></type><name>sdp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_actdesc_t</name> <modifier>*</modifier></type><name>ap</name> <init>= <expr><call><name>dt_stmt_action</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_kind</name></name> <operator>=</operator> <name>DTRACEACT_PANIC</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_arg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_action_chill</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>dtrace_stmtdesc_t</name> <modifier>*</modifier></type><name>sdp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_actdesc_t</name> <modifier>*</modifier></type><name>ap</name> <init>= <expr><call><name>dt_stmt_action</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>dt_cg</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_difo</name></name> <operator>=</operator> <call><name>dt_as</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_kind</name></name> <operator>=</operator> <name>DTRACEACT_CHILL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_action_raise</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>dtrace_stmtdesc_t</name> <modifier>*</modifier></type><name>sdp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_actdesc_t</name> <modifier>*</modifier></type><name>ap</name> <init>= <expr><call><name>dt_stmt_action</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>dt_cg</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_difo</name></name> <operator>=</operator> <call><name>dt_as</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_kind</name></name> <operator>=</operator> <name>DTRACEACT_RAISE</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_action_exit</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>dtrace_stmtdesc_t</name> <modifier>*</modifier></type><name>sdp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_actdesc_t</name> <modifier>*</modifier></type><name>ap</name> <init>= <expr><call><name>dt_stmt_action</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>dt_cg</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_difo</name></name> <operator>=</operator> <call><name>dt_as</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_kind</name></name> <operator>=</operator> <name>DTRACEACT_EXIT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_difo</name><operator>-&gt;</operator><name>dtdo_rtype</name><operator>.</operator><name>dtdt_size</name></name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_action_speculate</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>dtrace_stmtdesc_t</name> <modifier>*</modifier></type><name>sdp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_actdesc_t</name> <modifier>*</modifier></type><name>ap</name> <init>= <expr><call><name>dt_stmt_action</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>dt_cg</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_difo</name></name> <operator>=</operator> <call><name>dt_as</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_kind</name></name> <operator>=</operator> <name>DTRACEACT_SPECULATE</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_action_printm</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>dtrace_stmtdesc_t</name> <modifier>*</modifier></type><name>sdp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_actdesc_t</name> <modifier>*</modifier></type><name>ap</name> <init>= <expr><call><name>dt_stmt_action</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>size</name> <init>= <expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>addr</name> <init>= <expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name><operator>-&gt;</operator><name>dn_list</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>n</name><index>[<expr><name>DT_TYPE_NAMELEN</name></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dt_node_is_posconst</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>D_PRINTM_SIZE</name></expr></argument>, <argument><expr><literal type="string">"printm( ) argument #1 must "</literal>
<literal type="string">"be a non-zero positive integral constant expression\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dt_node_is_pointer</name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>D_PRINTM_ADDR</name></expr></argument>,
<argument><expr><literal type="string">"printm( ) argument #2 is incompatible with "</literal>
<literal type="string">"prototype:\n\tprototype: pointer\n"</literal>
<literal type="string">"\t argument: %s\n"</literal></expr></argument>,
<argument><expr><call><name>dt_node_type_name</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>dt_cg</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_difo</name></name> <operator>=</operator> <call><name>dt_as</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_kind</name></name> <operator>=</operator> <name>DTRACEACT_PRINTM</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_difo</name><operator>-&gt;</operator><name>dtdo_rtype</name><operator>.</operator><name>dtdt_flags</name></name> <operator>|=</operator> <name>DIF_TF_BYREF</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_difo</name><operator>-&gt;</operator><name>dtdo_rtype</name><operator>.</operator><name>dtdt_size</name></name> <operator>=</operator> <name><name>size</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uintptr_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_action_commit</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>dtrace_stmtdesc_t</name> <modifier>*</modifier></type><name>sdp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_actdesc_t</name> <modifier>*</modifier></type><name>ap</name> <init>= <expr><call><name>dt_stmt_action</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>dt_cg</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_difo</name></name> <operator>=</operator> <call><name>dt_as</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_kind</name></name> <operator>=</operator> <name>DTRACEACT_COMMIT</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_action_discard</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>dtrace_stmtdesc_t</name> <modifier>*</modifier></type><name>sdp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_actdesc_t</name> <modifier>*</modifier></type><name>ap</name> <init>= <expr><call><name>dt_stmt_action</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>dt_cg</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_difo</name></name> <operator>=</operator> <call><name>dt_as</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_kind</name></name> <operator>=</operator> <name>DTRACEACT_DISCARD</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_compile_fun</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>dtrace_stmtdesc_t</name> <modifier>*</modifier></type><name>sdp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_id</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DT_ACT_BREAKPOINT</name></expr>:</case>
<expr_stmt><expr><call><name>dt_action_breakpoint</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_ACT_CHILL</name></expr>:</case>
<expr_stmt><expr><call><name>dt_action_chill</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_ACT_CLEAR</name></expr>:</case>
<expr_stmt><expr><call><name>dt_action_clear</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_ACT_COMMIT</name></expr>:</case>
<expr_stmt><expr><call><name>dt_action_commit</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_ACT_DENORMALIZE</name></expr>:</case>
<expr_stmt><expr><call><name>dt_action_normalize</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_ACT_DISCARD</name></expr>:</case>
<expr_stmt><expr><call><name>dt_action_discard</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_ACT_EXIT</name></expr>:</case>
<expr_stmt><expr><call><name>dt_action_exit</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_ACT_FREOPEN</name></expr>:</case>
<expr_stmt><expr><call><name>dt_action_printflike</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>, <argument><expr><name>DTRACEACT_FREOPEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_ACT_FTRUNCATE</name></expr>:</case>
<expr_stmt><expr><call><name>dt_action_ftruncate</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_ACT_MOD</name></expr>:</case>
<expr_stmt><expr><call><name>dt_action_symmod</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>, <argument><expr><name>DTRACEACT_MOD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_ACT_NORMALIZE</name></expr>:</case>
<expr_stmt><expr><call><name>dt_action_normalize</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_ACT_PANIC</name></expr>:</case>
<expr_stmt><expr><call><name>dt_action_panic</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_ACT_PRINT</name></expr>:</case>
<expr_stmt><expr><call><name>dt_action_trace</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_ACT_PRINTA</name></expr>:</case>
<expr_stmt><expr><call><name>dt_action_printa</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_ACT_PRINTF</name></expr>:</case>
<expr_stmt><expr><call><name>dt_action_printflike</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>, <argument><expr><name>DTRACEACT_PRINTF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_ACT_PRINTM</name></expr>:</case>
<expr_stmt><expr><call><name>dt_action_printm</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_ACT_RAISE</name></expr>:</case>
<expr_stmt><expr><call><name>dt_action_raise</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_ACT_SETOPT</name></expr>:</case>
<expr_stmt><expr><call><name>dt_action_setopt</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_ACT_SPECULATE</name></expr>:</case>
<expr_stmt><expr><call><name>dt_action_speculate</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_ACT_STACK</name></expr>:</case>
<expr_stmt><expr><call><name>dt_action_stack</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_ACT_STOP</name></expr>:</case>
<expr_stmt><expr><call><name>dt_action_stop</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_ACT_SYM</name></expr>:</case>
<expr_stmt><expr><call><name>dt_action_symmod</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>, <argument><expr><name>DTRACEACT_SYM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_ACT_SYSTEM</name></expr>:</case>
<expr_stmt><expr><call><name>dt_action_printflike</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>, <argument><expr><name>DTRACEACT_SYSTEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_ACT_TRACE</name></expr>:</case>
<expr_stmt><expr><call><name>dt_action_trace</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_ACT_TRACEMEM</name></expr>:</case>
<expr_stmt><expr><call><name>dt_action_tracemem</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_ACT_TRUNC</name></expr>:</case>
<expr_stmt><expr><call><name>dt_action_trunc</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_ACT_UADDR</name></expr>:</case>
<expr_stmt><expr><call><name>dt_action_symmod</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>, <argument><expr><name>DTRACEACT_UADDR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_ACT_UMOD</name></expr>:</case>
<expr_stmt><expr><call><name>dt_action_symmod</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>, <argument><expr><name>DTRACEACT_UMOD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_ACT_USYM</name></expr>:</case>
<expr_stmt><expr><call><name>dt_action_symmod</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>, <argument><expr><name>DTRACEACT_USYM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_ACT_USTACK</name></expr>:</case>
<case>case <expr><name>DT_ACT_JSTACK</name></expr>:</case>
<expr_stmt><expr><call><name>dt_action_ustack</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name></expr></argument>, <argument><expr><name>D_UNKNOWN</name></expr></argument>, <argument><expr><literal type="string">"tracing function %s( ) is "</literal>
<literal type="string">"not yet supported\n"</literal></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_compile_exp</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>dtrace_stmtdesc_t</name> <modifier>*</modifier></type><name>sdp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_actdesc_t</name> <modifier>*</modifier></type><name>ap</name> <init>= <expr><call><name>dt_stmt_action</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>dt_cg</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_difo</name></name> <operator>=</operator> <call><name>dt_as</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_difo</name><operator>-&gt;</operator><name>dtdo_rtype</name></name> <operator>=</operator> <name>dt_void_rtype</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_kind</name></name> <operator>=</operator> <name>DTRACEACT_DIFEXPR</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_compile_agg</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>dtrace_stmtdesc_t</name> <modifier>*</modifier></type><name>sdp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_ident_t</name> <modifier>*</modifier></type><name>aid</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>fid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>anp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>incr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_actdesc_t</name> <modifier>*</modifier></type><name>ap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint_t</name></type> <name>n</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>argmax</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>arg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_aggfun</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_AGG_NULL</name></expr></argument>, <argument><expr><literal type="string">"expression has null effect: @%s\n"</literal></expr></argument>,
<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>aid</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>fid</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_aggfun</name><operator>-&gt;</operator><name>dn_ident</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_aggfun</name><operator>-&gt;</operator><name>dn_args</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
<call><name>dt_node_is_scalar</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_aggfun</name><operator>-&gt;</operator><name>dn_args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_aggfun</name></name></expr></argument>, <argument><expr><name>D_AGG_SCALAR</name></expr></argument>, <argument><expr><literal type="string">"%s( ) argument #1 must "</literal>
<literal type="string">"be of scalar type\n"</literal></expr></argument>, <argument><expr><name><name>fid</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>





<expr_stmt><expr><name>ap</name> <operator>=</operator> <call><name>dt_stmt_action</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_action_difconst</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name><name>aid</name><operator>-&gt;</operator><name>di_id</name></name></expr></argument>, <argument><expr><name>DTRACEACT_DIFEXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>anp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_aggtup</name></name></expr>;</init> <condition><expr><name>anp</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>anp</name> <operator>=</operator> <name><name>anp</name><operator>-&gt;</operator><name>dn_list</name></name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>ap</name> <operator>=</operator> <call><name>dt_stmt_action</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>anp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_FUNC</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>anp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_id</name></name> <operator>==</operator> <name>DT_ACT_STACK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_action_stack_args</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>, <argument><expr><name><name>anp</name><operator>-&gt;</operator><name>dn_args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>anp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_id</name></name> <operator>==</operator> <name>DT_ACT_USTACK</name> <operator>||</operator>
<name><name>anp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_id</name></name> <operator>==</operator> <name>DT_ACT_JSTACK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_action_ustack_args</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>, <argument><expr><name>anp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>anp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_id</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DT_ACT_UADDR</name></expr>:</case>
<expr_stmt><expr><call><name>dt_action_symmod_args</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>,
<argument><expr><name><name>anp</name><operator>-&gt;</operator><name>dn_args</name></name></expr></argument>, <argument><expr><name>DTRACEACT_UADDR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>

<case>case <expr><name>DT_ACT_USYM</name></expr>:</case>
<expr_stmt><expr><call><name>dt_action_symmod_args</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>,
<argument><expr><name><name>anp</name><operator>-&gt;</operator><name>dn_args</name></name></expr></argument>, <argument><expr><name>DTRACEACT_USYM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>

<case>case <expr><name>DT_ACT_UMOD</name></expr>:</case>
<expr_stmt><expr><call><name>dt_action_symmod_args</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>,
<argument><expr><name><name>anp</name><operator>-&gt;</operator><name>dn_args</name></name></expr></argument>, <argument><expr><name>DTRACEACT_UMOD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>

<case>case <expr><name>DT_ACT_SYM</name></expr>:</case>
<expr_stmt><expr><call><name>dt_action_symmod_args</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>,
<argument><expr><name><name>anp</name><operator>-&gt;</operator><name>dn_args</name></name></expr></argument>, <argument><expr><name>DTRACEACT_SYM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>

<case>case <expr><name>DT_ACT_MOD</name></expr>:</case>
<expr_stmt><expr><call><name>dt_action_symmod_args</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>,
<argument><expr><name><name>anp</name><operator>-&gt;</operator><name>dn_args</name></name></expr></argument>, <argument><expr><name>DTRACEACT_MOD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>

<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>dt_cg</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>, <argument><expr><name>anp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_difo</name></name> <operator>=</operator> <call><name>dt_as</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_kind</name></name> <operator>=</operator> <name>DTRACEACT_DIFEXPR</name></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>fid</name><operator>-&gt;</operator><name>di_id</name></name> <operator>==</operator> <name>DTRACEAGG_LQUANTIZE</name></expr>)</condition> <block>{<block_content>









<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>arg1</name> <init>= <expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_aggfun</name><operator>-&gt;</operator><name>dn_args</name><operator>-&gt;</operator><name>dn_list</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>arg2</name> <init>= <expr><name><name>arg1</name><operator>-&gt;</operator><name>dn_list</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>arg3</name> <init>= <expr><name><name>arg2</name><operator>-&gt;</operator><name>dn_list</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_idsig_t</name> <modifier>*</modifier></type><name>isp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>nlevels</name></decl>, <decl><type ref="prev"/><name>step</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>oarg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>baseval</name></decl>, <decl><type ref="prev"/><name>limitval</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>arg1</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>!=</operator> <name>DT_NODE_INT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>D_LQUANT_BASETYPE</name></expr></argument>, <argument><expr><literal type="string">"lquantize( ) "</literal>
<literal type="string">"argument #1 must be an integer constant\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>baseval</name> <operator>=</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><name><name>arg1</name><operator>-&gt;</operator><name>dn_value</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>baseval</name> <argument_list type="generic">&lt; <argument><expr><name>INT32_MIN</name> <operator>||</operator> <name>baseval</name></expr></argument> &gt;</argument_list></name> <name>INT32_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>D_LQUANT_BASEVAL</name></expr></argument>, <argument><expr><literal type="string">"lquantize( ) "</literal>
<literal type="string">"argument #1 must be a 32-bit quantity\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>arg2</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>!=</operator> <name>DT_NODE_INT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><name>D_LQUANT_LIMTYPE</name></expr></argument>, <argument><expr><literal type="string">"lquantize( ) "</literal>
<literal type="string">"argument #2 must be an integer constant\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>limitval</name> <operator>=</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><name><name>arg2</name><operator>-&gt;</operator><name>dn_value</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>limitval</name> <argument_list type="generic">&lt; <argument><expr><name>INT32_MIN</name> <operator>||</operator> <name>limitval</name></expr></argument> &gt;</argument_list></name> <name>INT32_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><name>D_LQUANT_LIMVAL</name></expr></argument>, <argument><expr><literal type="string">"lquantize( ) "</literal>
<literal type="string">"argument #2 must be a 32-bit quantity\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>limitval</name> <operator>&lt;</operator> <name>baseval</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_LQUANT_MISMATCH</name></expr></argument>,
<argument><expr><literal type="string">"lquantize( ) base (argument #1) must be less "</literal>
<literal type="string">"than limit (argument #2)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>arg3</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dt_node_is_posconst</name><argument_list>(<argument><expr><name>arg3</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>arg3</name></expr></argument>, <argument><expr><name>D_LQUANT_STEPTYPE</name></expr></argument>, <argument><expr><literal type="string">"lquantize( ) "</literal>
<literal type="string">"argument #3 must be a non-zero positive "</literal>
<literal type="string">"integer constant\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>step</name> <operator>=</operator> <name><name>arg3</name><operator>-&gt;</operator><name>dn_value</name></name><operator>)</operator> <operator>&gt;</operator> <name>UINT16_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>arg3</name></expr></argument>, <argument><expr><name>D_LQUANT_STEPVAL</name></expr></argument>, <argument><expr><literal type="string">"lquantize( ) "</literal>
<literal type="string">"argument #3 must be a 16-bit quantity\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>nlevels</name> <operator>=</operator> <operator>(</operator><name>limitval</name> <operator>-</operator> <name>baseval</name><operator>)</operator> <operator>/</operator> <name>step</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>nlevels</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_LQUANT_STEPLARGE</name></expr></argument>,
<argument><expr><literal type="string">"lquantize( ) step (argument #3) too large: must "</literal>
<literal type="string">"have at least one quantization level\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>nlevels</name> <operator>&gt;</operator> <name>UINT16_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_LQUANT_STEPSMALL</name></expr></argument>, <argument><expr><literal type="string">"lquantize( ) step "</literal>
<literal type="string">"(argument #3) too small: number of quantization "</literal>
<literal type="string">"levels must be a 16-bit quantity\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <operator>(</operator><name>step</name> <operator>&lt;&lt;</operator> <name>DTRACE_LQUANTIZE_STEPSHIFT</name><operator>)</operator> <operator>|</operator>
<operator>(</operator><name>nlevels</name> <operator>&lt;&lt;</operator> <name>DTRACE_LQUANTIZE_LEVELSHIFT</name><operator>)</operator> <operator>|</operator>
<operator>(</operator><operator>(</operator><name>baseval</name> <operator>&lt;&lt;</operator> <name>DTRACE_LQUANTIZE_BASESHIFT</name><operator>)</operator> <operator>&amp;</operator>
<name>DTRACE_LQUANTIZE_BASEMASK</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>arg</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>isp</name> <operator>=</operator> <operator>(</operator><name>dt_idsig_t</name> <operator>*</operator><operator>)</operator><name><name>aid</name><operator>-&gt;</operator><name>di_data</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>isp</name><operator>-&gt;</operator><name>dis_auxinfo</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>





<expr_stmt><expr><name><name>isp</name><operator>-&gt;</operator><name>dis_auxinfo</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>oarg</name> <operator>=</operator> <name><name>isp</name><operator>-&gt;</operator><name>dis_auxinfo</name></name><operator>)</operator> <operator>!=</operator> <name>arg</name></expr>)</condition> <block>{<block_content>






<decl_stmt><decl><type><name>int</name></type> <name>obaseval</name> <init>= <expr><call><name>DTRACE_LQUANTIZE_BASE</name><argument_list>(<argument><expr><name>oarg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>onlevels</name> <init>= <expr><call><name>DTRACE_LQUANTIZE_LEVELS</name><argument_list>(<argument><expr><name>oarg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ostep</name> <init>= <expr><call><name>DTRACE_LQUANTIZE_STEP</name><argument_list>(<argument><expr><name>oarg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>obaseval</name> <operator>!=</operator> <name>baseval</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_LQUANT_MATCHBASE</name></expr></argument>, <argument><expr><literal type="string">"lquantize( ) "</literal>
<literal type="string">"base (argument #1) doesn't match previous "</literal>
<literal type="string">"declaration: expected %d, found %d\n"</literal></expr></argument>,
<argument><expr><name>obaseval</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>baseval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>onlevels</name> <operator>*</operator> <name>ostep</name> <operator>!=</operator> <name>nlevels</name> <operator>*</operator> <name>step</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_LQUANT_MATCHLIM</name></expr></argument>, <argument><expr><literal type="string">"lquantize( ) "</literal>
<literal type="string">"limit (argument #2) doesn't match previous"</literal>
<literal type="string">" declaration: expected %d, found %d\n"</literal></expr></argument>,
<argument><expr><name>obaseval</name> <operator>+</operator> <name>onlevels</name> <operator>*</operator> <name>ostep</name></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>baseval</name> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator><name>nlevels</name> <operator>*</operator> <operator>(</operator><name>int</name><operator>)</operator><name>step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ostep</name> <operator>!=</operator> <name>step</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_LQUANT_MATCHSTEP</name></expr></argument>, <argument><expr><literal type="string">"lquantize( ) "</literal>
<literal type="string">"step (argument #3) doesn't match previous "</literal>
<literal type="string">"declaration: expected %d, found %d\n"</literal></expr></argument>,
<argument><expr><name>ostep</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>






<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>incr</name> <operator>=</operator> <ternary><condition><expr><name>arg3</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name><name>arg3</name><operator>-&gt;</operator><name>dn_list</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>argmax</name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fid</name><operator>-&gt;</operator><name>di_id</name></name> <operator>==</operator> <name>DTRACEAGG_LLQUANTIZE</name></expr>)</condition> <block>{<block_content>










<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>llarg</name> <init>= <expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_aggfun</name><operator>-&gt;</operator><name>dn_args</name><operator>-&gt;</operator><name>dn_list</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>oarg</name></decl>, <decl><type ref="prev"/><name>order</name></decl>, <decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_idsig_t</name> <modifier>*</modifier></type><name>isp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<struct>struct <block>{
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>badtype</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>badval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mismatch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>shift</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint16_t</name></type> <name>value</name></decl>;</decl_stmt>
}</block> <decl><name><name>args</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><literal type="string">"factor"</literal></expr>, <expr><name>D_LLQUANT_FACTORTYPE</name></expr>,
<expr><name>D_LLQUANT_FACTORVAL</name></expr>, <expr><name>D_LLQUANT_FACTORMATCH</name></expr>,
<expr><name>DTRACE_LLQUANTIZE_FACTORSHIFT</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"low magnitude"</literal></expr>, <expr><name>D_LLQUANT_LOWTYPE</name></expr>,
<expr><name>D_LLQUANT_LOWVAL</name></expr>, <expr><name>D_LLQUANT_LOWMATCH</name></expr>,
<expr><name>DTRACE_LLQUANTIZE_LOWSHIFT</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"high magnitude"</literal></expr>, <expr><name>D_LLQUANT_HIGHTYPE</name></expr>,
<expr><name>D_LLQUANT_HIGHVAL</name></expr>, <expr><name>D_LLQUANT_HIGHMATCH</name></expr>,
<expr><name>DTRACE_LLQUANTIZE_HIGHSHIFT</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"linear steps per magnitude"</literal></expr>, <expr><name>D_LLQUANT_NSTEPTYPE</name></expr>,
<expr><name>D_LLQUANT_NSTEPVAL</name></expr>, <expr><name>D_LLQUANT_NSTEPMATCH</name></expr>,
<expr><name>DTRACE_LLQUANTIZE_NSTEPSHIFT</name></expr> }</block></expr>,
<expr><block>{ <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</struct>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>arg</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>str</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>llarg</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>!=</operator> <name>DT_NODE_INT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>llarg</name></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>badtype</name></expr></argument>, <argument><expr><literal type="string">"llquantize( ) "</literal>
<literal type="string">"argument #%d (%s) must be an "</literal>
<literal type="string">"integer constant\n"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>llarg</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>&gt;</operator> <name>UINT16_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>llarg</name></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>badval</name></expr></argument>, <argument><expr><literal type="string">"llquantize( ) "</literal>
<literal type="string">"argument #%d (%s) must be an unsigned "</literal>
<literal type="string">"16-bit quantity\n"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><name><name>llarg</name><operator>-&gt;</operator><name>dn_value</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>arg</name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><name>UINT16_MAX</name> <operator>&lt;&lt;</operator>
<name><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>shift</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>arg</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>&lt;&lt;</operator> <name><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>shift</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>llarg</name> <operator>=</operator> <name><name>llarg</name><operator>-&gt;</operator><name>dn_list</name></name></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>arg</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_LLQUANT_FACTORSMALL</name></expr></argument>, <argument><expr><literal type="string">"llquantize( ) "</literal>
<literal type="string">"factor (argument #1) must be two or more\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>&gt;=</operator> <name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>value</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_LLQUANT_MAGRANGE</name></expr></argument>, <argument><expr><literal type="string">"llquantize( ) "</literal>
<literal type="string">"high magnitude (argument #3) must be greater "</literal>
<literal type="string">"than low magnitude (argument #2)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>&lt;</operator> <name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>value</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_LLQUANT_FACTORNSTEPS</name></expr></argument>, <argument><expr><literal type="string">"llquantize( ) "</literal>
<literal type="string">"factor (argument #1) must be less than or "</literal>
<literal type="string">"equal to the number of linear steps per "</literal>
<literal type="string">"magnitude (argument #4)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>v</name> <operator>=</operator> <name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>value</name></expr>;</init> <condition><expr><name>v</name> <operator>&lt;</operator> <name><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>value</name></expr>;</condition> <incr><expr><name>v</name> <operator>*=</operator> <name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>value</name></expr></incr>)</control><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></for>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>%</operator> <name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>value</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>v</name> <operator>%</operator> <name><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>value</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_LLQUANT_FACTOREVEN</name></expr></argument>, <argument><expr><literal type="string">"llquantize( ) "</literal>
<literal type="string">"factor (argument #1) must evenly divide the "</literal>
<literal type="string">"number of steps per magnitude (argument #4), "</literal>
<literal type="string">"and the number of steps per magnitude must evenly "</literal>
<literal type="string">"divide a power of the factor\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>order</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>+</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>order</name> <operator>*</operator> <name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>&gt;</operator> <name>order</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>order</name> <operator>*=</operator> <name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>value</name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_LLQUANT_MAGTOOBIG</name></expr></argument>, <argument><expr><literal type="string">"llquantize( ) "</literal>
<literal type="string">"factor (%d) raised to power of high magnitude "</literal>
<literal type="string">"(%d) plus 1 overflows 64-bits\n"</literal></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>,
<argument><expr><name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>isp</name> <operator>=</operator> <operator>(</operator><name>dt_idsig_t</name> <operator>*</operator><operator>)</operator><name><name>aid</name><operator>-&gt;</operator><name>di_data</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>isp</name><operator>-&gt;</operator><name>dis_auxinfo</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>





<expr_stmt><expr><name><name>isp</name><operator>-&gt;</operator><name>dis_auxinfo</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>oarg</name> <operator>=</operator> <name><name>isp</name><operator>-&gt;</operator><name>dis_auxinfo</name></name><operator>)</operator> <operator>!=</operator> <name>arg</name></expr>)</condition> <block>{<block_content>






<decl_stmt><decl><type><name>int</name></type> <name>expected</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>found</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>expected</name> <operator>==</operator> <name>found</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>str</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>expected</name> <operator>=</operator> <operator>(</operator><name>oarg</name> <operator>&gt;&gt;</operator> <name><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>shift</name><operator>)</operator> <operator>&amp;</operator> <name>UINT16_MAX</name></expr>;</expr_stmt>
<expr_stmt><expr><name>found</name> <operator>=</operator> <operator>(</operator><name>arg</name> <operator>&gt;&gt;</operator> <name><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>shift</name><operator>)</operator> <operator>&amp;</operator> <name>UINT16_MAX</name></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>mismatch</name></expr></argument>, <argument><expr><literal type="string">"llquantize( ) "</literal>
<literal type="string">"%s (argument #%d) doesn't match previous "</literal>
<literal type="string">"declaration: expected %d, found %d\n"</literal></expr></argument>,
<argument><expr><name><name>args</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>str</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>, <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>incr</name> <operator>=</operator> <name>llarg</name></expr>;</expr_stmt>
<expr_stmt><expr><name>argmax</name> <operator>=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fid</name><operator>-&gt;</operator><name>di_id</name></name> <operator>==</operator> <name>DTRACEAGG_QUANTIZE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>incr</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_aggfun</name><operator>-&gt;</operator><name>dn_args</name><operator>-&gt;</operator><name>dn_list</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>argmax</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>incr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dt_node_is_scalar</name><argument_list>(<argument><expr><name>incr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_PROTO_ARG</name></expr></argument>, <argument><expr><literal type="string">"%s( ) increment value "</literal>
<literal type="string">"(argument #%d) must be of scalar type\n"</literal></expr></argument>,
<argument><expr><name><name>fid</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>, <argument><expr><name>argmax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>anp</name> <operator>=</operator> <name><name>incr</name><operator>-&gt;</operator><name>dn_list</name></name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>argc</name> <init>= <expr><name>argmax</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>anp</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>anp</name> <operator>=</operator> <name><name>anp</name><operator>-&gt;</operator><name>dn_list</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>argc</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>incr</name></expr></argument>, <argument><expr><name>D_PROTO_LEN</name></expr></argument>, <argument><expr><literal type="string">"%s( ) prototype "</literal>
<literal type="string">"mismatch: %d args passed, at most %d expected"</literal></expr></argument>,
<argument><expr><name><name>fid</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argmax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ap</name> <operator>=</operator> <call><name>dt_stmt_action</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>dt_cg</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>, <argument><expr><name>incr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_difo</name></name> <operator>=</operator> <call><name>dt_as</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_difo</name><operator>-&gt;</operator><name>dtdo_rtype</name></name> <operator>=</operator> <name>dt_void_rtype</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_kind</name></name> <operator>=</operator> <name>DTRACEACT_DIFEXPR</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>sdp</name><operator>-&gt;</operator><name>dtsd_aggdata</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sdp</name><operator>-&gt;</operator><name>dtsd_aggdata</name></name> <operator>=</operator> <name>aid</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ap</name> <operator>=</operator> <call><name>dt_stmt_action</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>fid</name><operator>-&gt;</operator><name>di_kind</name></name> <operator>==</operator> <name>DT_IDENT_AGGFUNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>DTRACEACT_ISAGG</name><argument_list>(<argument><expr><name><name>fid</name><operator>-&gt;</operator><name>di_id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_kind</name></name> <operator>=</operator> <name><name>fid</name><operator>-&gt;</operator><name>di_id</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_ntuple</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_arg</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_aggfun</name><operator>-&gt;</operator><name>dn_args</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_cg</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_aggfun</name><operator>-&gt;</operator><name>dn_args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>dtad_difo</name></name> <operator>=</operator> <call><name>dt_as</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_compile_one_clause</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>cnp</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>pnp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_ecbdesc_t</name> <modifier>*</modifier></type><name>edp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_stmtdesc_t</name> <modifier>*</modifier></type><name>sdp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl>;</decl_stmt>

<expr_stmt><expr><name>yylineno</name> <operator>=</operator> <name><name>pnp</name><operator>-&gt;</operator><name>dn_line</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_setcontext</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>pnp</name><operator>-&gt;</operator><name>dn_desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dt_node_cook</name><argument_list>(<argument><expr><name>cnp</name></expr></argument>, <argument><expr><name>DT_IDFLG_REF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>DT_TREEDUMP_PASS</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dt_node_printr</name><argument_list>(<argument><expr><name>cnp</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>edp</name> <operator>=</operator> <call><name>dt_ecbdesc_create</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>pnp</name><operator>-&gt;</operator><name>dn_desc</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_NOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_ecbdesc</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_ecbdesc</name></name> <operator>=</operator> <name>edp</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cnp</name><operator>-&gt;</operator><name>dn_pred</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_cg</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>, <argument><expr><name><name>cnp</name><operator>-&gt;</operator><name>dn_pred</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>edp</name><operator>-&gt;</operator><name>dted_pred</name><operator>.</operator><name>dtpdd_difo</name></name> <operator>=</operator> <call><name>dt_as</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cnp</name><operator>-&gt;</operator><name>dn_acts</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_stmt_append</name><argument_list>(<argument><expr><call><name>dt_stmt_create</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>edp</name></expr></argument>,
<argument><expr><name><name>cnp</name><operator>-&gt;</operator><name>dn_ctxattr</name></name></expr></argument>, <argument><expr><name>_dtrace_defattr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>dnp</name> <operator>=</operator> <name><name>cnp</name><operator>-&gt;</operator><name>dn_acts</name></name></expr>;</init> <condition><expr><name>dnp</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>dnp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_list</name></name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_stmt</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sdp</name> <operator>=</operator> <call><name>dt_stmt_create</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>edp</name></expr></argument>, <argument><expr><name><name>cnp</name><operator>-&gt;</operator><name>dn_ctxattr</name></name></expr></argument>, <argument><expr><name><name>cnp</name><operator>-&gt;</operator><name>dn_attr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_kind</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DT_NODE_DEXPR</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_AGG</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dt_compile_agg</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dt_compile_exp</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_DFUNC</name></expr>:</case>
<expr_stmt><expr><call><name>dt_compile_fun</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_AGG</name></expr>:</case>
<expr_stmt><expr><call><name>dt_compile_agg</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_UNKNOWN</name></expr></argument>, <argument><expr><literal type="string">"internal error -- node kind "</literal>
<literal type="string">"%u is not a valid statement\n"</literal></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_kind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_stmt</name></name> <operator>==</operator> <name>sdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_stmt_append</name><argument_list>(<argument><expr><name>sdp</name></expr></argument>, <argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_ecbdesc</name></name> <operator>==</operator> <name>edp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_ecbdesc_release</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>edp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_endcontext</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_ecbdesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_compile_clause</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>cnp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>pnp</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>pnp</name> <operator>=</operator> <name><name>cnp</name><operator>-&gt;</operator><name>dn_pdescs</name></name></expr>;</init> <condition><expr><name>pnp</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>pnp</name> <operator>=</operator> <name><name>pnp</name><operator>-&gt;</operator><name>dn_list</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dt_compile_one_clause</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>cnp</name></expr></argument>, <argument><expr><name>pnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_compile_xlator</name><parameter_list>(<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_xlator_t</name> <modifier>*</modifier></type><name>dxp</name> <init>= <expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_xlator</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>mnp</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>mnp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_members</name></name></expr>;</init> <condition><expr><name>mnp</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>mnp</name> <operator>=</operator> <name><name>mnp</name><operator>-&gt;</operator><name>dn_list</name></name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dxp</name><operator>-&gt;</operator><name>dx_membdif</name><index>[<expr><name><name>mnp</name><operator>-&gt;</operator><name>dn_membid</name></name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_cg</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>, <argument><expr><name>mnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dxp</name><operator>-&gt;</operator><name>dx_membdif</name><index>[<expr><name><name>mnp</name><operator>-&gt;</operator><name>dn_membid</name></name></expr>]</index></name> <operator>=</operator> <call><name>dt_as</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>dt_setcontext</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>dtrace_probedesc_t</name> <modifier>*</modifier></type><name>pdp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>dtrace_pattr_t</name> <modifier>*</modifier></type><name>pap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_probe_t</name> <modifier>*</modifier></type><name>prp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_provider_t</name> <modifier>*</modifier></type><name>pvp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_ident_t</name> <modifier>*</modifier></type><name>idp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>attrstr</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>prov_len</name></decl>;</decl_stmt>














<expr_stmt><expr><name>prov_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>pdp</name><operator>-&gt;</operator><name>dtpd_provider</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>prov_len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>isdigit</name><argument_list>(<argument><expr><name><name>pdp</name><operator>-&gt;</operator><name>dtpd_provider</name><index>[<expr><name>prov_len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><operator>(</operator><name>pvp</name> <operator>=</operator> <call><name>dt_provider_lookup</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>pdp</name><operator>-&gt;</operator><name>dtpd_provider</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator>
<name><name>pvp</name><operator>-&gt;</operator><name>pv_desc</name><operator>.</operator><name>dtvd_priv</name><operator>.</operator><name>dtpp_flags</name></name> <operator>&amp;</operator> <name>DTRACE_PRIV_PROC</name><operator>)</operator> <operator>&amp;&amp;</operator>
<call><name>dt_pid_create_probes</name><argument_list>(<argument><expr><name>pdp</name></expr></argument>, <argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>yypcb</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_COMPILER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>






<if_stmt><if>if <condition>(<expr><operator>(</operator><name>prp</name> <operator>=</operator> <call><name>dt_probe_info</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>pdp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_pinfo</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>pap</name> <operator>=</operator> <operator>&amp;</operator><name>_dtrace_prvdesc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>dtrace_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bzero</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_pinfo</name></name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>dtrace_probeinfo_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_pinfo</name><operator>.</operator><name>dtp_attr</name></name> <operator>=</operator> <name><name>pap</name><operator>-&gt;</operator><name>dtpa_provider</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_pinfo</name><operator>.</operator><name>dtp_arga</name></name> <operator>=</operator> <name><name>pap</name><operator>-&gt;</operator><name>dtpa_args</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>pap</name> <operator>=</operator> <operator>&amp;</operator><name><name>prp</name><operator>-&gt;</operator><name>pr_pvp</name><operator>-&gt;</operator><name>pv_desc</name><operator>.</operator><name>dtvd_attr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>err</name> <operator>==</operator> <name>EDT_NOPROBE</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_cflags</name></name> <operator>&amp;</operator> <name>DTRACE_C_ZDEFS</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_PDESC_ZERO</name></expr></argument>, <argument><expr><literal type="string">"probe description %s:%s:%s:%s does not "</literal>
<literal type="string">"match any probes\n"</literal></expr></argument>, <argument><expr><name><name>pdp</name><operator>-&gt;</operator><name>dtpd_provider</name></name></expr></argument>, <argument><expr><name><name>pdp</name><operator>-&gt;</operator><name>dtpd_mod</name></name></expr></argument>,
<argument><expr><name><name>pdp</name><operator>-&gt;</operator><name>dtpd_func</name></name></expr></argument>, <argument><expr><name><name>pdp</name><operator>-&gt;</operator><name>dtpd_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <name>EDT_NOPROBE</name> <operator>&amp;&amp;</operator> <name>err</name> <operator>!=</operator> <name>EDT_UNSTABLE</name> <operator>&amp;&amp;</operator> <name>err</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_PDESC_INVAL</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>dtrace_errmsg</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>dt_dprintf</name><argument_list>(<argument><expr><literal type="string">"set context to %s:%s:%s:%s [%u] prp=%p attr=%s argc=%d\n"</literal></expr></argument>,
<argument><expr><name><name>pdp</name><operator>-&gt;</operator><name>dtpd_provider</name></name></expr></argument>, <argument><expr><name><name>pdp</name><operator>-&gt;</operator><name>dtpd_mod</name></name></expr></argument>, <argument><expr><name><name>pdp</name><operator>-&gt;</operator><name>dtpd_func</name></name></expr></argument>, <argument><expr><name><name>pdp</name><operator>-&gt;</operator><name>dtpd_name</name></name></expr></argument>,
<argument><expr><name><name>pdp</name><operator>-&gt;</operator><name>dtpd_id</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>prp</name></expr></argument>, <argument><expr><call><name>dt_attr_str</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_pinfo</name><operator>.</operator><name>dtp_attr</name></name></expr></argument>,
<argument><expr><name>attrstr</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>attrstr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_pinfo</name><operator>.</operator><name>dtp_argc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<if_stmt><if>if <condition>(<expr><operator>(</operator><name>idp</name> <operator>=</operator> <call><name>dt_idhash_lookup</name><argument_list>(<argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_globals</name></name></expr></argument>, <argument><expr><literal type="string">"probeprov"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>idp</name><operator>-&gt;</operator><name>di_attr</name></name> <operator>=</operator> <name><name>pap</name><operator>-&gt;</operator><name>dtpa_provider</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>idp</name> <operator>=</operator> <call><name>dt_idhash_lookup</name><argument_list>(<argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_globals</name></name></expr></argument>, <argument><expr><literal type="string">"probemod"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>idp</name><operator>-&gt;</operator><name>di_attr</name></name> <operator>=</operator> <name><name>pap</name><operator>-&gt;</operator><name>dtpa_mod</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>idp</name> <operator>=</operator> <call><name>dt_idhash_lookup</name><argument_list>(<argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_globals</name></name></expr></argument>, <argument><expr><literal type="string">"probefunc"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>idp</name><operator>-&gt;</operator><name>di_attr</name></name> <operator>=</operator> <name><name>pap</name><operator>-&gt;</operator><name>dtpa_func</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>idp</name> <operator>=</operator> <call><name>dt_idhash_lookup</name><argument_list>(<argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_globals</name></name></expr></argument>, <argument><expr><literal type="string">"probename"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>idp</name><operator>-&gt;</operator><name>di_attr</name></name> <operator>=</operator> <name><name>pap</name><operator>-&gt;</operator><name>dtpa_name</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>idp</name> <operator>=</operator> <call><name>dt_idhash_lookup</name><argument_list>(<argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_globals</name></name></expr></argument>, <argument><expr><literal type="string">"args"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>idp</name><operator>-&gt;</operator><name>di_attr</name></name> <operator>=</operator> <name><name>pap</name><operator>-&gt;</operator><name>dtpa_args</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_pdesc</name></name> <operator>=</operator> <name>pdp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_probe</name></name> <operator>=</operator> <name>prp</name></expr>;</expr_stmt>
</block_content>}</block></function>






<function><type><name>void</name></type>
<name>dt_endcontext</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>cvars</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"probeprov"</literal></expr>, <expr><literal type="string">"probemod"</literal></expr>, <expr><literal type="string">"probefunc"</literal></expr>, <expr><literal type="string">"probename"</literal></expr>, <expr><literal type="string">"args"</literal></expr>, <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>dt_ident_t</name> <modifier>*</modifier></type><name>idp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>cvars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>idp</name> <operator>=</operator> <call><name>dt_idhash_lookup</name><argument_list>(<argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_globals</name></name></expr></argument>, <argument><expr><name><name>cvars</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>idp</name><operator>-&gt;</operator><name>di_attr</name></name> <operator>=</operator> <name>_dtrace_defattr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_pdesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_probe</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_reduceid</name><parameter_list>(<parameter><decl><type><name>dt_idhash_t</name> <modifier>*</modifier></type><name>dhp</name></decl></parameter>, <parameter><decl><type><name>dt_ident_t</name> <modifier>*</modifier></type><name>idp</name></decl></parameter>, <parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>idp</name><operator>-&gt;</operator><name>di_vers</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>idp</name><operator>-&gt;</operator><name>di_vers</name></name> <operator>&gt;</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_vmax</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dt_idhash_delete</name><argument_list>(<argument><expr><name>dhp</name></expr></argument>, <argument><expr><name>idp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>










<function><type><name>int</name></type>
<name>dt_reduce</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>dt_version_t</name></type> <name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>s</name><index>[<expr><name>DT_VERSION_STRMAX</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_xlator_t</name> <modifier>*</modifier></type><name>dxp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>nxp</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>v</name> <operator>&gt;</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_vmax</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>EDT_VERSREDUCED</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>v</name> <operator>==</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_vmax</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>dt_dprintf</name><argument_list>(<argument><expr><literal type="string">"reducing api version to %s\n"</literal></expr></argument>,
<argument><expr><call><name>dt_version_num2str</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_vmax</name></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>dxp</name> <operator>=</operator> <call><name>dt_list_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtp</name><operator>-&gt;</operator><name>dt_xlators</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>dxp</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>dxp</name> <operator>=</operator> <name>nxp</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>nxp</name> <operator>=</operator> <call><name>dt_list_next</name><argument_list>(<argument><expr><name>dxp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dxp</name><operator>-&gt;</operator><name>dx_souid</name><operator>.</operator><name>di_vers</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>dxp</name><operator>-&gt;</operator><name>dx_souid</name><operator>.</operator><name>di_vers</name></name> <operator>&gt;</operator> <name>v</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><name><name>dxp</name><operator>-&gt;</operator><name>dx_ptrid</name><operator>.</operator><name>di_vers</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>dxp</name><operator>-&gt;</operator><name>dx_ptrid</name><operator>.</operator><name>di_vers</name></name> <operator>&gt;</operator> <name>v</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dt_list_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtp</name><operator>-&gt;</operator><name>dt_xlators</name></name></expr></argument>, <argument><expr><name>dxp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dt_idhash_iter</name><argument_list>(<argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_macros</name></name></expr></argument>, <argument><expr><operator>(</operator><name>dt_idhash_f</name> <operator>*</operator><operator>)</operator><name>dt_reduceid</name></expr></argument>, <argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dt_idhash_iter</name><argument_list>(<argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_aggs</name></name></expr></argument>, <argument><expr><operator>(</operator><name>dt_idhash_f</name> <operator>*</operator><operator>)</operator><name>dt_reduceid</name></expr></argument>, <argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dt_idhash_iter</name><argument_list>(<argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_globals</name></name></expr></argument>, <argument><expr><operator>(</operator><name>dt_idhash_f</name> <operator>*</operator><operator>)</operator><name>dt_reduceid</name></expr></argument>, <argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dt_idhash_iter</name><argument_list>(<argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_tls</name></name></expr></argument>, <argument><expr><operator>(</operator><name>dt_idhash_f</name> <operator>*</operator><operator>)</operator><name>dt_reduceid</name></expr></argument>, <argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type>
<name>dt_preproc</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>ifp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>argc</name> <init>= <expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_cpp_argc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name> <init>= <expr><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>argc</name> <operator>+</operator> <literal type="number">5</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>ofp</name> <init>= <expr><call><name>tmpfile</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>illumos</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char</name></type> <name><name>ipath</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>opath</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>char</name></type> <name><name>verdef</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>sigaction</name></name></type> <name>act</name></decl>, <decl><type ref="prev"/><name>oact</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sigset_t</name></type> <name>mask</name></decl>, <decl><type ref="prev"/><name>omask</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>wstat</name></decl>, <decl><type ref="prev"/><name>estat</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>illumos</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>off64_t</name></type> <name>off</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>off_t</name></type> <name>off</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>argv</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>ofp</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></if></if_stmt>







<if_stmt><if>if <condition>(<expr><call><name>isatty</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>ifp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>off</name> <operator>=</operator> <call><name>ftello64</name><argument_list>(<argument><expr><name>ifp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>fgetc</name><argument_list>(<argument><expr><name>ifp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="char">'#'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>c</name> <operator>=</operator> <call><name>fgetc</name><argument_list>(<argument><expr><name>ifp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="char">'!'</literal></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>off</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>c</name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>;</condition> <incr><expr><name>off</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>fgetc</name><argument_list>(<argument><expr><name>ifp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>off</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fflush</name><argument_list>(<argument><expr><name>ifp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fseeko64</name><argument_list>(<argument><expr><name>ifp</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>illumos</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>ipath</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>ipath</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"/dev/fd/%d"</literal></expr></argument>, <argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>ifp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>opath</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>opath</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"/dev/fd/%d"</literal></expr></argument>, <argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>ofp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>bcopy</name><argument_list>(<argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_cpp_argv</name></name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>verdef</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>verdef</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"-D__SUNW_D_VERSION=0x%08x"</literal></expr></argument>, <argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_vmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>argv</name><index>[<expr><name>argc</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>verdef</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>illumos</name></expr></argument>)</argument_list></call></expr></cpp:if>
<switch>switch <condition>(<expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_stdcmode</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DT_STDC_XA</name></expr>:</case>
<case>case <expr><name>DT_STDC_XT</name></expr>:</case>
<expr_stmt><expr><name><name>argv</name><index>[<expr><name>argc</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="string">"-D__STDC__=0"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_STDC_XC</name></expr>:</case>
<expr_stmt><expr><name><name>argv</name><index>[<expr><name>argc</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="string">"-D__STDC__=1"</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>

<expr_stmt><expr><name><name>argv</name><index>[<expr><name>argc</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>ipath</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>argv</name><index>[<expr><name>argc</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>opath</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name><name>argv</name><index>[<expr><name>argc</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="string">"-P"</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>argv</name><index>[<expr><name>argc</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>









<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sigemptyset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sigaddset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mask</name></expr></argument>, <argument><expr><name>SIGCHLD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sigprocmask</name><argument_list>(<argument><expr><name>SIG_BLOCK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mask</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>omask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bzero</name><argument_list>(<argument><expr><operator>&amp;</operator><name>act</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>act</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>act</name><operator>.</operator><name>sa_handler</name></name> <operator>=</operator> <name>SIG_DFL</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sigaction</name><argument_list>(<argument><expr><name>SIGCHLD</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>act</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>pid</name> <operator>=</operator> <call><name>fork1</name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sigaction</name><argument_list>(<argument><expr><name>SIGCHLD</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oact</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sigprocmask</name><argument_list>(<argument><expr><name>SIG_SETMASK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>omask</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>EDT_CPPFORK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>illumos</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>isatty</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>ifp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>lseek</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>ifp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>dup2</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>ifp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dup2</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>ofp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>execvp</name><argument_list>(<argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_cpp_path</name></name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>_exit</name><argument_list>(<argument><expr><ternary><condition><expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr> ?</condition><then> <expr><literal type="number">127</literal></expr> </then><else>: <expr><literal type="number">126</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<do>do <block>{<block_content>
<expr_stmt><expr><call><name>dt_dprintf</name><argument_list>(<argument><expr><literal type="string">"waiting for %s (PID %d)\n"</literal></expr></argument>, <argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_cpp_path</name></name></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><call><name>waitpid</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wstat</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition>;</do>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sigaction</name><argument_list>(<argument><expr><name>SIGCHLD</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oact</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sigprocmask</name><argument_list>(<argument><expr><name>SIG_SETMASK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>omask</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>dt_dprintf</name><argument_list>(<argument><expr><literal type="string">"%s returned exit status 0x%x\n"</literal></expr></argument>, <argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_cpp_path</name></name></expr></argument>, <argument><expr><name>wstat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>estat</name> <operator>=</operator> <ternary><condition><expr><call><name>WIFEXITED</name><argument_list>(<argument><expr><name>wstat</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>WEXITSTATUS</name><argument_list>(<argument><expr><name>wstat</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>estat</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name>estat</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">126</literal></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>EDT_CPPEXEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">127</literal></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>EDT_CPPENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>EDT_CPPERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fflush</name><argument_list>(<argument><expr><name>ofp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fseek</name><argument_list>(<argument><expr><name>ofp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ofp</name><operator>)</operator></expr>;</return>

<label><name>err</name>:</label>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fclose</name><argument_list>(<argument><expr><name>ofp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_lib_depend_error</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_set_errmsg</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>dt_lib_depend_add</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>dt_list_t</name> <modifier>*</modifier></type><name>dlp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_lib_depend_t</name> <modifier>*</modifier></type><name>dld</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>arg</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>end</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>dld</name> <operator>=</operator> <call><name>dt_zalloc</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>dt_lib_depend_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dld</name><operator>-&gt;</operator><name>dtld_libpath</name></name> <operator>=</operator> <call><name>dt_alloc</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_free</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>dld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>strlcpy</name><argument_list>(<argument><expr><name><name>dld</name><operator>-&gt;</operator><name>dtld_libpath</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>end</name> <operator>-</operator> <name>arg</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dld</name><operator>-&gt;</operator><name>dtld_library</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_free</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>dld</name><operator>-&gt;</operator><name>dtld_libpath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_free</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>dld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>EDT_NOMEM</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>dt_list_append</name><argument_list>(<argument><expr><name>dlp</name></expr></argument>, <argument><expr><name>dld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>dt_lib_depend_t</name> <modifier>*</modifier></type>
<name>dt_lib_depend_lookup</name><parameter_list>(<parameter><decl><type><name>dt_list_t</name> <modifier>*</modifier></type><name>dld</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_lib_depend_t</name> <modifier>*</modifier></type><name>dldn</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>dldn</name> <operator>=</operator> <call><name>dt_list_next</name><argument_list>(<argument><expr><name>dld</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>dldn</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
<incr><expr><name>dldn</name> <operator>=</operator> <call><name>dt_list_next</name><argument_list>(<argument><expr><name>dldn</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>dldn</name><operator>-&gt;</operator><name>dtld_library</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>dldn</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_lib_build_graph</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_lib_depend_t</name> <modifier>*</modifier></type><name>dld</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dpld</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>dld</name> <operator>=</operator> <call><name>dt_list_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtp</name><operator>-&gt;</operator><name>dt_lib_dep</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>dld</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
<incr><expr><name>dld</name> <operator>=</operator> <call><name>dt_list_next</name><argument_list>(<argument><expr><name>dld</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>library</name> <init>= <expr><name><name>dld</name><operator>-&gt;</operator><name>dtld_library</name></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>dpld</name> <operator>=</operator> <call><name>dt_list_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dld</name><operator>-&gt;</operator><name>dtld_dependencies</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>dpld</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
<incr><expr><name>dpld</name> <operator>=</operator> <call><name>dt_list_next</name><argument_list>(<argument><expr><name>dpld</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>dt_lib_depend_t</name> <modifier>*</modifier></type><name>dlda</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>dlda</name> <operator>=</operator> <call><name>dt_lib_depend_lookup</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtp</name><operator>-&gt;</operator><name>dt_lib_dep</name></name></expr></argument>,
<argument><expr><name><name>dpld</name><operator>-&gt;</operator><name>dtld_library</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_lib_depend_error</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>,
<argument><expr><literal type="string">"Invalid library dependency in %s: %s\n"</literal></expr></argument>,
<argument><expr><name><name>dld</name><operator>-&gt;</operator><name>dtld_library</name></name></expr></argument>, <argument><expr><name><name>dpld</name><operator>-&gt;</operator><name>dtld_library</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>EDT_COMPILER</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>dt_lib_depend_add</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dlda</name><operator>-&gt;</operator><name>dtld_dependents</name></name></expr></argument>,
<argument><expr><name>library</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_topo_sort</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>dt_lib_depend_t</name> <modifier>*</modifier></type><name>dld</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_lib_depend_t</name> <modifier>*</modifier></type><name>dpld</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dlda</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>new</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>dld</name><operator>-&gt;</operator><name>dtld_start</name></name> <operator>=</operator> <operator>++</operator><operator>(</operator><operator>*</operator><name>count</name><operator>)</operator></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>dpld</name> <operator>=</operator> <call><name>dt_list_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dld</name><operator>-&gt;</operator><name>dtld_dependents</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>dpld</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
<incr><expr><name>dpld</name> <operator>=</operator> <call><name>dt_list_next</name><argument_list>(<argument><expr><name>dpld</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>dlda</name> <operator>=</operator> <call><name>dt_lib_depend_lookup</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtp</name><operator>-&gt;</operator><name>dt_lib_dep</name></name></expr></argument>,
<argument><expr><name><name>dpld</name><operator>-&gt;</operator><name>dtld_library</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dlda</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dlda</name><operator>-&gt;</operator><name>dtld_start</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<call><name>dt_topo_sort</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>dlda</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>new</name> <operator>=</operator> <call><name>dt_zalloc</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>dt_lib_depend_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>new</name><operator>-&gt;</operator><name>dtld_library</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name><name>dld</name><operator>-&gt;</operator><name>dtld_library</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_free</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>EDT_NOMEM</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>dtld_start</name></name> <operator>=</operator> <name><name>dld</name><operator>-&gt;</operator><name>dtld_start</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>dtld_finish</name></name> <operator>=</operator> <name><name>dld</name><operator>-&gt;</operator><name>dtld_finish</name></name> <operator>=</operator> <operator>++</operator><operator>(</operator><operator>*</operator><name>count</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_list_prepend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtp</name><operator>-&gt;</operator><name>dt_lib_dep_sorted</name></name></expr></argument>, <argument><expr><name>new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>dt_dprintf</name><argument_list>(<argument><expr><literal type="string">"library %s sorted (%d/%d)\n"</literal></expr></argument>, <argument><expr><name><name>new</name><operator>-&gt;</operator><name>dtld_library</name></name></expr></argument>,
<argument><expr><name><name>new</name><operator>-&gt;</operator><name>dtld_start</name></name></expr></argument>, <argument><expr><name><name>new</name><operator>-&gt;</operator><name>dtld_finish</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_lib_depend_sort</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_lib_depend_t</name> <modifier>*</modifier></type><name>dld</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dpld</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dlda</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dt_lib_build_graph</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>






<for>for <control>(<init><expr><name>dld</name> <operator>=</operator> <call><name>dt_list_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtp</name><operator>-&gt;</operator><name>dt_lib_dep</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>dld</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
<incr><expr><name>dld</name> <operator>=</operator> <call><name>dt_list_next</name><argument_list>(<argument><expr><name>dld</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>dld</name><operator>-&gt;</operator><name>dtld_start</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<call><name>dt_topo_sort</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>dld</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>count</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt> <empty_stmt>;</empty_stmt>
</block_content>}</block></for>






<for>for <control>(<init><expr><name>dld</name> <operator>=</operator> <call><name>dt_list_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtp</name><operator>-&gt;</operator><name>dt_lib_dep</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>dld</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
<incr><expr><name>dld</name> <operator>=</operator> <call><name>dt_list_next</name><argument_list>(<argument><expr><name>dld</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>dpld</name> <operator>=</operator> <call><name>dt_list_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dld</name><operator>-&gt;</operator><name>dtld_dependents</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>dpld</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
<incr><expr><name>dpld</name> <operator>=</operator> <call><name>dt_list_next</name><argument_list>(<argument><expr><name>dpld</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>dlda</name> <operator>=</operator> <call><name>dt_lib_depend_lookup</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtp</name><operator>-&gt;</operator><name>dt_lib_dep_sorted</name></name></expr></argument>,
<argument><expr><name><name>dpld</name><operator>-&gt;</operator><name>dtld_library</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dlda</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dlda</name><operator>-&gt;</operator><name>dtld_finish</name></name> <operator>&gt;</operator> <name><name>dld</name><operator>-&gt;</operator><name>dtld_finish</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_lib_depend_error</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>,
<argument><expr><literal type="string">"Cyclic dependency detected: %s =&gt; %s\n"</literal></expr></argument>,
<argument><expr><name><name>dld</name><operator>-&gt;</operator><name>dtld_library</name></name></expr></argument>, <argument><expr><name><name>dpld</name><operator>-&gt;</operator><name>dtld_library</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>EDT_COMPILER</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_lib_depend_free</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_lib_depend_t</name> <modifier>*</modifier></type><name>dld</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dlda</name></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>(</operator><name>dld</name> <operator>=</operator> <call><name>dt_list_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtp</name><operator>-&gt;</operator><name>dt_lib_dep</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><operator>(</operator><name>dlda</name> <operator>=</operator> <call><name>dt_list_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dld</name><operator>-&gt;</operator><name>dtld_dependencies</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_list_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dld</name><operator>-&gt;</operator><name>dtld_dependencies</name></name></expr></argument>, <argument><expr><name>dlda</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_free</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>dlda</name><operator>-&gt;</operator><name>dtld_library</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_free</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>dlda</name><operator>-&gt;</operator><name>dtld_libpath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_free</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>dlda</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<while>while <condition>(<expr><operator>(</operator><name>dlda</name> <operator>=</operator> <call><name>dt_list_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dld</name><operator>-&gt;</operator><name>dtld_dependents</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_list_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dld</name><operator>-&gt;</operator><name>dtld_dependents</name></name></expr></argument>, <argument><expr><name>dlda</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_free</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>dlda</name><operator>-&gt;</operator><name>dtld_library</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_free</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>dlda</name><operator>-&gt;</operator><name>dtld_libpath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_free</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>dlda</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>dt_list_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtp</name><operator>-&gt;</operator><name>dt_lib_dep</name></name></expr></argument>, <argument><expr><name>dld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_free</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>dld</name><operator>-&gt;</operator><name>dtld_library</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_free</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>dld</name><operator>-&gt;</operator><name>dtld_libpath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_free</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>dld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>

<while>while <condition>(<expr><operator>(</operator><name>dld</name> <operator>=</operator> <call><name>dt_list_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtp</name><operator>-&gt;</operator><name>dt_lib_dep_sorted</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_list_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtp</name><operator>-&gt;</operator><name>dt_lib_dep_sorted</name></name></expr></argument>, <argument><expr><name>dld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_free</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>dld</name><operator>-&gt;</operator><name>dtld_library</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_free</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>dld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_load_libs_dir</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>dp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DIR</name> <modifier>*</modifier></type><name>dirp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>fname</name><index>[<expr><name>PATH_MAX</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>rv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_lib_depend_t</name> <modifier>*</modifier></type><name>dld</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>dirp</name> <operator>=</operator> <call><name>opendir</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_dprintf</name><argument_list>(<argument><expr><literal type="string">"skipping lib dir %s: %s\n"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>


<while>while <condition>(<expr><operator>(</operator><name>dp</name> <operator>=</operator> <call><name>readdir</name><argument_list>(<argument><expr><name>dirp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name><name>dp</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">".d"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>dp</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fp</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_dprintf</name><argument_list>(<argument><expr><literal type="string">"skipping library %s: %s\n"</literal></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>




<for>for <control>(<init><expr><name>dld</name> <operator>=</operator> <call><name>dt_list_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtp</name><operator>-&gt;</operator><name>dt_lib_dep</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>dld</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
<incr><expr><name>dld</name> <operator>=</operator> <call><name>dt_list_next</name><argument_list>(<argument><expr><name>dld</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name><name>dld</name><operator>-&gt;</operator><name>dtld_library</name></name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>end</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>end</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>dp</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>dld</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_dprintf</name><argument_list>(<argument><expr><literal type="string">"skipping library %s, already processed "</literal>
<literal type="string">"library with the same name: %s"</literal></expr></argument>, <argument><expr><name><name>dp</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>,
<argument><expr><name><name>dld</name><operator>-&gt;</operator><name>dtld_library</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_filetag</name></name> <operator>=</operator> <name>fname</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_lib_depend_add</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dtp</name><operator>-&gt;</operator><name>dt_lib_dep</name></name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>dt_compile</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>DT_CTX_DPROG</name></expr></argument>,
<argument><expr><name>DTRACE_PROBESPEC_NAME</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>DTRACE_C_EMPTY</name> <operator>|</operator> <name>DTRACE_C_CTL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_errno</name></name> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>dtp</name><operator>-&gt;</operator><name>dt_errno</name></name> <operator>!=</operator> <name>EDT_COMPILER</name> <operator>||</operator>
<name><name>dtp</name><operator>-&gt;</operator><name>dt_errtag</name></name> <operator>!=</operator> <call><name>dt_errtag</name><argument_list>(<argument><expr><name>D_PRAGMA_DEPEND</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_errno</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dt_dprintf</name><argument_list>(<argument><expr><literal type="string">"error parsing library %s: %s\n"</literal></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><call><name>dtrace_errmsg</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><call><name>dtrace_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_filetag</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>closedir</name><argument_list>(<argument><expr><name>dirp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_load_libs_sort</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_prog_t</name> <modifier>*</modifier></type><name>pgp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_lib_depend_t</name> <modifier>*</modifier></type><name>dld</name></decl>;</decl_stmt>






<if_stmt><if>if <condition>(<expr><call><name>dt_lib_depend_sort</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>dld</name> <operator>=</operator> <call><name>dt_list_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtp</name><operator>-&gt;</operator><name>dt_lib_dep_sorted</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>dld</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
<incr><expr><name>dld</name> <operator>=</operator> <call><name>dt_list_next</name><argument_list>(<argument><expr><name>dld</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fp</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name><name>dld</name><operator>-&gt;</operator><name>dtld_library</name></name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_dprintf</name><argument_list>(<argument><expr><literal type="string">"skipping library %s: %s\n"</literal></expr></argument>,
<argument><expr><name><name>dld</name><operator>-&gt;</operator><name>dtld_library</name></name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_filetag</name></name> <operator>=</operator> <name><name>dld</name><operator>-&gt;</operator><name>dtld_library</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>pgp</name> <operator>=</operator> <call><name>dtrace_program_fcompile</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>DTRACE_C_EMPTY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_filetag</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pgp</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>dtp</name><operator>-&gt;</operator><name>dt_errno</name></name> <operator>!=</operator> <name>EDT_COMPILER</name> <operator>||</operator>
<name><name>dtp</name><operator>-&gt;</operator><name>dt_errtag</name></name> <operator>!=</operator> <call><name>dt_errtag</name><argument_list>(<argument><expr><name>D_PRAGMA_DEPEND</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>pgp</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_dprintf</name><argument_list>(<argument><expr><literal type="string">"skipping library %s: %s\n"</literal></expr></argument>,
<argument><expr><name><name>dld</name><operator>-&gt;</operator><name>dtld_library</name></name></expr></argument>,
<argument><expr><call><name>dtrace_errmsg</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><call><name>dtrace_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>dld</name><operator>-&gt;</operator><name>dtld_loaded</name></name> <operator>=</operator> <name>B_TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_program_destroy</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>pgp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>dt_lib_depend_free</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>

<label><name>err</name>:</label>
<expr_stmt><expr><call><name>dt_lib_depend_free</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_load_libs</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_dirpath_t</name> <modifier>*</modifier></type><name>dirp</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_cflags</name></name> <operator>&amp;</operator> <name>DTRACE_C_NOLIBS</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_cflags</name></name> <operator>|=</operator> <name>DTRACE_C_NOLIBS</name></expr>;</expr_stmt>








<for>for <control>(<init><expr><name>dirp</name> <operator>=</operator> <call><name>dt_list_next</name><argument_list>(<argument><expr><call><name>dt_list_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtp</name><operator>-&gt;</operator><name>dt_lib_path</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</init>
<condition><expr><name>dirp</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>dirp</name> <operator>=</operator> <call><name>dt_list_next</name><argument_list>(<argument><expr><name>dirp</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dt_load_libs_dir</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>dirp</name><operator>-&gt;</operator><name>dir_path</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_cflags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DTRACE_C_NOLIBS</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<expr_stmt><expr><name>dirp</name> <operator>=</operator> <call><name>dt_list_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtp</name><operator>-&gt;</operator><name>dt_lib_path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_load_libs_dir</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>dirp</name><operator>-&gt;</operator><name>dir_path</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_cflags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DTRACE_C_NOLIBS</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dt_load_libs_sort</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>dt_compile</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>dtrace_probespec_t</name></type> <name>pspec</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>,
<parameter><decl><type><name>uint_t</name></type> <name>cflags</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>argv</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_decl_t</name> <modifier>*</modifier></type><name>ddp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_pcb_t</name></type> <name>pcb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier><specifier>volatile</specifier></type> <name>rv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fp</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>s</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>cflags</name> <operator>&amp;</operator> <operator>~</operator><name>DTRACE_C_MASK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dt_list_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtp</name><operator>-&gt;</operator><name>dt_lib_path</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>dt_load_libs</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_globals</name><operator>-&gt;</operator><name>dh_nelems</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dt_idhash_iter</name><argument_list>(<argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_globals</name></name></expr></argument>, <argument><expr><name>dt_idreset</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_tls</name><operator>-&gt;</operator><name>dh_nelems</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dt_idhash_iter</name><argument_list>(<argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_tls</name></name></expr></argument>, <argument><expr><name>dt_idreset</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>fp</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>cflags</name> <operator>&amp;</operator> <name>DTRACE_C_CPP</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>fp</name> <operator>=</operator> <call><name>dt_preproc</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>dt_pcb_push</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pcb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pcb</name><operator>.</operator><name>pcb_fileptr</name></name> <operator>=</operator> <name>fp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pcb</name><operator>.</operator><name>pcb_string</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pcb</name><operator>.</operator><name>pcb_strptr</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pcb</name><operator>.</operator><name>pcb_strlen</name></name> <operator>=</operator> <ternary><condition><expr><name>s</name></expr> ?</condition><then> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pcb</name><operator>.</operator><name>pcb_sargc</name></name> <operator>=</operator> <name>argc</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pcb</name><operator>.</operator><name>pcb_sargv</name></name> <operator>=</operator> <name>argv</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pcb</name><operator>.</operator><name>pcb_sflagv</name></name> <operator>=</operator> <ternary><condition><expr><name>argc</name></expr> ?</condition><then> <expr><call><name>calloc</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>ushort_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pcb</name><operator>.</operator><name>pcb_pspec</name></name> <operator>=</operator> <name>pspec</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pcb</name><operator>.</operator><name>pcb_cflags</name></name> <operator>=</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_cflags</name></name> <operator>|</operator> <name>cflags</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pcb</name><operator>.</operator><name>pcb_amin</name></name> <operator>=</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_amin</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pcb</name><operator>.</operator><name>pcb_yystate</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pcb</name><operator>.</operator><name>pcb_context</name></name> <operator>=</operator> <name>context</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pcb</name><operator>.</operator><name>pcb_token</name></name> <operator>=</operator> <name>context</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>context</name> <operator>!=</operator> <name>DT_CTX_DPROG</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>yybegin</name><argument_list>(<argument><expr><name>YYS_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>cflags</name> <operator>&amp;</operator> <name>DTRACE_C_CTL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>yybegin</name><argument_list>(<argument><expr><name>YYS_CONTROL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>yybegin</name><argument_list>(<argument><expr><name>YYS_CLAUSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>err</name> <operator>=</operator> <call><name>setjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_sargc</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>yypcb</name><operator>-&gt;</operator><name>pcb_sflagv</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_NOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_idents</name></name> <operator>=</operator> <call><name>dt_idhash_create</name><argument_list>(<argument><expr><literal type="string">"ambiguous"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_locals</name></name> <operator>=</operator> <call><name>dt_idhash_create</name><argument_list>(<argument><expr><literal type="string">"clause local"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>DIF_VAR_OTHER_UBASE</name></expr></argument>, <argument><expr><name>DIF_VAR_OTHER_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_idents</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>yypcb</name><operator>-&gt;</operator><name>pcb_locals</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_NOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>







<if_stmt><if>if <condition>(<expr><call><name>yyparse</name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>yypcb</name><operator>-&gt;</operator><name>pcb_root</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_EMPTY</name></expr></argument>, <argument><expr><literal type="string">"empty D program translation unit\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>yybegin</name><argument_list>(<argument><expr><name>YYS_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cflags</name> <operator>&amp;</operator> <name>DTRACE_C_CTL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>context</name> <operator>!=</operator> <name>DT_CTX_DTYPE</name> <operator>&amp;&amp;</operator> <call><name>DT_TREEDUMP_PASS</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dt_node_printr</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_root</name></name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_pragmas</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dt_idhash_iter</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_pragmas</name></name></expr></argument>, <argument><expr><name>dt_idpragma</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_cflags</name></name> <operator>&amp;</operator> <name>DTRACE_C_ARGREF</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>!</operator><operator>(</operator><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_sflagv</name><index>[<expr><name>argc</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <name>DT_IDFLG_REF</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_MACRO_UNUSED</name></expr></argument>, <argument><expr><literal type="string">"extraneous argument '%s' ($%d is "</literal>
<literal type="string">"not referenced)\n"</literal></expr></argument>, <argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_sargv</name><index>[<expr><name>argc</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>argc</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><name>context</name> <operator>==</operator> <name>DT_CTX_DPROG</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>next_dnp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>new_list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>dnp</name> <operator>=</operator> <name><name>yypcb</name><operator>-&gt;</operator><name>pcb_root</name><operator>-&gt;</operator><name>dn_list</name></name></expr>;</init>
<condition><expr><name>dnp</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>dnp</name> <operator>=</operator> <name>next_dnp</name></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>next_dnp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_list</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_list</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_CLAUSE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>dnp</name> <operator>=</operator> <call><name>dt_compile_sugar</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>new_list</name> <operator>=</operator> <call><name>dt_node_link</name><argument_list>(<argument><expr><name>new_list</name></expr></argument>, <argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_root</name><operator>-&gt;</operator><name>dn_list</name></name> <operator>=</operator> <name>new_list</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>







<switch>switch <condition>(<expr><name>context</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DT_CTX_DPROG</name></expr>:</case>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_root</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_PROG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>dnp</name> <operator>=</operator> <name><name>yypcb</name><operator>-&gt;</operator><name>pcb_root</name><operator>-&gt;</operator><name>dn_list</name></name><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
<operator>!</operator><operator>(</operator><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_cflags</name></name> <operator>&amp;</operator> <name>DTRACE_C_EMPTY</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_EMPTY</name></expr></argument>, <argument><expr><literal type="string">"empty D program translation unit\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_prog</name></name> <operator>=</operator> <call><name>dt_program_create</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><call><name>dtrace_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>dnp</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>dnp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_list</name></name></expr></incr>)</control> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_kind</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DT_NODE_CLAUSE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>DT_TREEDUMP_PASS</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dt_printd</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>dt_compile_clause</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_XLATOR</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_xlatemode</name></name> <operator>==</operator> <name>DT_XL_DYNAMIC</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dt_compile_xlator</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_PROVIDER</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dt_node_cook</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>DT_IDFLG_REF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></for>

<expr_stmt><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_prog</name><operator>-&gt;</operator><name>dp_xrefs</name></name> <operator>=</operator> <name><name>yypcb</name><operator>-&gt;</operator><name>pcb_asxrefs</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_prog</name><operator>-&gt;</operator><name>dp_xrefslen</name></name> <operator>=</operator> <name><name>yypcb</name><operator>-&gt;</operator><name>pcb_asxreflen</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_asxrefs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_asxreflen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>rv</name> <operator>=</operator> <name><name>yypcb</name><operator>-&gt;</operator><name>pcb_prog</name></name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DT_CTX_DEXPR</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dt_node_cook</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_root</name></name></expr></argument>, <argument><expr><name>DT_IDFLG_REF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_cg</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>, <argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>dt_as</name><argument_list>(<argument><expr><name>yypcb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DT_CTX_DTYPE</name></expr>:</case>
<expr_stmt><expr><name>ddp</name> <operator>=</operator> <operator>(</operator><name>dt_decl_t</name> <operator>*</operator><operator>)</operator><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_root</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>dt_decl_type</name><argument_list>(<argument><expr><name>ddp</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_decl_free</name><argument_list>(<argument><expr><name>ddp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_COMPILER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>rv</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>

<label><name>out</name>:</label>
<if_stmt><if>if <condition>(<expr><name>context</name> <operator>!=</operator> <name>DT_CTX_DTYPE</name> <operator>&amp;&amp;</operator> <name><name>yypcb</name><operator>-&gt;</operator><name>pcb_root</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
<call><name>DT_TREEDUMP_PASS</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dt_node_printr</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_root</name></name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_cdefs_fd</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>ftruncate64</name><argument_list>(<argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_cdefs_fd</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator>
<call><name>lseek64</name><argument_list>(<argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_cdefs_fd</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator>
<call><name>ctf_write</name><argument_list>(<argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_cdefs</name><operator>-&gt;</operator><name>dm_ctfp</name></name></expr></argument>, <argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_cdefs_fd</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CTF_ERR</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dt_dprintf</name><argument_list>(<argument><expr><literal type="string">"failed to update CTF cache: %s\n"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_ddefs_fd</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>ftruncate64</name><argument_list>(<argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_ddefs_fd</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator>
<call><name>lseek64</name><argument_list>(<argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_ddefs_fd</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator>
<call><name>ctf_write</name><argument_list>(<argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_ddefs</name><operator>-&gt;</operator><name>dm_ctfp</name></name></expr></argument>, <argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_ddefs_fd</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CTF_ERR</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dt_dprintf</name><argument_list>(<argument><expr><literal type="string">"failed to update CTF cache: %s\n"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_fileptr</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>cflags</name> <operator>&amp;</operator> <name>DTRACE_C_CPP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fclose</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_fileptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>dt_pcb_pop</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><ternary><condition><expr><name>err</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name>rv</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>dtrace_prog_t</name> <modifier>*</modifier></type>
<name>dtrace_program_strcompile</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><name>dtrace_probespec_t</name></type> <name>spec</name></decl></parameter>, <parameter><decl><type><name>uint_t</name></type> <name>cflags</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><call><name>dt_compile</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>DT_CTX_DPROG</name></expr></argument>,
<argument><expr><name>spec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>cflags</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>dtrace_prog_t</name> <modifier>*</modifier></type>
<name>dtrace_program_fcompile</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>,
<parameter><decl><type><name>uint_t</name></type> <name>cflags</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><call><name>dt_compile</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>DT_CTX_DPROG</name></expr></argument>,
<argument><expr><name>DTRACE_PROBESPEC_NAME</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>cflags</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>dtrace_type_strcompile</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>dtrace_typeinfo_t</name> <modifier>*</modifier></type><name>dtt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dt_compile</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>DT_CTX_DTYPE</name></expr></argument>,
<argument><expr><name>DTRACE_PROBESPEC_NONE</name></expr></argument>, <argument><expr><name>dtt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><ternary><condition><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_errno</name></name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>dtrace_type_fcompile</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><name>dtrace_typeinfo_t</name> <modifier>*</modifier></type><name>dtt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dt_compile</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>DT_CTX_DTYPE</name></expr></argument>,
<argument><expr><name>DTRACE_PROBESPEC_NONE</name></expr></argument>, <argument><expr><name>dtt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><ternary><condition><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_errno</name></name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>
</unit>
