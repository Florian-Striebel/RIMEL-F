<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/cddl/contrib/opensolaris/lib/libdtrace/common/dt_decl.c">



























<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>ident</name> <cpp:literal>"%Z%%M% %I% %E% SMI"</cpp:literal></cpp:pragma>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;strings.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;alloca.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dt_decl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dt_parser.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dt_module.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dt_impl.h&gt;</cpp:file></cpp:include>

<function><type><specifier>static</specifier> <name>dt_decl_t</name> <modifier>*</modifier></type>
<name>dt_decl_check</name><parameter_list>(<parameter><decl><type><name>dt_decl_t</name> <modifier>*</modifier></type><name>ddp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_kind</name></name> <operator>==</operator> <name>CTF_K_UNKNOWN</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>ddp</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_name</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_name</name></name></expr></argument>, <argument><expr><literal type="string">"char"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>ddp</name><operator>-&gt;</operator><name>dd_attr</name></name> <operator>&amp;</operator> <operator>(</operator><name>DT_DA_SHORT</name> <operator>|</operator> <name>DT_DA_LONG</name> <operator>|</operator> <name>DT_DA_LONGLONG</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_CHARATTR</name></expr></argument>, <argument><expr><literal type="string">"invalid type declaration: short and "</literal>
<literal type="string">"long may not be used with char type\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_name</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_name</name></name></expr></argument>, <argument><expr><literal type="string">"void"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>ddp</name><operator>-&gt;</operator><name>dd_attr</name></name> <operator>&amp;</operator> <operator>(</operator><name>DT_DA_SHORT</name> <operator>|</operator> <name>DT_DA_LONG</name> <operator>|</operator> <name>DT_DA_LONGLONG</name> <operator>|</operator>
<operator>(</operator><name>DT_DA_SIGNED</name> <operator>|</operator> <name>DT_DA_UNSIGNED</name><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_VOIDATTR</name></expr></argument>, <argument><expr><literal type="string">"invalid type declaration: attributes "</literal>
<literal type="string">"may not be used with void type\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_kind</name></name> <operator>!=</operator> <name>CTF_K_INTEGER</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>ddp</name><operator>-&gt;</operator><name>dd_attr</name></name> <operator>&amp;</operator> <operator>(</operator><name>DT_DA_SIGNED</name> <operator>|</operator> <name>DT_DA_UNSIGNED</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_SIGNINT</name></expr></argument>, <argument><expr><literal type="string">"invalid type declaration: signed and "</literal>
<literal type="string">"unsigned may only be used with integer type\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_kind</name></name> <operator>!=</operator> <name>CTF_K_INTEGER</name> <operator>&amp;&amp;</operator> <name><name>ddp</name><operator>-&gt;</operator><name>dd_kind</name></name> <operator>!=</operator> <name>CTF_K_FLOAT</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>ddp</name><operator>-&gt;</operator><name>dd_attr</name></name> <operator>&amp;</operator> <operator>(</operator><name>DT_DA_LONG</name> <operator>|</operator> <name>DT_DA_LONGLONG</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_LONGINT</name></expr></argument>, <argument><expr><literal type="string">"invalid type declaration: long and "</literal>
<literal type="string">"long long may only be used with integer or "</literal>
<literal type="string">"floating-point type\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><name>ddp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>dt_decl_t</name> <modifier>*</modifier></type>
<name>dt_decl_alloc</name><parameter_list>(<parameter><decl><type><name>ushort_t</name></type> <name>kind</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_decl_t</name> <modifier>*</modifier></type><name>ddp</name> <init>= <expr><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>dt_decl_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ddp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_NOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_kind</name></name> <operator>=</operator> <name>kind</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_attr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_ctfp</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_type</name></name> <operator>=</operator> <name>CTF_ERR</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_name</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_node</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>ddp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>dt_decl_free</name><parameter_list>(<parameter><decl><type><name>dt_decl_t</name> <modifier>*</modifier></type><name>ddp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_decl_t</name> <modifier>*</modifier></type><name>ndp</name></decl>;</decl_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>ddp</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ddp</name> <operator>=</operator> <name>ndp</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>ndp</name> <operator>=</operator> <name><name>ddp</name><operator>-&gt;</operator><name>dd_next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_list_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ddp</name><operator>-&gt;</operator><name>dd_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ddp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>dt_decl_reset</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_scope_t</name> <modifier>*</modifier></type><name>dsp</name> <init>= <expr><operator>&amp;</operator><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_dstack</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_decl_t</name> <modifier>*</modifier></type><name>ddp</name> <init>= <expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_decl</name></name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_next</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_decl</name></name> <operator>=</operator> <name><name>ddp</name><operator>-&gt;</operator><name>dd_next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_decl_free</name><argument_list>(<argument><expr><name>ddp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ddp</name> <operator>=</operator> <name><name>dsp</name><operator>-&gt;</operator><name>ds_decl</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>dt_decl_t</name> <modifier>*</modifier></type>
<name>dt_decl_push</name><parameter_list>(<parameter><decl><type><name>dt_decl_t</name> <modifier>*</modifier></type><name>ddp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_scope_t</name> <modifier>*</modifier></type><name>dsp</name> <init>= <expr><operator>&amp;</operator><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_dstack</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_decl_t</name> <modifier>*</modifier></type><name>top</name> <init>= <expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_decl</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>top</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
<name><name>top</name><operator>-&gt;</operator><name>dd_kind</name></name> <operator>==</operator> <name>CTF_K_UNKNOWN</name> <operator>&amp;&amp;</operator> <name><name>top</name><operator>-&gt;</operator><name>dd_name</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>top</name><operator>-&gt;</operator><name>dd_kind</name></name> <operator>=</operator> <name>CTF_K_INTEGER</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dt_decl_check</name><argument_list>(<argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_next</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_next</name></name> <operator>=</operator> <name>top</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_decl</name></name> <operator>=</operator> <name>ddp</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>ddp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>dt_decl_t</name> <modifier>*</modifier></type>
<name>dt_decl_pop</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_scope_t</name> <modifier>*</modifier></type><name>dsp</name> <init>= <expr><operator>&amp;</operator><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_dstack</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_decl_t</name> <modifier>*</modifier></type><name>ddp</name> <init>= <expr><call><name>dt_decl_top</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_decl</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ctfp</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_type</name></name> <operator>=</operator> <name>CTF_ERR</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_class</name></name> <operator>=</operator> <name>DT_DC_DEFAULT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_enumval</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>ddp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>dt_decl_t</name> <modifier>*</modifier></type>
<name>dt_decl_pop_param</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>idp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_scope_t</name> <modifier>*</modifier></type><name>dsp</name> <init>= <expr><operator>&amp;</operator><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_dstack</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_class</name></name> <operator>!=</operator> <name>DT_DC_DEFAULT</name> <operator>&amp;&amp;</operator> <name><name>dsp</name><operator>-&gt;</operator><name>ds_class</name></name> <operator>!=</operator> <name>DT_DC_REGISTER</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_PARMCLASS</name></expr></argument>, <argument><expr><literal type="string">"inappropriate storage class "</literal>
<literal type="string">"for function or associative array parameter\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>idp</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>dt_decl_top</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>idp</name> <operator>=</operator> <name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><call><name>dt_decl_pop</name><argument_list>()</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>dt_decl_t</name> <modifier>*</modifier></type>
<name>dt_decl_top</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_decl_t</name> <modifier>*</modifier></type><name>ddp</name> <init>= <expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_dstack</name><operator>.</operator><name>ds_decl</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ddp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_NODECL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_kind</name></name> <operator>==</operator> <name>CTF_K_UNKNOWN</name> <operator>&amp;&amp;</operator> <name><name>ddp</name><operator>-&gt;</operator><name>dd_name</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_kind</name></name> <operator>=</operator> <name>CTF_K_INTEGER</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dt_decl_check</name><argument_list>(<argument><expr><name>ddp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><name>ddp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>dt_decl_t</name> <modifier>*</modifier></type>
<name>dt_decl_ident</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_scope_t</name> <modifier>*</modifier></type><name>dsp</name> <init>= <expr><operator>&amp;</operator><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_dstack</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_decl_t</name> <modifier>*</modifier></type><name>ddp</name> <init>= <expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_decl</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_IDENT</name></expr></argument>, <argument><expr><literal type="string">"old-style declaration or "</literal>
<literal type="string">"incorrect type specified\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ddp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ddp</name> <operator>=</operator> <call><name>dt_decl_push</name><argument_list>(<argument><expr><call><name>dt_decl_alloc</name><argument_list>(<argument><expr><name>CTF_K_UNKNOWN</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><name>ddp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>dt_decl_class</name><parameter_list>(<parameter><decl><type><name>dt_dclass_t</name></type> <name>class</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_scope_t</name> <modifier>*</modifier></type><name>dsp</name> <init>= <expr><operator>&amp;</operator><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_dstack</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_class</name></name> <operator>!=</operator> <name>DT_DC_DEFAULT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_CLASS</name></expr></argument>, <argument><expr><literal type="string">"only one storage class allowed "</literal>
<literal type="string">"in a declaration\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_class</name></name> <operator>=</operator> <name>class</name></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><name>dt_decl_t</name> <modifier>*</modifier></type>
<name>dt_decl_spec</name><parameter_list>(<parameter><decl><type><name>ushort_t</name></type> <name>kind</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_decl_t</name> <modifier>*</modifier></type><name>ddp</name> <init>= <expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_dstack</name><operator>.</operator><name>ds_decl</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ddp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>dt_decl_push</name><argument_list>(<argument><expr><call><name>dt_decl_alloc</name><argument_list>(<argument><expr><name>kind</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>








<if_stmt><if>if <condition>(<expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_name</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>kind</name> <operator>==</operator> <name>CTF_K_TYPEDEF</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_dstack</name><operator>.</operator><name>ds_class</name></name> <operator>!=</operator> <name>DT_DC_TYPEDEF</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>dt_decl_ident</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_IDRED</name></expr></argument>, <argument><expr><literal type="string">"identifier redeclared: %s\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_name</name></name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name><name>ddp</name><operator>-&gt;</operator><name>dd_kind</name></name> <operator>!=</operator> <name>CTF_K_UNKNOWN</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_COMBO</name></expr></argument>, <argument><expr><literal type="string">"invalid type combination\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_kind</name></name> <operator>=</operator> <name>kind</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_name</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><call><name>dt_decl_check</name><argument_list>(<argument><expr><name>ddp</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>dt_decl_t</name> <modifier>*</modifier></type>
<name>dt_decl_attr</name><parameter_list>(<parameter><decl><type><name>ushort_t</name></type> <name>attr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_decl_t</name> <modifier>*</modifier></type><name>ddp</name> <init>= <expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_dstack</name><operator>.</operator><name>ds_decl</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ddp</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ddp</name> <operator>=</operator> <call><name>dt_decl_push</name><argument_list>(<argument><expr><call><name>dt_decl_alloc</name><argument_list>(<argument><expr><name>CTF_K_UNKNOWN</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_attr</name></name> <operator>=</operator> <name>attr</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ddp</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>attr</name> <operator>==</operator> <name>DT_DA_LONG</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ddp</name><operator>-&gt;</operator><name>dd_attr</name></name> <operator>&amp;</operator> <name>DT_DA_LONG</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_attr</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DT_DA_LONG</name></expr>;</expr_stmt>
<expr_stmt><expr><name>attr</name> <operator>=</operator> <name>DT_DA_LONGLONG</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_attr</name></name> <operator>|=</operator> <name>attr</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><call><name>dt_decl_check</name><argument_list>(<argument><expr><name>ddp</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_decl_protoform</name><parameter_list>(<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>fnp</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>flist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>dnp</name> <operator>=</operator> <name>flist</name></expr>;</init> <condition><expr><name>dnp</name> <operator>!=</operator> <name>fnp</name> <operator>&amp;&amp;</operator> <name>dnp</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>dnp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_list</name></name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
<call><name>strcmp</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name></expr></argument>, <argument><expr><name><name>fnp</name><operator>-&gt;</operator><name>dn_string</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>B_TRUE</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><operator>(</operator><name>B_FALSE</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>









<function><type><name>int</name></type>
<name>dt_decl_prototype</name><parameter_list>(<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>plist</name></decl></parameter>,
<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>flist</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>kind</name></decl></parameter>, <parameter><decl><type><name>uint_t</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>n</name><index>[<expr><name>DT_TYPE_NAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>is_void</name></decl>, <decl><type ref="prev"/><name>v</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>form</name> <init>= <expr><name>plist</name> <operator>!=</operator> <name>flist</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>dnp</name> <operator>=</operator> <name>plist</name></expr>;</init> <condition><expr><name>dnp</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>dnp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_list</name></name></expr><operator>,</operator> <expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_type</name></name> <operator>==</operator> <name>CTF_ERR</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>DT_DP_VARARGS</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_DECL_PROTO_VARARGS</name></expr></argument>, <argument><expr><literal type="string">"%s prototype may "</literal>
<literal type="string">"not use a variable-length argument list\n"</literal></expr></argument>, <argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dt_node_is_dynamic</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>DT_DP_DYNAMIC</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_DECL_PROTO_TYPE</name></expr></argument>, <argument><expr><literal type="string">"%s prototype may not "</literal>
<literal type="string">"use parameter of type %s: %s, parameter #%d\n"</literal></expr></argument>,
<argument><expr><name>kind</name></expr></argument>, <argument><expr><call><name>dt_node_type_name</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><ternary><condition><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name></expr> ?</condition><then> <expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name></expr> </then><else>: <expr><literal type="string">"(anonymous)"</literal></expr></else></ternary></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>is_void</name> <operator>=</operator> <call><name>dt_node_is_void</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> <operator>+=</operator> <name>is_void</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>is_void</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>DT_DP_VOID</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_DECL_PROTO_TYPE</name></expr></argument>, <argument><expr><literal type="string">"%s prototype may not "</literal>
<literal type="string">"use parameter of type %s: %s, parameter #%d\n"</literal></expr></argument>,
<argument><expr><name>kind</name></expr></argument>, <argument><expr><call><name>dt_node_type_name</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><ternary><condition><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name></expr> ?</condition><then> <expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name></expr> </then><else>: <expr><literal type="string">"(anonymous)"</literal></expr></else></ternary></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>is_void</name> <operator>&amp;&amp;</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_DECL_PROTO_NAME</name></expr></argument>, <argument><expr><literal type="string">"void parameter may "</literal>
<literal type="string">"not have a name: %s\n"</literal></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
<call><name>dt_decl_protoform</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>flist</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>form</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_DECL_PROTO_FORM</name></expr></argument>, <argument><expr><literal type="string">"parameter is "</literal>
<literal type="string">"%s declared in %s prototype: %s, parameter #%d\n"</literal></expr></argument>,
<argument><expr><ternary><condition><expr><name>form</name></expr> ?</condition><then> <expr><literal type="string">"not"</literal></expr> </then><else>: <expr><literal type="string">"already"</literal></expr></else></ternary></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
<operator>!</operator><name>is_void</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>DT_DP_ANON</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_DECL_PROTO_NAME</name></expr></argument>, <argument><expr><literal type="string">"parameter declaration "</literal>
<literal type="string">"requires a name: parameter #%d\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>v</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>plist</name><operator>-&gt;</operator><name>dn_list</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_PROTO_VOID</name></expr></argument>, <argument><expr><literal type="string">"void must be sole parameter\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><ternary><condition><expr><name>v</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>dt_decl_t</name> <modifier>*</modifier></type>
<name>dt_decl_array</name><parameter_list>(<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_decl_t</name> <modifier>*</modifier></type><name>ddp</name> <init>= <expr><call><name>dt_decl_push</name><argument_list>(<argument><expr><call><name>dt_decl_alloc</name><argument_list>(<argument><expr><name>CTF_K_ARRAY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_scope_t</name> <modifier>*</modifier></type><name>dsp</name> <init>= <expr><operator>&amp;</operator><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_dstack</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_decl_t</name> <modifier>*</modifier></type><name>ndp</name> <init>= <expr><name>ddp</name></expr></init></decl>;</decl_stmt>







<while>while <condition>(<expr><name><name>ndp</name><operator>-&gt;</operator><name>dd_next</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>ndp</name><operator>-&gt;</operator><name>dd_next</name><operator>-&gt;</operator><name>dd_kind</name></name> <operator>==</operator> <name>CTF_K_ARRAY</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ndp</name> <operator>=</operator> <name><name>ndp</name><operator>-&gt;</operator><name>dd_next</name></name></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><name>ndp</name> <operator>!=</operator> <name>ddp</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>dnp</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_TYPE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_DYNOBJ</name></expr></argument>,
<argument><expr><literal type="string">"cannot declare array of associative arrays\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_decl</name></name> <operator>=</operator> <name><name>ddp</name><operator>-&gt;</operator><name>dd_next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_next</name></name> <operator>=</operator> <name><name>ndp</name><operator>-&gt;</operator><name>dd_next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ndp</name><operator>-&gt;</operator><name>dd_next</name></name> <operator>=</operator> <name>ddp</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_next</name><operator>-&gt;</operator><name>dd_name</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
<call><name>strcmp</name><argument_list>(<argument><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_next</name><operator>-&gt;</operator><name>dd_name</name></name></expr></argument>, <argument><expr><literal type="string">"void"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_VOIDOBJ</name></expr></argument>, <argument><expr><literal type="string">"cannot declare array of void\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>dnp</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>!=</operator> <name>DT_NODE_TYPE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>dnp</name> <operator>=</operator> <name><name>ddp</name><operator>-&gt;</operator><name>dd_node</name></name> <operator>=</operator> <call><name>dt_node_cook</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>DT_IDFLG_REF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dt_node_is_posconst</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_ARRSUB</name></expr></argument>, <argument><expr><literal type="string">"positive integral constant "</literal>
<literal type="string">"expression or tuple signature expected as "</literal>
<literal type="string">"array declaration subscript\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>&gt;</operator> <name>UINT_MAX</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_ARRBIG</name></expr></argument>, <argument><expr><literal type="string">"array dimension too big\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>dnp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_node</name></name> <operator>=</operator> <name>dnp</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dt_decl_prototype</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>dnp</name></expr></argument>, <argument><expr><literal type="string">"array"</literal></expr></argument>, <argument><expr><name>DT_DP_ANON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><name>ddp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>












<function><type><name>dt_decl_t</name> <modifier>*</modifier></type>
<name>dt_decl_func</name><parameter_list>(<parameter><decl><type><name>dt_decl_t</name> <modifier>*</modifier></type><name>pdp</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_decl_t</name> <modifier>*</modifier></type><name>ddp</name> <init>= <expr><call><name>dt_decl_alloc</name><argument_list>(<argument><expr><name>CTF_K_FUNCTION</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_node</name></name> <operator>=</operator> <name>dnp</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dt_decl_prototype</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>dnp</name></expr></argument>, <argument><expr><literal type="string">"function"</literal></expr></argument>,
<argument><expr><name>DT_DP_VARARGS</name> <operator>|</operator> <name>DT_DP_VOID</name> <operator>|</operator> <name>DT_DP_ANON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pdp</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>pdp</name><operator>-&gt;</operator><name>dd_kind</name></name> <operator>!=</operator> <name>CTF_K_POINTER</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>dt_decl_push</name><argument_list>(<argument><expr><name>ddp</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<while>while <condition>(<expr><name><name>pdp</name><operator>-&gt;</operator><name>dd_next</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>pdp</name><operator>-&gt;</operator><name>dd_next</name><operator>-&gt;</operator><name>dd_attr</name></name> <operator>&amp;</operator> <name>DT_DA_PAREN</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>pdp</name> <operator>=</operator> <name><name>pdp</name><operator>-&gt;</operator><name>dd_next</name></name></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><name><name>pdp</name><operator>-&gt;</operator><name>dd_next</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>dt_decl_push</name><argument_list>(<argument><expr><name>ddp</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_next</name></name> <operator>=</operator> <name><name>pdp</name><operator>-&gt;</operator><name>dd_next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pdp</name><operator>-&gt;</operator><name>dd_next</name></name> <operator>=</operator> <name>ddp</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>pdp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>dt_decl_t</name> <modifier>*</modifier></type>
<name>dt_decl_ptr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><call><name>dt_decl_push</name><argument_list>(<argument><expr><call><name>dt_decl_alloc</name><argument_list>(<argument><expr><name>CTF_K_POINTER</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>dt_decl_t</name> <modifier>*</modifier></type>
<name>dt_decl_sou</name><parameter_list>(<parameter><decl><type><name>uint_t</name></type> <name>kind</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_decl_t</name> <modifier>*</modifier></type><name>ddp</name> <init>= <expr><call><name>dt_decl_spec</name><argument_list>(<argument><expr><name>kind</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>n</name><index>[<expr><name>DT_TYPE_NAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_file_t</name> <modifier>*</modifier></type><name>ctfp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_id_t</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint_t</name></type> <name>flag</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_idepth</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ctfp</name> <operator>=</operator> <name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name><operator>-&gt;</operator><name>dt_cdefs</name><operator>-&gt;</operator><name>dm_ctfp</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>ctfp</name> <operator>=</operator> <name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name><operator>-&gt;</operator><name>dt_ddefs</name><operator>-&gt;</operator><name>dm_ctfp</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_dstack</name><operator>.</operator><name>ds_next</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>flag</name> <operator>=</operator> <name>CTF_ADD_NONROOT</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>flag</name> <operator>=</operator> <name>CTF_ADD_ROOT</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s %s"</literal></expr></argument>,
<argument><expr><ternary><condition><expr><name>kind</name> <operator>==</operator> <name>CTF_K_STRUCT</name></expr> ?</condition><then> <expr><literal type="string">"struct"</literal></expr> </then><else>: <expr><literal type="string">"union"</literal></expr></else></ternary></expr></argument>,
<argument><expr><ternary><condition><expr><name>name</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><literal type="string">"(anon)"</literal></expr> </then><else>: <expr><name>name</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>name</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>type</name> <operator>=</operator> <call><name>ctf_lookup_by_name</name><argument_list>(<argument><expr><name>ctfp</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>CTF_ERR</name> <operator>&amp;&amp;</operator>
<call><name>ctf_type_kind</name><argument_list>(<argument><expr><name>ctfp</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CTF_K_FORWARD</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_TYPERED</name></expr></argument>, <argument><expr><literal type="string">"type redeclared: %s\n"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>==</operator> <name>CTF_K_STRUCT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>ctf_add_struct</name><argument_list>(<argument><expr><name>ctfp</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>ctf_add_union</name><argument_list>(<argument><expr><name>ctfp</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>CTF_ERR</name> <operator>||</operator> <call><name>ctf_update</name><argument_list>(<argument><expr><name>ctfp</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CTF_ERR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_UNKNOWN</name></expr></argument>, <argument><expr><literal type="string">"failed to define %s: %s\n"</literal></expr></argument>,
<argument><expr><name>n</name></expr></argument>, <argument><expr><call><name>ctf_errmsg</name><argument_list>(<argument><expr><call><name>ctf_errno</name><argument_list>(<argument><expr><name>ctfp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_ctfp</name></name> <operator>=</operator> <name>ctfp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>dt_scope_push</name><argument_list>(<argument><expr><name>ctfp</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ddp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>dt_decl_member</name><parameter_list>(<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_scope_t</name> <modifier>*</modifier></type><name>dsp</name> <init>= <expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_dstack</name><operator>.</operator><name>ds_next</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_decl_t</name> <modifier>*</modifier></type><name>ddp</name> <init>= <expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_dstack</name><operator>.</operator><name>ds_decl</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ident</name> <init>= <expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_dstack</name><operator>.</operator><name>ds_ident</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>idname</name> <init>= <expr><ternary><condition><expr><name>ident</name></expr> ?</condition><then> <expr><name>ident</name></expr> </then><else>: <expr><literal type="string">"(anon)"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>n</name><index>[<expr><name>DT_TYPE_NAMELEN</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>dtrace_typeinfo_t</name></type> <name>dtt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_encoding_t</name></type> <name>cte</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_id_t</name></type> <name>base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint_t</name></type> <name>kind</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>size</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>dsp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_NOSCOPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ddp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_NODECL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>dnp</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>ident</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_MNAME</name></expr></argument>, <argument><expr><literal type="string">"member declaration requires a name\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_kind</name></name> <operator>==</operator> <name>CTF_K_UNKNOWN</name> <operator>&amp;&amp;</operator> <name><name>ddp</name><operator>-&gt;</operator><name>dd_name</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_kind</name></name> <operator>=</operator> <name>CTF_K_INTEGER</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dt_decl_check</name><argument_list>(<argument><expr><name>ddp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dt_decl_type</name><argument_list>(<argument><expr><name>ddp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dtt</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_COMPILER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ident</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>ident</name></expr></argument>, <argument><expr><literal type="char">'`'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_SCOPE</name></expr></argument>, <argument><expr><literal type="string">"D scoping operator may not be used "</literal>
<literal type="string">"in a member name (%s)\n"</literal></expr></argument>, <argument><expr><name>ident</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name> <operator>==</operator> <call><name>DT_DYN_CTFP</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<name><name>dtt</name><operator>.</operator><name>dtt_type</name></name> <operator>==</operator> <call><name>DT_DYN_TYPE</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_DYNOBJ</name></expr></argument>,
<argument><expr><literal type="string">"cannot have dynamic member: %s\n"</literal></expr></argument>, <argument><expr><name>ident</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>base</name> <operator>=</operator> <call><name>ctf_type_resolve</name><argument_list>(<argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>, <argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kind</name> <operator>=</operator> <call><name>ctf_type_kind</name><argument_list>(<argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>ctf_type_size</name><argument_list>(<argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>==</operator> <name>CTF_K_FORWARD</name> <operator>||</operator> <operator>(</operator><operator>(</operator><name>kind</name> <operator>==</operator> <name>CTF_K_STRUCT</name> <operator>||</operator>
<name>kind</name> <operator>==</operator> <name>CTF_K_UNION</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>size</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_INCOMPLETE</name></expr></argument>, <argument><expr><literal type="string">"incomplete struct/union/enum %s: "</literal>
<literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>dt_type_name</name><argument_list>(<argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>, <argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_type</name></name></expr></argument>,
<argument><expr><name>n</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ident</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_VOIDOBJ</name></expr></argument>, <argument><expr><literal type="string">"cannot have void member: %s\n"</literal></expr></argument>, <argument><expr><name>ident</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>







<if_stmt><if>if <condition>(<expr><name>dnp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>dnp</name> <operator>=</operator> <call><name>dt_node_cook</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>DT_IDFLG_REF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>







<if_stmt><if>if <condition>(<expr><name>ident</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_INT</name> <operator>&amp;&amp;</operator>
<name><name>dnp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_node_free</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dt_node_is_posconst</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_BFCONST</name></expr></argument>, <argument><expr><literal type="string">"positive integral constant "</literal>
<literal type="string">"expression expected as bit-field size\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ctf_type_kind</name><argument_list>(<argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CTF_K_INTEGER</name> <operator>||</operator>
<call><name>ctf_type_encoding</name><argument_list>(<argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cte</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CTF_ERR</name> <operator>||</operator>
<call><name>IS_VOID</name><argument_list>(<argument><expr><name>cte</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_BFTYPE</name></expr></argument>, <argument><expr><literal type="string">"invalid type for "</literal>
<literal type="string">"bit-field: %s\n"</literal></expr></argument>, <argument><expr><name>idname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>&gt;</operator> <name><name>cte</name><operator>.</operator><name>cte_bits</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_BFSIZE</name></expr></argument>, <argument><expr><literal type="string">"bit-field too big "</literal>
<literal type="string">"for type: %s\n"</literal></expr></argument>, <argument><expr><name>idname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>cte</name><operator>.</operator><name>cte_offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cte</name><operator>.</operator><name>cte_bits</name></name> <operator>=</operator> <operator>(</operator><name>uint_t</name><operator>)</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_value</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>dtt</name><operator>.</operator><name>dtt_type</name></name> <operator>=</operator> <call><name>ctf_add_integer</name><argument_list>(<argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ctfp</name></name></expr></argument>,
<argument><expr><name>CTF_ADD_NONROOT</name></expr></argument>, <argument><expr><call><name>ctf_type_name</name><argument_list>(<argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>,
<argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_type</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>cte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dtt</name><operator>.</operator><name>dtt_type</name></name> <operator>==</operator> <name>CTF_ERR</name> <operator>||</operator>
<call><name>ctf_update</name><argument_list>(<argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ctfp</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CTF_ERR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_UNKNOWN</name></expr></argument>, <argument><expr><literal type="string">"failed to create type for "</literal>
<literal type="string">"member '%s': %s\n"</literal></expr></argument>, <argument><expr><name>idname</name></expr></argument>,
<argument><expr><call><name>ctf_errmsg</name><argument_list>(<argument><expr><call><name>ctf_errno</name><argument_list>(<argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ctfp</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name> <operator>=</operator> <name><name>dsp</name><operator>-&gt;</operator><name>ds_ctfp</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_free</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>







<if_stmt><if>if <condition>(<expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name> <operator>!=</operator> <name><name>dsp</name><operator>-&gt;</operator><name>ds_ctfp</name></name> <operator>&amp;&amp;</operator>
<name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name> <operator>!=</operator> <call><name>ctf_parent_file</name><argument_list>(<argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ctfp</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>dtt</name><operator>.</operator><name>dtt_type</name></name> <operator>=</operator> <call><name>ctf_add_type</name><argument_list>(<argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ctfp</name></name></expr></argument>,
<argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>, <argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name> <operator>=</operator> <name><name>dsp</name><operator>-&gt;</operator><name>ds_ctfp</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dtt</name><operator>.</operator><name>dtt_type</name></name> <operator>==</operator> <name>CTF_ERR</name> <operator>||</operator>
<call><name>ctf_update</name><argument_list>(<argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CTF_ERR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_UNKNOWN</name></expr></argument>, <argument><expr><literal type="string">"failed to copy type of '%s': %s\n"</literal></expr></argument>,
<argument><expr><name>idname</name></expr></argument>, <argument><expr><call><name>ctf_errmsg</name><argument_list>(<argument><expr><call><name>ctf_errno</name><argument_list>(<argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ctf_add_member</name><argument_list>(<argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ctfp</name></name></expr></argument>, <argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_type</name></name></expr></argument>,
<argument><expr><name>ident</name></expr></argument>, <argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_type</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CTF_ERR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_UNKNOWN</name></expr></argument>, <argument><expr><literal type="string">"failed to define member '%s': %s\n"</literal></expr></argument>,
<argument><expr><name>idname</name></expr></argument>, <argument><expr><call><name>ctf_errmsg</name><argument_list>(<argument><expr><call><name>ctf_errno</name><argument_list>(<argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ctfp</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<label><name>done</name>:</label>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ident</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_dstack</name><operator>.</operator><name>ds_ident</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_decl_reset</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_decl_hasmembers</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>dt_decl_t</name> <modifier>*</modifier></type>
<name>dt_decl_enum</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_decl_t</name> <modifier>*</modifier></type><name>ddp</name> <init>= <expr><call><name>dt_decl_spec</name><argument_list>(<argument><expr><name>CTF_K_ENUM</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>n</name><index>[<expr><name>DT_TYPE_NAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_file_t</name> <modifier>*</modifier></type><name>ctfp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_id_t</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint_t</name></type> <name>flag</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_idepth</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ctfp</name> <operator>=</operator> <name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name><operator>-&gt;</operator><name>dt_cdefs</name><operator>-&gt;</operator><name>dm_ctfp</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>ctfp</name> <operator>=</operator> <name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name><operator>-&gt;</operator><name>dt_ddefs</name><operator>-&gt;</operator><name>dm_ctfp</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_dstack</name><operator>.</operator><name>ds_next</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>flag</name> <operator>=</operator> <name>CTF_ADD_NONROOT</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>flag</name> <operator>=</operator> <name>CTF_ADD_ROOT</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"enum %s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>name</name></expr> ?</condition><then> <expr><name>name</name></expr> </then><else>: <expr><literal type="string">"(anon)"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>name</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>type</name> <operator>=</operator> <call><name>ctf_lookup_by_name</name><argument_list>(<argument><expr><name>ctfp</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>CTF_ERR</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ctf_enum_iter</name><argument_list>(<argument><expr><name>ctfp</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>dt_decl_hasmembers</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_TYPERED</name></expr></argument>, <argument><expr><literal type="string">"type redeclared: %s\n"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>type</name> <operator>=</operator> <call><name>ctf_add_enum</name><argument_list>(<argument><expr><name>ctfp</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>CTF_ERR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_UNKNOWN</name></expr></argument>, <argument><expr><literal type="string">"failed to define %s: %s\n"</literal></expr></argument>,
<argument><expr><name>n</name></expr></argument>, <argument><expr><call><name>ctf_errmsg</name><argument_list>(<argument><expr><call><name>ctf_errno</name><argument_list>(<argument><expr><name>ctfp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_ctfp</name></name> <operator>=</operator> <name>ctfp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>dt_scope_push</name><argument_list>(<argument><expr><name>ctfp</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ddp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>dt_decl_enumerator</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_scope_t</name> <modifier>*</modifier></type><name>dsp</name> <init>= <expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_dstack</name><operator>.</operator><name>ds_next</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name> <init>= <expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>dt_idnode_t</name> <modifier>*</modifier></type><name>inp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_ident_t</name> <modifier>*</modifier></type><name>idp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>value</name></decl>;</decl_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>alloca</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>strcpy</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>dsp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_NOSCOPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_decl</name><operator>-&gt;</operator><name>dd_kind</name></name> <operator>==</operator> <name>CTF_K_ENUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>value</name> <operator>=</operator> <name><name>dsp</name><operator>-&gt;</operator><name>ds_enumval</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="char">'`'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_SCOPE</name></expr></argument>, <argument><expr><literal type="string">"D scoping operator may not be used in "</literal>
<literal type="string">"an enumerator name (%s)\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>






<if_stmt><if>if <condition>(<expr><name>dnp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>!=</operator> <name>DT_NODE_IDENT</name> <operator>||</operator> <call><name>ctf_enum_value</name><argument_list>(
<argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ctfp</name></name></expr></argument>, <argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_type</name></name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>dnp</name> <operator>=</operator> <call><name>dt_node_cook</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>DT_IDFLG_REF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>!=</operator> <name>DT_NODE_INT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_ENCONST</name></expr></argument>, <argument><expr><literal type="string">"enumerator '%s' must "</literal>
<literal type="string">"be assigned to an integral constant "</literal>
<literal type="string">"expression\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>intmax_t</name><operator>)</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>&gt;</operator> <name>INT_MAX</name> <operator>||</operator>
<operator>(</operator><name>intmax_t</name><operator>)</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>&lt;</operator> <name>INT_MIN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_ENOFLOW</name></expr></argument>, <argument><expr><literal type="string">"enumerator '%s' value "</literal>
<literal type="string">"overflows INT_MAX (%d)\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>INT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_value</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>dt_node_free</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ctf_add_enumerator</name><argument_list>(<argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ctfp</name></name></expr></argument>, <argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_type</name></name></expr></argument>,
<argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CTF_ERR</name> <operator>||</operator> <call><name>ctf_update</name><argument_list>(<argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ctfp</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CTF_ERR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_UNKNOWN</name></expr></argument>, <argument><expr><literal type="string">"failed to define enumerator '%s': %s\n"</literal></expr></argument>,
<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>ctf_errmsg</name><argument_list>(<argument><expr><call><name>ctf_errno</name><argument_list>(<argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ctfp</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_enumval</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>









<if_stmt><if>if <condition>(<expr><call><name>dt_idstack_lookup</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_globals</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ctfp</name></name> <operator>==</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_ddefs</name><operator>-&gt;</operator><name>dm_ctfp</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_IDRED</name></expr></argument>,
<argument><expr><literal type="string">"identifier redeclared: %s\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<return>return;</return></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>dt_dprintf</name><argument_list>(<argument><expr><literal type="string">"add global enumerator %s = %d\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>idp</name> <operator>=</operator> <call><name>dt_idhash_insert</name><argument_list>(<argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_globals</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>DT_IDENT_ENUM</name></expr></argument>,
<argument><expr><name>DT_IDFLG_INLINE</name> <operator>|</operator> <name>DT_IDFLG_REF</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>_dtrace_defattr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><operator>&amp;</operator><name>dt_idops_inline</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_gen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>idp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_NOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>yyintprefix</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yyintsuffix</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>yyintdecimal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>dnp</name> <operator>=</operator> <call><name>dt_node_int</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_type_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ctfp</name></name></expr></argument>, <argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_type</name></name></expr></argument>, <argument><expr><name>B_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>inp</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>dt_idnode_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_NOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>





<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_list</name></name> <operator>==</operator> <name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_list</name></name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_link</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_link</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bzero</name><argument_list>(<argument><expr><name>inp</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>dt_idnode_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>inp</name><operator>-&gt;</operator><name>din_list</name></name> <operator>=</operator> <name>dnp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>inp</name><operator>-&gt;</operator><name>din_root</name></name> <operator>=</operator> <name>dnp</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>idp</name><operator>-&gt;</operator><name>di_iarg</name></name> <operator>=</operator> <name>inp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>idp</name><operator>-&gt;</operator><name>di_ctfp</name></name> <operator>=</operator> <name><name>dsp</name><operator>-&gt;</operator><name>ds_ctfp</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>idp</name><operator>-&gt;</operator><name>di_type</name></name> <operator>=</operator> <name><name>dsp</name><operator>-&gt;</operator><name>ds_type</name></name></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><name>int</name></type>
<name>dt_decl_type</name><parameter_list>(<parameter><decl><type><name>dt_decl_t</name> <modifier>*</modifier></type><name>ddp</name></decl></parameter>, <parameter><decl><type><name>dtrace_typeinfo_t</name> <modifier>*</modifier></type><name>tip</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name> <init>= <expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>dt_module_t</name> <modifier>*</modifier></type><name>dmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_arinfo_t</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_id_t</name></type> <name>type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>n</name><index>[<expr><name>DT_TYPE_NAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint_t</name></type> <name>flag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>tip</name><operator>-&gt;</operator><name>dtt_flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>





<expr_stmt><expr><name>dmp</name> <operator>=</operator> <ternary><condition><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_idepth</name></name></expr> ?</condition><then> <expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_cdefs</name></name></expr> </then><else>: <expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_ddefs</name></name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>flag</name> <operator>=</operator> <ternary><condition><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_dstack</name><operator>.</operator><name>ds_next</name></name></expr> ?</condition><then> <expr><name>CTF_ADD_NONROOT</name></expr> </then><else>: <expr><name>CTF_ADD_ROOT</name></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_attr</name></name> <operator>&amp;</operator> <name>DT_DA_USER</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>tip</name><operator>-&gt;</operator><name>dtt_flags</name></name> <operator>=</operator> <name>DTT_FL_USER</name></expr>;</expr_stmt></block_content></block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_ctfp</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name>dmp</name> <operator>=</operator> <call><name>dt_module_lookup_by_ctf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_ctfp</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>tip</name><operator>-&gt;</operator><name>dtt_object</name></name> <operator>=</operator> <name><name>dmp</name><operator>-&gt;</operator><name>dm_name</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tip</name><operator>-&gt;</operator><name>dtt_ctfp</name></name> <operator>=</operator> <name><name>ddp</name><operator>-&gt;</operator><name>dd_ctfp</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tip</name><operator>-&gt;</operator><name>dtt_type</name></name> <operator>=</operator> <name><name>ddp</name><operator>-&gt;</operator><name>dd_type</name></name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>








<if_stmt><if>if <condition>(<expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_kind</name></name> <operator>==</operator> <name>CTF_K_FUNCTION</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>tip</name><operator>-&gt;</operator><name>dtt_object</name></name> <operator>=</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_ddefs</name><operator>-&gt;</operator><name>dm_name</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tip</name><operator>-&gt;</operator><name>dtt_ctfp</name></name> <operator>=</operator> <call><name>DT_FUNC_CTFP</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tip</name><operator>-&gt;</operator><name>dtt_type</name></name> <operator>=</operator> <call><name>DT_FUNC_TYPE</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>






<if_stmt><if>if <condition>(<expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_kind</name></name> <operator>==</operator> <name>CTF_K_POINTER</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_next</name><operator>-&gt;</operator><name>dd_kind</name></name> <operator>==</operator> <name>CTF_K_FUNCTION</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>tip</name><operator>-&gt;</operator><name>dtt_object</name></name> <operator>=</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_ddefs</name><operator>-&gt;</operator><name>dm_name</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tip</name><operator>-&gt;</operator><name>dtt_ctfp</name></name> <operator>=</operator> <call><name>DT_FPTR_CTFP</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tip</name><operator>-&gt;</operator><name>dtt_type</name></name> <operator>=</operator> <call><name>DT_FPTR_TYPE</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rv</name> <operator>=</operator> <call><name>dt_decl_type</name><argument_list>(<argument><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_next</name></name></expr></argument>, <argument><expr><name>tip</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><name>rv</name> <operator>=</operator> <call><name>dt_type_pointer</name><argument_list>(<argument><expr><name>tip</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xywarn</name><argument_list>(<argument><expr><name>D_UNKNOWN</name></expr></argument>, <argument><expr><literal type="string">"cannot find type: %s*: %s\n"</literal></expr></argument>,
<argument><expr><call><name>dt_type_name</name><argument_list>(<argument><expr><name><name>tip</name><operator>-&gt;</operator><name>dtt_ctfp</name></name></expr></argument>, <argument><expr><name><name>tip</name><operator>-&gt;</operator><name>dtt_type</name></name></expr></argument>,
<argument><expr><name>n</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ctf_errmsg</name><argument_list>(<argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_ctferr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><name>rv</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>


























<if_stmt><if>if <condition>(<expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_kind</name></name> <operator>==</operator> <name>CTF_K_ARRAY</name></expr>)</condition> <block>{<block_content>




<if_stmt><if>if <condition>(<expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_node</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
<name><name>ddp</name><operator>-&gt;</operator><name>dd_node</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_TYPE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>tip</name><operator>-&gt;</operator><name>dtt_object</name></name> <operator>=</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_ddefs</name><operator>-&gt;</operator><name>dm_name</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tip</name><operator>-&gt;</operator><name>dtt_ctfp</name></name> <operator>=</operator> <call><name>DT_DYN_CTFP</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tip</name><operator>-&gt;</operator><name>dtt_type</name></name> <operator>=</operator> <call><name>DT_DYN_TYPE</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rv</name> <operator>=</operator> <call><name>dt_decl_type</name><argument_list>(<argument><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_next</name></name></expr></argument>, <argument><expr><name>tip</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>rv</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>






<if_stmt><if>if <condition>(<expr><name><name>tip</name><operator>-&gt;</operator><name>dtt_ctfp</name></name> <operator>!=</operator> <name><name>dmp</name><operator>-&gt;</operator><name>dm_ctfp</name></name> <operator>&amp;&amp;</operator>
<name><name>tip</name><operator>-&gt;</operator><name>dtt_ctfp</name></name> <operator>!=</operator> <call><name>ctf_parent_file</name><argument_list>(<argument><expr><name><name>dmp</name><operator>-&gt;</operator><name>dm_ctfp</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>tip</name><operator>-&gt;</operator><name>dtt_type</name></name> <operator>=</operator> <call><name>ctf_add_type</name><argument_list>(<argument><expr><name><name>dmp</name><operator>-&gt;</operator><name>dm_ctfp</name></name></expr></argument>,
<argument><expr><name><name>tip</name><operator>-&gt;</operator><name>dtt_ctfp</name></name></expr></argument>, <argument><expr><name><name>tip</name><operator>-&gt;</operator><name>dtt_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tip</name><operator>-&gt;</operator><name>dtt_ctfp</name></name> <operator>=</operator> <name><name>dmp</name><operator>-&gt;</operator><name>dm_ctfp</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>tip</name><operator>-&gt;</operator><name>dtt_type</name></name> <operator>==</operator> <name>CTF_ERR</name> <operator>||</operator>
<call><name>ctf_update</name><argument_list>(<argument><expr><name><name>tip</name><operator>-&gt;</operator><name>dtt_ctfp</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CTF_ERR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xywarn</name><argument_list>(<argument><expr><name>D_UNKNOWN</name></expr></argument>, <argument><expr><literal type="string">"failed to copy type: %s\n"</literal></expr></argument>,
<argument><expr><call><name>ctf_errmsg</name><argument_list>(<argument><expr><call><name>ctf_errno</name><argument_list>(<argument><expr><name><name>tip</name><operator>-&gt;</operator><name>dtt_ctfp</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>





<expr_stmt><expr><name><name>r</name><operator>.</operator><name>ctr_contents</name></name> <operator>=</operator> <name><name>tip</name><operator>-&gt;</operator><name>dtt_type</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>r</name><operator>.</operator><name>ctr_index</name></name> <operator>=</operator> <call><name>ctf_lookup_by_name</name><argument_list>(<argument><expr><name><name>tip</name><operator>-&gt;</operator><name>dtt_ctfp</name></name></expr></argument>, <argument><expr><literal type="string">"long"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>r</name><operator>.</operator><name>ctr_nelems</name></name> <operator>=</operator> <ternary><condition><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_node</name></name></expr> ?</condition><then>
<expr><operator>(</operator><name>uint_t</name><operator>)</operator><name><name>ddp</name><operator>-&gt;</operator><name>dd_node</name><operator>-&gt;</operator><name>dn_value</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tip</name><operator>-&gt;</operator><name>dtt_object</name></name> <operator>=</operator> <name><name>dmp</name><operator>-&gt;</operator><name>dm_name</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tip</name><operator>-&gt;</operator><name>dtt_ctfp</name></name> <operator>=</operator> <name><name>dmp</name><operator>-&gt;</operator><name>dm_ctfp</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tip</name><operator>-&gt;</operator><name>dtt_type</name></name> <operator>=</operator> <call><name>ctf_add_array</name><argument_list>(<argument><expr><name><name>dmp</name><operator>-&gt;</operator><name>dm_ctfp</name></name></expr></argument>, <argument><expr><name>CTF_ADD_ROOT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>tip</name><operator>-&gt;</operator><name>dtt_type</name></name> <operator>==</operator> <name>CTF_ERR</name> <operator>||</operator>
<call><name>ctf_update</name><argument_list>(<argument><expr><name><name>tip</name><operator>-&gt;</operator><name>dtt_ctfp</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CTF_ERR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xywarn</name><argument_list>(<argument><expr><name>D_UNKNOWN</name></expr></argument>, <argument><expr><literal type="string">"failed to create array type: %s\n"</literal></expr></argument>,
<argument><expr><call><name>ctf_errmsg</name><argument_list>(<argument><expr><call><name>ctf_errno</name><argument_list>(<argument><expr><name><name>tip</name><operator>-&gt;</operator><name>dtt_ctfp</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>





<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>alloca</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_name</name></name></expr> ?</condition><then> <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_name</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">20</literal></expr> </then><else>: <expr><literal type="number">20</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_kind</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>CTF_K_INTEGER</name></expr>:</case>
<case>case <expr><name>CTF_K_FLOAT</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_attr</name></name> <operator>&amp;</operator> <name>DT_DA_SIGNED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>strcat</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"signed "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_attr</name></name> <operator>&amp;</operator> <name>DT_DA_UNSIGNED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>strcat</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"unsigned "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_attr</name></name> <operator>&amp;</operator> <name>DT_DA_SHORT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>strcat</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"short "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_attr</name></name> <operator>&amp;</operator> <name>DT_DA_LONG</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>strcat</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"long "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_attr</name></name> <operator>&amp;</operator> <name>DT_DA_LONGLONG</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>strcat</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"long long "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_attr</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>ddp</name><operator>-&gt;</operator><name>dd_name</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>strcat</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"int"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>CTF_K_STRUCT</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>strcpy</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"struct "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CTF_K_UNION</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>strcpy</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"union "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CTF_K_ENUM</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>strcpy</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"enum "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CTF_K_TYPEDEF</name></expr>:</case>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>xywarn</name><argument_list>(<argument><expr><name>D_UNKNOWN</name></expr></argument>, <argument><expr><literal type="string">"internal error -- "</literal>
<literal type="string">"bad decl kind %u\n"</literal></expr></argument>, <argument><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_kind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></switch>





<if_stmt><if>if <condition>(<expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_name</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ddp</name><operator>-&gt;</operator><name>dd_kind</name></name> <operator>!=</operator> <name>CTF_K_INTEGER</name> <operator>||</operator>
<operator>(</operator><name><name>ddp</name><operator>-&gt;</operator><name>dd_attr</name></name> <operator>&amp;</operator> <operator>(</operator><name>DT_DA_SHORT</name> <operator>|</operator> <name>DT_DA_LONG</name> <operator>|</operator> <name>DT_DA_LONGLONG</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>strcat</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>






<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rv</name> <operator>=</operator> <call><name>dt_type_lookup</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>tip</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>rv</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_kind</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>CTF_K_STRUCT</name></expr>:</case>
<case>case <expr><name>CTF_K_UNION</name></expr>:</case>
<case>case <expr><name>CTF_K_ENUM</name></expr>:</case>
<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>ctf_add_forward</name><argument_list>(<argument><expr><name><name>dmp</name><operator>-&gt;</operator><name>dm_ctfp</name></name></expr></argument>, <argument><expr><name>flag</name></expr></argument>,
<argument><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_name</name></name></expr></argument>, <argument><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_kind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>xywarn</name><argument_list>(<argument><expr><name>D_UNKNOWN</name></expr></argument>, <argument><expr><literal type="string">"failed to resolve type %s: %s\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>,
<argument><expr><call><name>dtrace_errmsg</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><call><name>dtrace_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>rv</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>CTF_ERR</name> <operator>||</operator> <call><name>ctf_update</name><argument_list>(<argument><expr><name><name>dmp</name><operator>-&gt;</operator><name>dm_ctfp</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CTF_ERR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xywarn</name><argument_list>(<argument><expr><name>D_UNKNOWN</name></expr></argument>, <argument><expr><literal type="string">"failed to add forward tag for %s: %s\n"</literal></expr></argument>,
<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>ctf_errmsg</name><argument_list>(<argument><expr><call><name>ctf_errno</name><argument_list>(<argument><expr><name><name>dmp</name><operator>-&gt;</operator><name>dm_ctfp</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_ctfp</name></name> <operator>=</operator> <name><name>dmp</name><operator>-&gt;</operator><name>dm_ctfp</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tip</name><operator>-&gt;</operator><name>dtt_object</name></name> <operator>=</operator> <name><name>dmp</name><operator>-&gt;</operator><name>dm_name</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tip</name><operator>-&gt;</operator><name>dtt_ctfp</name></name> <operator>=</operator> <name><name>dmp</name><operator>-&gt;</operator><name>dm_ctfp</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tip</name><operator>-&gt;</operator><name>dtt_type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>dt_scope_create</name><parameter_list>(<parameter><decl><type><name>dt_scope_t</name> <modifier>*</modifier></type><name>dsp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_decl</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ctfp</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_type</name></name> <operator>=</operator> <name>CTF_ERR</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_class</name></name> <operator>=</operator> <name>DT_DC_DEFAULT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_enumval</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>dt_scope_destroy</name><parameter_list>(<parameter><decl><type><name>dt_scope_t</name> <modifier>*</modifier></type><name>dsp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_scope_t</name> <modifier>*</modifier></type><name>nsp</name></decl>;</decl_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>dsp</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>dsp</name> <operator>=</operator> <name>nsp</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>dt_decl_free</name><argument_list>(<argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_decl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nsp</name> <operator>=</operator> <name><name>dsp</name><operator>-&gt;</operator><name>ds_next</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>dsp</name> <operator>!=</operator> <operator>&amp;</operator><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_dstack</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>dsp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>dt_scope_push</name><parameter_list>(<parameter><decl><type><name>ctf_file_t</name> <modifier>*</modifier></type><name>ctfp</name></decl></parameter>, <parameter><decl><type><name>ctf_id_t</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_scope_t</name> <modifier>*</modifier></type><name>rsp</name> <init>= <expr><operator>&amp;</operator><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_dstack</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_scope_t</name> <modifier>*</modifier></type><name>dsp</name> <init>= <expr><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>dt_scope_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>dsp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_NOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_decl</name></name> <operator>=</operator> <name><name>rsp</name><operator>-&gt;</operator><name>ds_decl</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_next</name></name> <operator>=</operator> <name><name>rsp</name><operator>-&gt;</operator><name>ds_next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name> <operator>=</operator> <name><name>rsp</name><operator>-&gt;</operator><name>ds_ident</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ctfp</name></name> <operator>=</operator> <name>ctfp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_class</name></name> <operator>=</operator> <name><name>rsp</name><operator>-&gt;</operator><name>ds_class</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_enumval</name></name> <operator>=</operator> <name><name>rsp</name><operator>-&gt;</operator><name>ds_enumval</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>dt_scope_create</name><argument_list>(<argument><expr><name>rsp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rsp</name><operator>-&gt;</operator><name>ds_next</name></name> <operator>=</operator> <name>dsp</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>dt_decl_t</name> <modifier>*</modifier></type>
<name>dt_scope_pop</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_scope_t</name> <modifier>*</modifier></type><name>rsp</name> <init>= <expr><operator>&amp;</operator><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_dstack</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_scope_t</name> <modifier>*</modifier></type><name>dsp</name> <init>= <expr><name><name>rsp</name><operator>-&gt;</operator><name>ds_next</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>dsp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_NOSCOPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ctfp</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>ctf_update</name><argument_list>(<argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ctfp</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CTF_ERR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_UNKNOWN</name></expr></argument>, <argument><expr><literal type="string">"failed to update type definitions: %s\n"</literal></expr></argument>,
<argument><expr><call><name>ctf_errmsg</name><argument_list>(<argument><expr><call><name>ctf_errno</name><argument_list>(<argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ctfp</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>dt_decl_free</name><argument_list>(<argument><expr><name><name>rsp</name><operator>-&gt;</operator><name>ds_decl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>rsp</name><operator>-&gt;</operator><name>ds_ident</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rsp</name><operator>-&gt;</operator><name>ds_decl</name></name> <operator>=</operator> <name><name>dsp</name><operator>-&gt;</operator><name>ds_decl</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rsp</name><operator>-&gt;</operator><name>ds_next</name></name> <operator>=</operator> <name><name>dsp</name><operator>-&gt;</operator><name>ds_next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rsp</name><operator>-&gt;</operator><name>ds_ident</name></name> <operator>=</operator> <name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rsp</name><operator>-&gt;</operator><name>ds_ctfp</name></name> <operator>=</operator> <name><name>dsp</name><operator>-&gt;</operator><name>ds_ctfp</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rsp</name><operator>-&gt;</operator><name>ds_type</name></name> <operator>=</operator> <name><name>dsp</name><operator>-&gt;</operator><name>ds_type</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rsp</name><operator>-&gt;</operator><name>ds_class</name></name> <operator>=</operator> <name><name>dsp</name><operator>-&gt;</operator><name>ds_class</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rsp</name><operator>-&gt;</operator><name>ds_enumval</name></name> <operator>=</operator> <name><name>dsp</name><operator>-&gt;</operator><name>ds_enumval</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>dsp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name><name>rsp</name><operator>-&gt;</operator><name>ds_decl</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
</unit>
